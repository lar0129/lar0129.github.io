<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Adaptive radix tree：高效自适应树状索引结构</title>
    <url>/2023/12/10/Index-ART/</url>
    <content><![CDATA[<p>文献阅读：The adaptive radix tree: ARTful indexing for main-memory databases</p>
<span id="more"></span>

<blockquote>
<p> <a href="https://zhuanlan.zhihu.com/p/644667990">高效内存索引：Adaptive Radix Tree - 知乎 (zhihu.com)</a></p>
<p><a href="https://blog.51cto.com/u_11908275/6405376">数据库索引数据结构总结——ART树就是前缀树_11898275的技术博客_51CTO博客</a></p>
<p><a href="https://blog.csdn.net/qq_35423154/article/details/130119444">高级数据结构与算法 | 自适应基数树（Adaptive Radix Tree）-CSDN博客</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/617343461">论文阅读: The Adaptive Radix Tree: ARTful Indexing for Main-Memory Databases - 知乎 (zhihu.com)</a></p>
</blockquote>
<h1 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h1><p>我们以每个节点存 2-bits 为例，假设 Trie 中存储了 7, 10, 12，从下图可以看到这三个数的二进制表示。每个节点的值由 0 和 1 组成，同时每个节点包含指向所有子节点的指针，指针为 * 代表该子节点存在，指针为 Ø 代表改子节点不存在。最终由叶子节点指向实际的数据。</p>
<p><img src="https://pic4.zhimg.com/80/v2-4ab897ae16b3786ebdcbe45d581f74f3_1440w.webp"><span class="image-caption">img</span></p>
<h1 id="Radix-Trie"><a href="#Radix-Trie" class="headerlink" title="Radix Trie"></a>Radix Trie</h1><p>压缩后的节点需要将路径的前缀存储下来，如下：</p>
<p><img src="https://pic4.zhimg.com/80/v2-fc40986adca46f26ef480f3e98133e53_1440w.webp"><span class="image-caption">img</span></p>
<p>前两层的节点都只有一个子节点，将它们折叠到第三层的节点，保存折叠路径的前缀 0000，形成一个新节点，如下所示：</p>
<p><img src="https://pic1.zhimg.com/80/v2-fdd41137e2c6622b65a8bea74548941c_1440w.webp"><span class="image-caption">img</span></p>
<p>查找时，遇到折叠过的节点，要比较前缀是否匹配。经过垂直压缩，减少了节点树和层级树，节约了大量空间，但是依然没有解决空指针浪费的问题。</p>
<h1 id="AdaptiveRadixTree"><a href="#AdaptiveRadixTree" class="headerlink" title="AdaptiveRadixTree"></a>AdaptiveRadixTree</h1><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><blockquote>
<p>论文链接：<br><a href="https://db.in.tum.de/~leis/papers/ART.pdf">The Adaptive Radix Tree: ARTful Indexing for Main-Memory Databases</a><br><a href="https://db.in.tum.de/~leis/papers/artsync.pdf">The ART of Practical Synchronization</a></p>
</blockquote>
<p>Adaptive Radix Tree（ART）是由 Phil Bagwell 在 2000 年提出的一种基于 Trie Tree 实现的数据结构，旨在解决 Trie Tree 在空间效率和查找性能方面存在的问题。与其他基于 Trie 的数据结构（如 Radix Tree、Digital Search Tree）相比，其引入了自适应节点，高度压缩等特性，具有更好的空间效率和更快的查找速度。</p>
<p>相对于传统的基于比较的搜索树（如红黑树、AVL 树、B+ 树），ART 具有以下特点：</p>
<ul>
<li>ART 的高度取决于 Key 的长度，而非树中元素的数量。</li>
<li>ART 不需要平衡操作，且所有插入顺序产生的树都是相同的。</li>
<li>Key 按照字典序进行存储。</li>
<li>从根节点到叶子节点的路径代表着其对应的 Key，因此 Key 是隐式存储的，可以通过路径重新构造。</li>
</ul>
<p>假设字符串比较操作开销为 O(1)，字符串长度为 k，基于比较的搜索树的查询复杂度为 O(klogn)，而 ART 为 O(k)。</p>
<p>ART 适用于许多高效查找的应用场景，例如数据库内存索引，路由表等。</p>
<h3 id="自适应节点"><a href="#自适应节点" class="headerlink" title="自适应节点"></a>自适应节点</h3><p>ART 中包含了两种类型的节点：</p>
<ul>
<li><strong>内部节点</strong>：内部节点，将 key 映射到其他节点，用于表示路径。</li>
<li><strong>叶子节点</strong>：存储实际的 value 数据。</li>
</ul>
<h4 id="内部节点"><a href="#内部节点" class="headerlink" title="内部节点"></a>内部节点</h4><p>根据容量不同，ART 内部节点使用了四种不一样的内部结构。</p>
<ul>
<li><p><strong>Node4</strong></p>
<ul>
<li><p>Node4 是最小的节点类型，其由 4 个 key 以及对应 4 个子指针组成。key 和子指针存储在相同的位置，并以 key 为基准进行排序。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/af7f3dee5c1130e5617cc9c4e078c151.png"><span class="image-caption">img</span></p>
<p><strong>Node4</strong>，由一个长度为 4 的 byte 数组和长度为 4 的指针数组构成，最多存储 4 个不同的 key 及其对应的子节点指针。一共占用 40（4<em>1 + 4</em>8）bytes。有效指针个数小于等于 4 时，使用这种类型的节点存储如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-fdafe53b5a266456b3315a053a563ee8_1440w.webp"><span class="image-caption">img</span></p>
<p>查找时，需要遍历 byte 数组，判断当前要查找的 key 是否在数组中。由于数据长度小，遍历的开销也就很低。</p>
</li>
</ul>
</li>
<li><p>Node16</p>
<ul>
<li>Node16 是 Node4 的扩容版本，其存储着 16 个 key 和子指针。<img src="https://img-blog.csdnimg.cn/img_convert/0a5a6fa97dd5a6bd8d597958ce4cc970.png"><span class="image-caption">img</span></li>
</ul>
</li>
<li><p>Node48</p>
<ul>
<li><p>由于节点中存储的内容增加，遍历 key 数组的开销也随之增加，因此 Node48 采用了另一种存储方式，不再显式存储 key，而是由一个长度为 256 的索引和 48 个指针组成。索引的每个位置正好对应了 <code>unsigned char</code> 类型的 0~255。每个索引的对应位置存储了对应子指针的下标（不存在的始终标记为 0）。这里为了节省空间，带来了间接查询的开销。<img src="https://img-blog.csdnimg.cn/img_convert/c1866f48d7321eefcc587610d8074499.png"><span class="image-caption">img</span></p>
</li>
<li><p><img src="https://pic3.zhimg.com/80/v2-d0681f378ca7818b19a92d2df0a76366_1440w.webp"><span class="image-caption">img</span></p>
<p>由于 byte 数组和指针数组长度不对齐，需要通过一定的方式将它们映射起来：byte 数组的下标表示 key，值表示 key 对应的子节点指针在指针数组的位置。</p>
<p>查找 Node48 时，我们可以跟据查找的 key 快速定位到其在节点中的位置（key的值便是下标值），获取其对应的子节点指针。时间复杂多为 O(1) ，这是典型的空间换时间做法，但需要多一次内存访问时间。</p>
</li>
</ul>
</li>
<li><p>Node256</p>
<ul>
<li><p>Node256 是一个包含了 256 个指针的数组，相比较与 Node48，其一次查询即可得到结果。由于只存储指针，即使大部分位置为空，也不会过于浪费空间。<img src="https://img-blog.csdnimg.cn/img_convert/6e61c8e4abe1d04433891baae05714f3.png"><span class="image-caption">img</span></p>
</li>
<li><p><strong>Node256</strong>，由长度为 256 的指针数组构成，一共占用 2048（256 * 8）bytes。有效指针个数在 49~256 时，使用这种类型的节点存储，如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-2d4ce8456363a9ddc230b73b3cd2a2f0_1440w.webp"><span class="image-caption">img</span></p>
<p>指针数组的下标代表 key，值代表其对应的子节点指针。查找是，可以快速得到子节点指针，时间复杂度为 O(1) 。</p>
</li>
</ul>
</li>
</ul>
<p>每个内部节点中还包含了一个 header，用于存储节点类型、子节点数量和压缩的路径以及 span（标识压缩路径的深度）。</p>
<h4 id="叶子节点"><a href="#叶子节点" class="headerlink" title="叶子节点"></a>叶子节点</h4><p>除了内部节点存储的路径之外，ART 还需要将 value 存储在叶子节点上。假设只存储唯一 key，叶节点可以使用以下三种不同的结构：</p>
<ul>
<li><strong>单值叶节点</strong>：使用额外的叶节点类型存储一个值。</li>
<li><strong>多值叶节点</strong>：使用四种不同的叶节点类型之一来存储值，这些叶节点类型可以复用内部节点的结构，但存储值而不是指针</li>
<li><strong>组合指针&#x2F;值 slot</strong>：如果值适合指针，则不需要单独的节点类型。相反，内部节点中的每个指针存储位置可以存储指针或值。每个指针可以使用一个额外的附加位或在指针中做标记来区分。</li>
</ul>
<p>单值叶节点是最通用的方法，其允许在一个树中使用不同长度的 key 和 value。但是，由于树高度的增加，每次查找的时候都会有一次额外的指针遍历。</p>
<p>多值叶节点避免了这种开销，但要求树中的所有 key 具有相同的长度。</p>
<p>组合指针&#x2F;值 slot 是最高效的，允许存储不同长度的 key。通常情况下都会考虑使用这个，它特别适用于存储元组标识符或与指针相同大小的数据库二级索引。</p>
<h3 id="与其他数据结构比较"><a href="#与其他数据结构比较" class="headerlink" title="与其他数据结构比较"></a>与其他数据结构比较</h3><p>数据库常用的索引结构有 Hash 索引、B+ Tree 等，那么 ART 对比这些索引有什么优势呢？</p>
<p>ART 通过路径压缩、自适应节点分配极大的减少了空间浪费。相比 B+ Tree，其内部节点更小，占用空间更少，更适合 cpu cache，在纯内存场景，ART 优势明显。同时 ART 也拥有极佳的点查性能（最坏情况为 O(k) ），也更适合前缀匹配查询。</p>
<p>B+ Tree 的优势在于树高度小且平衡，更适合作为传统数据库的磁盘索引。B+ Tree 能提供稳定高效的查询性能，且范围查询性能也很突出。因此作为磁盘索引，B+ Tree 更有优势。</p>
<p><img src="https://s2.51cto.com/images/blog/202305/30103228_6475603cb89ee32978.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184"><span class="image-caption">数据库索引数据结构总结——ART树就是前缀树_数据库</span></p>
<p>Hash 索引常常能提供高效的点查性能，但是范围查询、前缀查询性能极差（全扫）。因此，Hash 索引常常用于加速点查，使用比较局限。</p>
<h3 id="高度压缩"><a href="#高度压缩" class="headerlink" title="高度压缩"></a>高度压缩</h3><p>如下图，为了节省空间，ART 中采用了 Path Compression（路径压缩） 和 Lazy Expansion（惰性拓展） 两种技术来尽可能的减少节点数量，压缩树的高度。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5a8d4e623a326c9adf9469854dd58a45.png"><span class="image-caption">img</span></p>
<p>Path Compression &amp;&amp; Lazy Expansion</p>
<h4 id="Path-Compression"><a href="#Path-Compression" class="headerlink" title="Path Compression"></a>Path Compression</h4><p>Path Compression 用于移除只有单个子节点的节点，例如图左侧中，B 节点仅有单个子节点 A，此时会将它们合并为 BA。由于合并后出现了前缀，此时需要在存储结构中将其表述出来，通常有以下两种方式：</p>
<ul>
<li><strong>悲观</strong>：每个节点额外使用一个变长 vector 存储前缀，在查找过程中要额外对其进行比较，因此称为悲观。</li>
<li><strong>乐观</strong>：用一个计数器记录前缀的长度，向下遍历时跳过这个长度，到了叶子节点后在回头进行前缀的比较。</li>
</ul>
<p>悲观策略使用更多的空间，同时变长 vector 可能会导致内存碎片。而乐观策略则增加了额外的字符串比较开销。由于两者各有优缺点，在 ART 中会根据使用场景的不同来决定具体的策略。默认使用悲观策略，每个节点最多存储 8 字节的前缀，如果超过这个大小，则切换到乐观策略。</p>
<h4 id="Lazy-Expansion"><a href="#Lazy-Expansion" class="headerlink" title="Lazy Expansion"></a>Lazy Expansion</h4><p>Lazy Expansion 指的是只有在需要使用内部节点来区分两个叶子节点时，才会创建内部节点。如上图右侧，在 F 路径中只存在 FOO 单个节点，不需要区分，因此两个 O 节点会被删除掉，只有再插入另外一个共享前缀 F 的节点时才会拓展。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/7ca14677a1cf65056b2da1ea8a69bf44.webp?x-oss-process=image/format,png"><span class="image-caption">img</span></p>
<p>查找算法</p>
<p>上图为查找逻辑的伪代码，执行的流程如下：</p>
<ol>
<li>判断节点是否为空，如果空则返回，否则继续。</li>
<li>判断节点是否为叶子节点，如果是叶子节点，则根据节点存储的 key 是否完全相等，判断查询是否成功（乐观策略在这个地方进行）。</li>
<li>如果当前节点不是叶子节点，则判断当前节点的前缀和需要查找的是否一致，如果不一致则中止匹配（悲观策略在这个地方进行）。</li>
<li>如果前面几轮判断都没查找到，此时则通过 <code>findChild</code> 找到下一个节点，继续递归下去查询。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/52d022423a27369b11b4340bc26d4762.webp?x-oss-process=image/format,png"><span class="image-caption">img</span></p>
<p>内部节点查找算法</p>
<p><code>findChild</code> 中主要描述了四种不同的内部节点类型中如何通过 key 找到子节点指针：</p>
<ul>
<li>Node4：遍历 key 数组，返回对应的 child。</li>
<li>Node16：通过 SIMD（不可用时使用二分搜索）来进行数组匹配，找到对应的 child。</li>
<li>Node48：通过字符序，判断 index 中对应下标存储的 child 数组下标是否为 0，如果不为 0 则根据下标找到对应的 child。</li>
<li>Node256：直接根据字符序，返回对应下标存储的 child。</li>
</ul>
<h4 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/abf453718f36401253c3b5aa4bf5b8d7.png"><span class="image-caption">img</span></p>
<p>插入算法</p>
<p>插入的流程如下：</p>
<ol>
<li>判断节点是否为空，如果为空则用叶子节点替换掉该节点。</li>
<li>判断节点是否为叶子节点，如果是则判断 key 是否相同，如果相同则直接返回。如果不同，此时则考虑对 lazy expansion 的拓展操作，将两个节点的公共前缀作为新内部节点的 Key，并将两个节点作为其子节点。</li>
<li>如果不是叶子节点，则首先比较前缀，如果前缀不相同，此时将生成一个新节点，将两个节点的公共前缀作为该节点的前缀，并将叶子节点节点和原来的老节点（截断公共前缀后）一起插入到这个新节点中。</li>
<li>如果仍然存在下一个节点，则继续向下递归执行，否则先判断节点是否已满，决定是否要调用 <code>grow</code> 进行节点扩容，再将叶子节点插入。</li>
</ol>
<h4 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h4><p>删除算法的思路与插入的大致相同，为其逆向操作，在这里就不过多赘述。如果删除叶子节点后内部节点过少，则会收缩内部节点的容量，如果只有一个子节点，此时则使用 Path Compression 压缩路径。</p>
<h4 id="Bulk-loading"><a href="#Bulk-loading" class="headerlink" title="Bulk loading"></a>Bulk loading</h4><p>在存在大量数据时，使用下面的递归算法可以加速索引的构建：</p>
<ol>
<li>将每个 key 的第一个字节用于基数分区（分为 256 个），并创建相应类型的内部节点。</li>
<li>在返回该内部节点之前，通过对每个分区使用下一个字节的 key，来递归加载其子节点。</li>
<li>重复步骤 2，直到所有的 key&#x2F;value 都被插入树中。</li>
</ol>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>传统的细粒度锁的拓展性较差（对于现代 CPU），而无锁结构虽然拓展性好，但是其实现又十分复杂、困难，因此在 ART 中采取了另外两种方法，<strong>Optimistic Lock Coupling</strong>（乐观锁耦合）和 <strong>Read-Optimized Write EXclusion</strong>（ROWEX，读优化写排除）。</p>
<h4 id="乐观锁耦合Optimistic-Lock-Coupling"><a href="#乐观锁耦合Optimistic-Lock-Coupling" class="headerlink" title="乐观锁耦合Optimistic Lock Coupling"></a>乐观锁耦合Optimistic Lock Coupling</h4><p>首先介绍一下什么是<strong>锁耦合（Lock Coupling）</strong>，其是多线程操作树结构时使用的一种同步技术。<strong>其有两个锁，当遍历树时，一个锁住父节点，一个锁住当前的节点</strong>，然后向下行走，重复这个过程，直到完成对节点的操作。（由于很像螃蟹行走的方式，所以有的人称其为蟹形协议）。</p>
<p>乐观锁耦合就是将乐观锁的思路与锁耦合合并起来，引入了版本号，下面给出悲观锁耦合和乐观锁耦合的对比代码：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2ff5a58e5c2673b0e4fc42442869eca3.png"><span class="image-caption">image-20230409030735775</span><br>这里引入了两个原语</p>
<ul>
<li><strong>readLockOrRestart</strong>：不获取锁，等待写锁释放后获取节点当前的版本。</li>
<li><strong>readUnlockOrRestart</strong>：等待写锁释放，检测版本号，如果版本变更则重启读操作。</li>
</ul>
<p>总结一下，其具有以下范式：</p>
<ol>
<li>读不会获取锁，但是其会检测版本号，如果版本号变更则从根开始重新读。</li>
<li>写不会被读阻塞。</li>
<li>写需要获取锁，且写入后更新版本信息。</li>
</ol>
<blockquote>
<p>上面的算法需要满足以下条件才能正常运行：</p>
<ol>
<li>调用 <code>readLockOrRestart</code> 时，读线程可能会看到不一致的中间状态，为了避免无限循环和访问空指针，必须进行版本检查和指针检查。</li>
<li>删除节点时不能立即进行回收，需要延迟释放——即将节点标记后，等待没有线程引用时再进行回收。</li>
<li>极端情况下，读可能会被多次重启，为了确保读能够执行，可以限制重启的次数，次数达到限制后采用读写锁。</li>
</ol>
</blockquote>
<h4 id="读优化写排除（ROWEX）-乐观读悲观写"><a href="#读优化写排除（ROWEX）-乐观读悲观写" class="headerlink" title="读优化写排除（ROWEX）(乐观读悲观写)"></a>读优化写排除（ROWEX）(乐观读悲观写)</h4><p>从上面可以看出，当读在进行时，如果有人写入，则会因版本号变更而重启读行为。而如果这种冲突极端严重，则会导致读行为不断重启，甚至可能永远无法执行。因此 ART 通过 ROWEX 来改进这一问题，ROWEX 的核心就是<strong>读取不会被阻塞或者重启</strong>。</p>
<p>ROWEX 具有以下范式：</p>
<ol>
<li>读不需要加锁、阻塞，也不需要检查版本信息，因此其总是成功的。</li>
<li>每个节点中需要维护一个互斥锁，当进行读操作时获取该锁，该锁仅用于阻塞其他写行为。</li>
<li>写操作保证同一个节点读一致性，即写操作必须通过原子指令执行。</li>
</ol>
<h5 id="适配-ROWEX"><a href="#适配-ROWEX" class="headerlink" title="适配 ROWEX"></a>适配 ROWEX</h5><p>为了适配 ROWEX，ART 的结构需要进行以下变动：</p>
<ol>
<li>为了支持并发局部修改，内部节点的 key 和指针需要用 <code>std::atomic</code> 来管理。</li>
<li>对于线性内部结构（Node4、Node16），为了避免排序，采用仅追加的方式，删除则直接将子指针指向空。（虽然不排序时需要遍历整个数组，但是还可以用 SIMD 进行优化），</li>
</ol>
<p>下面以节点替换和路径压缩为例，说明 ART 中 ROWEX 是如何工作的。</p>
<h5 id="节点替换"><a href="#节点替换" class="headerlink" title="节点替换"></a>节点替换</h5><p>当一个节点容量过大&#x2F;小时，需要替换成其他内部节点类型，此时执行以下流程：</p>
<ol>
<li>对该节点和其父节点进行加锁，并创建一个新节点，将旧节点中的数据全部拷贝到新节点中。</li>
<li>通过原子操作修改父节点的子指针，让其指向新节点。</li>
<li>解锁旧节点，将其标记为删除。</li>
</ol>
<p>任何被阻塞的写操作在检测到该节点被标记后，都会重新开始整个插入&#x2F;删除行为。因此对于读操作来说，读取是始终安全的。</p>
<h5 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h5><p><img src="https://img-blog.csdnimg.cn/img_convert/b3a142d9652bac2b779a5a24b2797db8.webp?x-oss-process=image/format,png"><span class="image-caption">img</span></p>
<p>对于路径压缩来说，情况又更加复杂，这主要是因为<strong>创建节点和更新前缀这两个步骤无法在单个原子操作</strong>中完成，如果不做处理，则读取时可以会读到中间状态。</p>
<p>例如上图，一开始树中只有 ARE，ART，通过 Path Compression 将 AR 作为公共前缀。此时插入一个新节点 AS，此时会进行以下操作：</p>
<ol>
<li>创建一个新的内部节点 A，让根节点将子指针从 AR 指向它，它指向 R 和 S。（创建节点）</li>
<li>将 R 节点原先的前缀清空（更新前缀）</li>
</ol>
<p>由于这两个都是独立的原子操作，当我们在完成第一步后，此时的 R 节点仍然保留着前缀，对于它来说此时存储的路径变为了 ARR，这就导致了当前<strong>状态的不一致</strong>。</p>
<p>为了解决这个问题，每个节点中都需要增加一个 level 字段（代表存储节点的实际高度，即未被 Compression 前应该处于哪一层），这个字段初始化后就不再变更，其保证了中间状态始终安全。</p>
<ul>
<li>如果一个读取操作在某个节点看到了中间状态，它可以通过<strong>检查该节点的 level，判断出该节点的前缀是否已经被截断</strong>。如果前缀已经被截断，则读取操作可以跳过该节点，继续向下搜索。如果前缀没有被截断，则读取操作可以根据该节点的 level 字段，查找出缺失的 key。</li>
<li>以上图为例，当我们看到蓝色节点的中间状态时，会直接跳过该处的前缀（此时 level 应当为 3，检测到 2 说明为中间状态）。</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>Learned index 综述</title>
    <url>/2023/12/10/Index-Learned%20index/</url>
    <content><![CDATA[<p>Learned index 综述</p>
<span id="more"></span>



<h2 id="学习索引-learned-index-技术"><a href="#学习索引-learned-index-技术" class="headerlink" title="学习索引 (learned index) 技术"></a><strong>学习索引 (learned index) 技术</strong></h2><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>索引技术在数据库中扮演着重要角色, 在数据库中有 b tree, hash 索引等. 但是这些数据结构<strong>没有利用到被索引数据分布的信息</strong>. </p>
<p>本文总结了谷歌发表于 NIPS 2017 和 SIGMOD 2018 的两篇文章, 探讨如何利用机器学习技术得到更好的范围索引, 使用机器学习模型替代传统的 B-trees 索引, 以及在这之上的改进, 使得学习索引技术可扩展, 解决学习索引更新问题.</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>数据库依靠索引结构来高效地执行众多核心操作. <strong>B-trees 用于范围检索, Hash-Maps 用于按照键值搜索, 布隆过滤器用于判断 record 是否存在.</strong> </p>
<ul>
<li>但是这些索引是广义目的的数据结构, 没有利用到被索引数据的信息, 在一些极端情况下会表现得较差, </li>
<li>比如当数据键值为从 1 递增到 n, 如果使用 b-tree 索引, 查询的时间复杂度为 o(logn), 实际上只需要 o(1) 的复杂度. 同样索引的空间复杂度也只需要 o(1), 而不是 o(n).</li>
</ul>
<p>如果能够<strong>学习到一个模型反映数据的模式,</strong> 就有可能<strong>自动构建索引结构</strong>即学习索引 (learned index) , 进而得到显著性能提升.</p>
<ul>
<li>Kraska[1], [2] 等人提出使用机器学习模型代替传统的 B 树索引，并在真实数据集上取得了不错的效果，但其提出的模型假设工作负载是静态的、只读的，对于索引更新问题没有提出很好的解决办法. [3] 提出了基于中间层的可扩展的学习索引模型 Dabble，用来解决索引更新引发的模型重新训练问题.</li>
</ul>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a><strong>内容</strong></h2><h3 id="B-Trees-可以看成模型"><a href="#B-Trees-可以看成模型" class="headerlink" title="B-Trees 可以看成模型"></a><strong>B-Trees 可以看成模型</strong></h3><p>范围索引, 比如 B-Trees, 可以视为一个机器学习模型, 给定输入 Key 返回 position.</p>
<p><img src="https://pic3.zhimg.com/v2-86bbd7ed6fc91f848e656fe03bbc6c1e_r.jpg"></p>
<h4 id="一个极端的例子与数据分布"><a href="#一个极端的例子与数据分布" class="headerlink" title="一个极端的例子与数据分布"></a>一个极端的例子与数据分布</h4><p>一个极端的例子，一亿条数据，主键是整型从1到1亿，如果用B树的话，从根节点到一个个中间节点，非常麻烦，如果知道数据是这样分布的话，那肯定不会选择建索引，直接通过偏移量访问了。索引，<strong>一般索引都是不知道数据分布的，这样更具有通用性</strong>，但是通常来说，知道数据分布对于索引的优化(空间和查询效率)是通常都是非常有效的(比如对于稠密数据，用ART肯定没有用普通的span为8的前缀树表现好，尤其是索引的构建上)。但是对于这些传统索引来说，无论是了解数据分布，还是让索引为每种数据分布做专门的优化都过于复杂了。</p>
<p>于是有了用机器学习来学习出一个能够<strong>反映数据分布</strong>，并能<strong>自动生成出特定的索引结构</strong>的想法。</p>
<blockquote>
<p>前面提到了B树需要保证要要查询的key必须在一个区间内，第一感觉用机器学习模型不简单，但事实并非如此。因为这个保证是给已经存储的key，而不是任意key，<strong>对于新来的key，B树需要重新平衡，对于学习型索引需要重新训练</strong>。再有就是这个错误边界并不是一定要有的，因为数据是有序的，误差也很容易纠正通过在预测值附近进行local search，比如用指数查找。因此，可以用其他回归模型，比如线性回归或神经网络来取代B树。</p>
</blockquote>
<h3 id="学习索引-learned-index"><a href="#学习索引-learned-index" class="headerlink" title="学习索引 (learned index)"></a><strong>学习索引 (learned index)</strong></h3><p><strong>学习索引要做的事是学习到一个映射函数, f(key)-&gt;pos, 将 key 写成 x, pos 写成 y, 希望学习到一个模型 f(x) 约等于 y.</strong> </p>
<ul>
<li>因为 x 是排序过的, 所以 f 实际上是在给数据的 CDF 建模 [4]. 下图是学习索引的一个示例.</li>
</ul>
<p><img src="https://pic2.zhimg.com/v2-6dd6a7a18af54282533a8e0726f0f2d1_r.jpg"></p>
<h3 id="模型架构"><a href="#模型架构" class="headerlink" title="模型架构"></a><strong>模型架构</strong></h3><p>上面的问题<strong>实质上是一个回归问题</strong>（给$x_i$求y。通过输入特征来预测连续数值输出）, 可以使用均方差作为损失函数, 训练模型. </p>
<p>同时<strong>为了提高模型的准确率, 使用层级模型</strong>. 损失函数如下所示</p>
<p><img src="https://pic2.zhimg.com/v2-ae8d609e8746db0082b9ac74ce86d605_r.jpg"></p>
<p>模型架构如下所示:</p>
<p><img src="https://pic4.zhimg.com/v2-5d87b69d40b38df60082e7f9cd22becf_r.jpg"></p>
<p>层级模型和集成模型的思路相似, 都是通过集成弱分类器得到性能更好的分类器.</p>
<h3 id="学习索引-learned-index-如何预测"><a href="#学习索引-learned-index-如何预测" class="headerlink" title="学习索引 (learned index) 如何预测"></a><strong>学习索引 (learned index) 如何预测</strong></h3><p>不同于一般的机器学习任务, 在使用学习索引 (learned index) 的时候, <strong>需要考虑模型输出偏差 delta</strong></p>
<ul>
<li>需要找到最大的误差 delta_max, 在 [y_pred-delta_max, y_pred+delta_max] 范围内搜寻起始点, 但是这个搜寻起始点可以使用二分查找, 时间复杂度不是很高.</li>
</ul>
<h3 id="Dabble-模型"><a href="#Dabble-模型" class="headerlink" title="Dabble 模型"></a><strong>Dabble 模型</strong></h3><p>之前其提出的模型假设工作负载是静态的、只读的，对于<strong>索引更新问题</strong>没有提出很好的解决办法. 因此提出了<strong>基于中间层的可扩展的学习索引模型 Dabble</strong></p>
<ul>
<li>用来解决<strong>索引更新引发的模型重训练</strong>问题</li>
</ul>
<p>实验：</p>
<p>Dabble 模型中设计了 3 个机制:</p>
<ul>
<li>(1) 利用聚类算法将数据集按照数据的聚集方式划分为 K 个部分, 得到 K 个数据区域, 使得<strong>在每一个数据区域内部, 数据分布尽可能相同</strong>; </li>
<li>(2) 对于每一个数据区域, <strong>分别利用神经网络对其进行训练</strong>, 使网络能够对该数据区域的分布得到一个比较好的拟合; </li>
<li>(3) 在神经网络训练阶段, <strong>重点关注访问频率高的热点数据</strong>, 从而使神经网络对这些数据的预测精度更高. 另外, 为了更快地处理动态插入以及更新操作, Dabble 模型提出了一种基于中间层的数据插入机制, 从而使得不同的神经网络模型之间解耦, 模型之间保持独立性. <strong><u>当数据插入时, 只需要重新训练有数据插入的那个数据区域对应的模型即可</u></strong>, 不需要对整个 Dabble 重新训练, 从而提高了模型的可扩展性.</li>
</ul>
<p>Dabble 模型架构图如下所示</p>
<p><img src="https://pic3.zhimg.com/v2-95e0ac3a2beda40d3057dbe875c4a47a_r.jpg"></p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a><strong>实验</strong></h2><p>论文 [1][2] 在 2 亿网站日志数据 weblogs 数据集上跑了实验. 将经过 cache 优化过的 B-Tree 页大小为 128 作为 baseline, 对于学习索引, 使用两阶段模型, 在没有 GPU 和 TPU 的机器上运行结果如下图所示. 可以看到学习索引<strong>比 B-Tree 更快的同时, 内存占用更少.</strong></p>
<p><img src="https://pic4.zhimg.com/v2-f9429d9ab98ad58ff6bfb795a40bb5e7_r.jpg"></p>
<p>论文 [3] 在 weblogs 和 lognormal 数据集上进行评测, 结果如下图.</p>
<p><img src="https://pic3.zhimg.com/v2-5b1c81aeadaf50e7a052ec60435d7242_r.jpg"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>本文总结了三篇文章, 主要探讨了结合机器学习技术的范围索引架构. 相较于传统的索引结构, 可学习型的索引展示了更好的可适应性.</p>
<p>参考文献 </p>
<p>[1] Alex Beutel, Tim Kraska∗, Ed H. Chi, Jeffrey Dean, Neoklis Polyzotis “A Machine Learning Approach to Databases Indexes”NIPS 2017</p>
<p>[2] Alex Beutel, Tim Kraska∗, Ed H. Chi, Jeffrey Dean, Neoklis Polyzotis “The Case for Learned Index Structures”SIGMOD 2018</p>
<p>[3] 高远宁, 叶金标, 杨念祖, 高晓沨, 陈贵海. 基于中间层的可扩展学习索引技术 [J]. 软件学报, 2020, 31(3): 620-633. <a href="https://link.zhihu.com/?target=http://www.jos.org.cn/1000-9825/5910.htm">http://www.jos.org.cn/1000-9825/5910.htm</a></p>
<p>[4] M. Magdon-Ismail and A. F. Atiya. Neural networks for density estimation. In M. J. Kearns, S. A. Solla, and D. A. Cohn, editors, Advances in Neural Information Processing Systems 11, pages 522–528. MIT Press, 1999.</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>计算机组成原理-学习笔记10-数据校验码</title>
    <url>/2023/02/10/Lecture%2010%20%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E7%A0%81/</url>
    <content><![CDATA[<p>计算机组成原理-学习笔记10-数据校验码</p>
<span id="more"></span>

<h1 id="Lecture-10-数据校验码"><a href="#Lecture-10-数据校验码" class="headerlink" title="Lecture 10 数据校验码"></a>Lecture 10 数据校验码</h1><h1 id="差错"><a href="#差错" class="headerlink" title="差错"></a>差错</h1><p>硬故障</p>
<p>软故障</p>
<p><strong>检错和校正</strong></p>
<h1 id="纠错"><a href="#纠错" class="headerlink" title="纠错"></a>纠错</h1><p>基本思想：储存额外信息以进行检错和校正</p>
<p>处理过程：</p>
<ul>
<li>数据输入：使用函数<strong>𝑓</strong>在𝑀位数据<strong>𝐷</strong>上生成𝐾位校验码<strong>𝐶</strong></li>
<li>数据输出：使用函数<strong>𝑓</strong>在𝑀位数据𝐷’上生成新的𝐾位代码<strong>𝐶****”</strong> ，并与取出的𝐾位码<strong>𝐶****’</strong>进行比较<ul>
<li>没有检测到差错：使用数据𝐷’</li>
<li>检测到差错且可以校正：校正数据𝐷’来生成数据𝐷”，并用数据𝐷”</li>
<li>检测到差错但无法纠正：报告</li>
</ul>
</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221110174316858.png"><span class="image-caption">image-20221110174316858</span></p>
<h2 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h2><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230225211413511.png"><span class="image-caption">image-20230225211413511</span></p>
<p>增加1位校验码来表示数据中1的数量是奇数还是偶数</p>
<p>• 奇校验：<strong>使</strong>传输的数据（数据位+校验位）中有<strong>奇数</strong>个1</p>
<p>• 偶校验：<strong>使</strong>传输的数据（数据位+校验位）中有<strong>偶数</strong>个1</p>
<p><strong>处理过程</strong></p>
<p>• 假设数据为𝐷 &#x3D; 𝐷𝑀 … 𝐷2𝐷1</p>
<p>• 数据输入</p>
<p>​	• 奇校验：𝐶 &#x3D; 𝐷𝑀 ⊕ ⋯⊕ 𝐷2⊕ 𝐷1 ⊕1</p>
<p>​	• 偶校验：𝐶 &#x3D; 𝐷𝑀 ⊕ ⋯⊕ 𝐷2⊕ 𝐷1</p>
<p>• 数据输出</p>
<p>​	• 奇校验：𝐶′′ &#x3D; 𝐷′𝑀 ⊕ ⋯⊕ 𝐷′2⊕ 𝐷′1 ⊕1</p>
<p>​	• 偶校验：𝐶′′ &#x3D; 𝐷′𝑀 ⊕ ⋯⊕ 𝐷′2⊕ 𝐷′1</p>
<p>• 检错：S &#x3D; 𝐶′′ ⊕ 𝐶′</p>
<p>​	• 𝑆 &#x3D; 0：正确 &#x2F; 数据中出错的位数为偶数</p>
<p>​	• 𝑆 &#x3D; 1：数据中出错的位数为奇数</p>
<ul>
<li><strong>优点：</strong><ul>
<li>代价低，计算简单</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>不能发现出错位数为偶数的情形</li>
<li>不能校正</li>
</ul>
</li>
<li>适用于对<strong>较短长度</strong>（如1字节）的数据进行检错</li>
</ul>
<h2 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h2><p>将数据分成几组， 对每一组都使用奇偶校验码进行检错 </p>
<p>数据输入：为数据𝐷中每组生成1位校验码， 合并得到𝐾位校验码𝐶</p>
<p>数据输出：为数据𝐷′中每组生成1位校验码， 合并得到新的𝐾位校验码𝐶′′  </p>
<p>检错：C’ 与 C’’ 进行异或，生成𝐾位故障字  </p>
<ul>
<li>假设最多1位发生错误</li>
<li>添加一位校验位可纠错一位，检错两位</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230225211715803.png"><span class="image-caption">image-20230225211715803</span></li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230225211758389.png"><span class="image-caption">image-20230225211758389</span></p>
<p><strong>考试时画表，每第k位 纠错位为1</strong></p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230225211840717.png"><span class="image-caption">image-20230225211840717</span></p>
<p>最大纠错能力</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230225212940790.png"><span class="image-caption">image-20230225212940790</span></p>
<h2 id="循环冗余校验"><a href="#循环冗余校验" class="headerlink" title="循环冗余校验"></a>循环冗余校验</h2><p>生成多项式：自定义</p>
<p>使用异或除法</p>
<p><strong>基本思想</strong></p>
<p>• 假设数据有M位，左移数据K位（右侧补0），并用K+1位生成多项式除它<br><strong>(异或？)</strong><br>• 采用K位余数作为校验码<br>• 把校验码放在数据（不含补的0）后面，一同存储或传输  </p>
<p><strong>校错</strong></p>
<p>• 如果M+K位内容可以被生成多项式除尽，则没有检测到错误<br>• 否则，发生错误  </p>
<p>模2除法：</p>
<ul>
<li>除数首位必为1</li>
<li>只需看被除数首位是否为1，为1则商1</li>
<li>异或运算</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>计算机组成原理-学习笔记11-RAID阵列</title>
    <url>/2023/02/10/Lecture%2011%20Raid%E5%86%97%E4%BD%99%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97/</url>
    <content><![CDATA[<p>计算机组成原理-学习笔记11-RAID</p>
<span id="more"></span>



<p>考前抱佛脚整理</p>
<h1 id="Lecture-11-RAID"><a href="#Lecture-11-RAID" class="headerlink" title="Lecture 11 RAID"></a>Lecture 11 RAID</h1><p>• 基本思想<br>    • 将多个独立操作的磁盘按某种方式组织成磁盘阵列， 以<strong>增加容量</strong><br>    • 将数据存储在多个盘体上， 通过这些盘并行工作来<strong>提高数据传输率</strong><br>    • 采用数据冗余来进行错误恢复以<strong>提高系统可靠性</strong></p>
<p>• 特性<br>    • 由一组物理磁盘驱动器组成， 被视为<strong>单个逻辑</strong>驱动器<br>    • 数据是分布在多个物理磁盘上<br>    • 冗余磁盘容量用于存储校验信息， 保证磁盘万一损坏时能恢复数据  </p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230225232853806.png"><span class="image-caption">image-20230225232853806</span></p>
<h2 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID 0"></a>RAID 0</h2><p>以条带的形式  </p>
<p>不采用冗余  </p>
<p>高数据传输率</p>
<p>高速响应I&#x2F;O请求  </p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230225233217161.png"><span class="image-caption">image-20230225233217161</span></p>
<h2 id="RAID-1"><a href="#RAID-1" class="headerlink" title="RAID 1"></a>RAID 1</h2><p>简单地备份所有数据的方法来实现冗余  </p>
<p>高速响应I&#x2F;O请求：  高速响应I&#x2F;O请求：</p>
<p>读请求可以选择寻道时间较小的那个    </p>
<p>受限于写入较慢的磁盘  </p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230225233423898.png"><span class="image-caption">image-20230225233423898</span></p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230225233454305.png"><span class="image-caption">image-20230225233454305</span></p>
<p>RAID10 <strong>容错率更高</strong></p>
<h2 id="RAID-2"><a href="#RAID-2" class="headerlink" title="RAID 2"></a>RAID 2</h2><p>对位于同一条带的各个数据盘上的数据位计算校验码（通常采用海明码）  </p>
<p>适用于多磁盘易出错环境，对于单个磁盘和磁盘驱动器已经具备高可靠性的情况没有意义<strong>（实际基本弃用）</strong>  </p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230225233720023.png"><span class="image-caption">image-20230225233720023</span></p>
<h2 id="RAID-3"><a href="#RAID-3" class="headerlink" title="RAID 3"></a>RAID 3</h2><p>对所有数据盘上同一位置的数据计算奇偶校验码  </p>
<p>非常小的数据条带</p>
<p>当某一磁盘损坏时，可以用于重构数据  </p>
<p>非常高的数据传输率，对于大量读请求，性能改善特别明显  </p>
<ul>
<li><p>并行存取</p>
<p>四个盘同时读写</p>
</li>
</ul>
<p>次只能执行一个I&#x2F;O请求，在面向多个IO请求时，性能将受损  </p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230225233932548.png"><span class="image-caption">image-20230225233932548</span></p>
<h2 id="RAID-4"><a href="#RAID-4" class="headerlink" title="RAID 4"></a>RAID 4</h2><p>较大的数据条带  </p>
<p>根据各个数据盘上的数据来逐位计算奇偶校验条带，奇偶校验位存储在奇偶校验盘的对应条带上  </p>
<p>独立存取阵列更适合与需要高速 IO 请求的应用，而相对较少用于需要高数据传输率的场合。</p>
<p>当执行较小规模的I&#x2F;O写请求时， RAID 4会遭遇<strong>写损失</strong></p>
<ul>
<li>对于每一次写操作， 阵列管理软件不仅要修改用户数据， 而且要修改相应的校验位  </li>
<li>校验盘会成为瓶颈（实际基本弃用）</li>
</ul>
<p>两读两写—— 两次读操作（数据盘、校验盘）、两次写操作（数据盘、校验盘）</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230225234128783.png"><span class="image-caption">image-20230225234128783</span></p>
<h2 id="RAID-5"><a href="#RAID-5" class="headerlink" title="RAID 5"></a>RAID 5</h2><p>与RAID 4 组织方式相似<strong>（常用）</strong> </p>
<p>在所有磁盘上都分布了奇偶校验条带  </p>
<p>访问时的<strong>“两读两写”</strong>：读在写前，读&#x2F;写不需要并行  </p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230225234244516.png"><span class="image-caption">image-20230225234244516</span></p>
<h2 id="RAID-6"><a href="#RAID-6" class="headerlink" title="RAID 6"></a>RAID 6</h2><p>采用两种不同的校验码，并将校验码以分开的块存于不同的磁盘中  </p>
<p>提升数据可用性：只有在平均修复时间间隔内3个磁盘都出了故障，才<br>会造成数据丢失  </p>
<p>写损失：每次写都要影响两个校验块（<strong>读3个写3个磁盘</strong>）  </p>
<p>三读三写</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>3 和 4 的区别在于，是不是一起转的</p>
<p> 5 和 6 各有优劣</p>
<p>123：并行写（1不是同步轴）</p>
<p>23：并行读写（同步轴）</p>
<p>45(6?)：不能并行写，能IO并行处理</p>
<p>可靠性：6&gt; 1 &gt; 2345 &gt; 0</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>计算机组成原理-学习笔记12-虚拟存储器</title>
    <url>/2023/02/10/Lecture%2012%20%E8%99%9A%E6%8B%9F%E5%82%A8%E5%AD%98%E5%99%A8/</url>
    <content><![CDATA[<p>计算机组成原理-学习笔记12-虚拟存储器</p>
<span id="more"></span>



<p>作业已写，考前抱佛脚整理</p>
<h1 id="Lecture-12-虚拟存储器"><a href="#Lecture-12-虚拟存储器" class="headerlink" title="Lecture 12 虚拟存储器"></a>Lecture 12 虚拟存储器</h1><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230225235941654.png"><span class="image-caption">image-20230225235941654</span></p>
<p>主存中包含操作系统和若干个用户程序  </p>
<p>在多道程序系统中， 主存需要进一步划分给多个任务， 划分的任务由<strong>操作系统动态执行</strong>  </p>
<p>不区分“进程” 和“任务  </p>
<ul>
<li>虚拟存储器<ul>
<li>请求分页：每次访问仅将当前需要的页面调入主存， 而其他不活跃的页面放在外存磁盘上</li>
</ul>
</li>
</ul>
<h2 id="分区方式"><a href="#分区方式" class="headerlink" title="分区方式"></a>分区方式</h2><ul>
<li><p>将主存分为两大区域<br>• 系统区： 固定的地址范围内，存放操作系统<br>• 用户区：存放所有用户程序  </p>
</li>
<li><p>简单<strong>固定</strong>分区<br>• 用户区划分成长度不等的固定长的分区<br>• 当一个任务调入主存时，分配一个<strong>可用的、能容纳它的、最小的</strong>分区<br>• 优点：简单<br>• 缺点：<strong>浪费主存</strong>空间  </p>
</li>
<li><p>可变长分区<br>• 用户区按每个任务所需要的内存大小进行分配<br>• 优点：提高了主存的利用率<br>• 缺点：时间越长，存储器中的<strong>碎片</strong>就会越多</p>
</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230226001016471.png"><span class="image-caption">image-20230226001016471</span></p>
<p><strong>帧 &#x2F; 页帧 &#x2F; 页框</strong> —— <strong>存储器</strong>分成相当小的、相等的固定长度的存储块，每个存储块被成为页帧、帧 </p>
<p>页 —— 每个进程划分为小的固定长的程序块，程序的每个程序块成为页 </p>
<p>页表 —— 记录了进程每页的帧地址 </p>
<p>逻辑地址 —— 页号和页中相对地址 </p>
<p>物理地址 —— 帧号和相对地址 </p>
<p>进程和主存划分的块的大小相同</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230226001222532.png"><span class="image-caption">image-20230226001222532</span></p>
<ul>
<li>优点<br>• 在不扩大物理内存的前提下，可以载入更多的任务<br>• 编写程序时<strong>不需要考虑可用物理内存</strong>的状态<br>• 程序员认为可以独享一个连续的、很大的内存<br>• 可以在<strong>大于物理内存</strong>的逻辑地址空间中编程</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230226001306568.png"><span class="image-caption">image-20230226001306568</span></p>
<h2 id="分页式"><a href="#分页式" class="headerlink" title="分页式"></a>分页式</h2><ul>
<li>页表<ul>
<li>页表中包含了所有虚拟页的信息， 包括虚拟页的存放位置、 装入位（valid） 、修改位（dirty） 、 存取权限位等等  </li>
<li><strong>保存在主存中</strong>  </li>
<li>虚拟页号 + 页内偏移量</li>
</ul>
</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230226001433001.png"><span class="image-caption">image-20230226001433001</span></p>
<p><img src="/C:/Users/lar/AppData/Roaming/Typora/typora-user-images/image-20230226001538018.png"><span class="image-caption">image-20230226001538018</span></p>
<p><strong>快表</strong></p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230226001605842.png"><span class="image-caption">image-20230226001605842</span></p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图<img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230226001749622.png"><span class="image-caption">image-20230226001749622</span></h3><p>绿色就是第八章cache学的</p>
<h3 id="多种可能"><a href="#多种可能" class="headerlink" title="多种可能"></a>多种可能</h3><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230226001931586.png"><span class="image-caption">image-20230226001931586</span></p>
<p>4：page 1次，cache miss 1次</p>
<h2 id="分段式"><a href="#分段式" class="headerlink" title="分段式"></a>分段式</h2><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230226002138094.png"><span class="image-caption">image-20230226002138094</span></p>
<h2 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h2><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230226002153775.png"><span class="image-caption">image-20230226002153775</span></p>
<p><strong>段号 + 页号 + 页内偏移量</strong>  </p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>计算机组成原理-学习笔记13-总线</title>
    <url>/2023/02/10/Lecture%2013%20%E6%80%BB%E7%BA%BF/</url>
    <content><![CDATA[<p>计算机组成原理-学习笔记13-总线</p>
<span id="more"></span>



<h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h1><h2 id="1-类型"><a href="#1-类型" class="headerlink" title="1.类型"></a>1.类型</h2><p>• 芯片内部总线：连接芯片内部的各个部分</p>
<p>​	• 例：CPU中连接寄存器、ALU等部分（计基讲的）</p>
<p><strong>• 系统总线：连接CPU、存储器、IO控制器和其他功能设备</strong>（本节课重点）</p>
<p>• 通信总线：连接主机和I&#x2F;O设备，或连接不同的计算机系统</p>
<h2 id="2-结构"><a href="#2-结构" class="headerlink" title="2.结构"></a>2.结构</h2><ul>
<li><strong>数据线：</strong>在系统组件之间传输数据<ul>
<li>数据线的数量决定了一次可<strong>以传输的数据的大小</strong>。正常每次只能传1位</li>
</ul>
</li>
<li><strong>地址线：</strong>在数据线和地址I&#x2F;O端口上指定数据的来源和去向<ul>
<li>地址线的数量决定了<strong>寻址空间的大小</strong>（存地址的位数2^n）</li>
<li>可能可以传2次，达到更大寻址空间</li>
</ul>
</li>
<li><strong>控制线：</strong>控制对数据线和地址线的存取和使用</li>
</ul>
<p>​	• 时钟（clock）：用于总线同步操作</p>
<p>​	• 总线请求（bus request）：表示模块需要获得对总线的控制，处理冲突</p>
<p>​	• 总线允许（bus grant）：发出请求的设备已经被允许控制总线</p>
<p>​	• 中断请求（interrupt request）：表示某个中断正在悬而未决</p>
<p>​	• 中断响应（interrupt ACK）：未决的终端请求被响应</p>
<p>​	• 存储器读（memory read）：从存储器读数据到总线</p>
<p>​	• 存储器写（memory write）：将数据从总线写入存储器</p>
<p>​	• I&#x2F;O读（I&#x2F;O read）：从I&#x2F;O端口读数据到总线</p>
<p>​	• I&#x2F;O写（I&#x2F;O write）：将数据从总线写入I&#x2F;O端口</p>
<h2 id="3-特点"><a href="#3-特点" class="headerlink" title="3.特点"></a>3.特点</h2><ul>
<li><p>可以<strong>被多个设备监听</strong>，但同一时刻只能由<strong>一个设备</strong>发送数据</p>
<ul>
<li>混淆例子：走廊喊话</li>
<li>不能抢夺</li>
</ul>
</li>
<li><p>如果连在总线上的某个设备希望向另一个设备发送数据，需要：</p>
<ul>
<li>1.获得<strong>总线的使用权</strong></li>
<li>2.通过总线传送数据</li>
</ul>
</li>
<li><p>如果连在总线上的某个设备希望向另一个组件请求数据，需要：</p>
<ul>
<li>获得总线的使用权</li>
<li>通过总线向另一个设备发送请求，等待另一个设备发送数据</li>
</ul>
</li>
</ul>
<h1 id="2-设计要素"><a href="#2-设计要素" class="headerlink" title="2.设计要素"></a>2.设计要素</h1><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ul>
<li><strong>专用（</strong>dedicated）总线：<strong>始终只负责一项功能，</strong>或始终分配给特定的计算机组件<ul>
<li>优点：高吞吐量，减少总线冲突</li>
<li>缺点：增加了系统的规模和成本</li>
</ul>
</li>
<li><strong>复用（</strong>multiplexed）总线：将同一线路用于多种用途<ul>
<li>优点：使用的布线数量少，节省空间和成本</li>
<li>缺点：每个模块需要更复杂的控制电路，且共享可能会降低性</li>
</ul>
</li>
</ul>
<h2 id="仲裁"><a href="#仲裁" class="headerlink" title="仲裁"></a>仲裁</h2><ul>
<li>通过某种策略选择一个设备</li>
<li>平衡因素<ul>
<li>优先级：优先级高的设备<strong>优先被服务</strong></li>
<li>公平性：优先级最低的设备<strong>不能一直被延迟</strong></li>
</ul>
</li>
</ul>
<h3 id="仲裁方案"><a href="#仲裁方案" class="headerlink" title="仲裁方案"></a>仲裁方案</h3><ul>
<li><p><strong>集中式（centralized</strong>）：由仲裁器（arbiter）或总线控制器（bus controller）负责分配总线使用权</p>
<ul>
<li><p><strong>链式查询 &#x2F; 菊花链</strong>（daisy chain）<img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221129174524495.png"><span class="image-caption">image-20221129174524495</span></p>
<ul>
<li><p>串行连接，将允许信号从优先级最高的设备下发到优先级</p>
<p>最低的设备</p>
</li>
<li><p>如果某个设备收到了允许信号并且发起了总线请求，该设备将总线设置为繁忙状态，允许信号将不再被进一步传递</p>
</li>
<li><p>优点：灵活，容易确定优先级</p>
</li>
<li><p>缺点：不能保证公平性，对故障敏感</p>
</li>
</ul>
</li>
<li><p><strong>计数器查询</strong>（query by a counter）<img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221129174517949.png"><span class="image-caption">image-20221129174517949</span></p>
<ul>
<li><p>将总线允许线替换为设备ID（地址）线</p>
</li>
<li><p>总线空闲时，总线仲裁器的计数器开始计数，计数值通过设备ID线发向各个部件</p>
</li>
<li><p>如果当前发送请求的设备ID等于裁决器当前的计数，裁决器将停止计数，</p>
<p>设备将总线设置为繁忙</p>
</li>
<li><p>优点：灵活地确定设备优先级，既可从1开始（优先级）也可从下一个设备ID开始（公平性）</p>
</li>
<li><p>缺点：需要解码和比较设备ID信号</p>
</li>
</ul>
</li>
<li><p><strong>独立请求</strong>（independently request）<img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221129174509347.png"><span class="image-caption">image-20221129174509347</span></p>
<ul>
<li>每个设备都有自己的总线请求线和总线允许线</li>
<li>总线仲裁器决定哪个设备可以使用总线<ul>
<li>确定策略：固定优先级，公平链式，LRU，FIFO</li>
</ul>
</li>
<li>优点：可编程</li>
<li>缺点：复杂</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>分布式（distributed</strong>）：每个设备都包含访问控制逻辑，各设备共同作用分享总线</p>
<ul>
<li><strong>自举式（self selection）</strong><ul>
<li>固定优先级</li>
<li>每个设备自行判断自己是否在请求总线的设备中优先级最高（3最高）</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221129174500223.png"><span class="image-caption">image-20221129174500223</span></li>
</ul>
</li>
<li><strong>冲突检测（collision detection)</strong><ul>
<li>当一个设备想要使用总线时，它会检查总线是否繁忙<ul>
<li>如果总线空闲，设备使用总线</li>
</ul>
</li>
<li><strong>冲突：</strong>如果两个设备发现总线空闲，它们可能同时使用总线<ul>
<li>在传输数据时，设备会监听总线，检查是否存在冲突。如果发生冲突，所有使用总线的设备将<strong>停止数据传输</strong>，并分别在<strong>随机时间间隔</strong>后再次请求总线</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h2><ul>
<li>目的：确定每个<strong>总线事务</strong>的开始和结束时间<ul>
<li>总线事务：地址 + 数据 + … + 数据</li>
</ul>
</li>
<li>类型<ul>
<li><p>同步时序(时钟信号)：时钟信号来同步</p>
<ul>
<li>共享同一个时钟（快受慢拖累）</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221204225949092.png"><span class="image-caption">image-20221204225949092</span></li>
</ul>
</li>
<li><p>异步时序(顺序)：一个事件的发生取决于前一个事件的发生</p>
<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221204230401684.png"><span class="image-caption">image-20221204230401684</span></li>
<li>Ready提供数据，ack接收</li>
<li>1.均为上升沿</li>
<li>2.Ready下降沿,否则ready不知道ack收到</li>
<li>3.ack下降沿，否则ack不知道ready撤了</li>
<li>（1开始后开始传输，即设置到数据&#x2F;地址线上）</li>
<li>（读完后2开始握手通知）</li>
<li>（3开始后收回悬置，即释放数据&#x2F;地址线）</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221204231730077.png"><span class="image-caption">image-20221204231730077</span></li>
<li>123和567：三次握手。4：释放和过渡</li>
</ul>
</li>
<li><p>半同步：同步和异步相结合</p>
<ul>
<li>准备和响应信号仅在上升沿有效</li>
<li>去除噪声</li>
</ul>
</li>
<li><p>事件分离：<strong>准备数据时释放总线</strong></p>
<ul>
<li>即在4时利用总线，将一个总线事件分离为两个过程</li>
<li>缺点：增加了每个总线事件的时间</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221204233008616.png"><span class="image-caption">image-20221204233008616</span></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="总线带宽和数据传输速率"><a href="#总线带宽和数据传输速率" class="headerlink" title="总线带宽和数据传输速率"></a><strong>总线带宽和数据传输速率</strong></h2><ul>
<li><strong>总线带宽（</strong>bus bandwidth）：总线的<strong>最大</strong>数据传输速率（<strong>理想）</strong><ul>
<li>不要考虑总线仲裁、地址传输等因素</li>
</ul>
</li>
<li><strong>数据传输速率</strong><ul>
<li>考虑地址传输、握手等因素（<strong>实际</strong>）</li>
</ul>
</li>
<li><strong>总线宽度（bus width</strong>）：组成总线的线数<ul>
<li>数据总线越宽，一次传输的数据位数就越多</li>
<li>地址总线越宽，一次传输的地址位数就越多、</li>
</ul>
</li>
</ul>
<h3 id="计算题例子"><a href="#计算题例子" class="headerlink" title="计算题例子"></a>计算题例子</h3><ul>
<li><p>Mbps是Million(10^6 &#x3D; 2^20) bits per second的缩写</p>
</li>
<li><p>时钟周期和频率：1GHz&#x3D;10^3MHz&#x3D;10^6KHz&#x3D;10^9Hz  1000的数量级</p>
<p>GHz对应的T(s)&#x3D;1&#x2F;(10^9Hz)&#x3D;10^-9 s &#x3D;1ns</p>
<p>1s&#x3D;10^3 ms&#x3D;10^6 us&#x3D;10^9 ns</p>
</li>
<li><p>同步总线</p>
<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221204234131244.png"><span class="image-caption">image-20221204234131244</span></li>
<li><strong>记住：准备数据【上取整】，一个时钟周期只能做一件事</strong></li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221204234347579.png"><span class="image-caption">image-20221204234347579</span></li>
</ul>
</li>
<li><p>异步总线</p>
<ul>
<li>第一次握手后开始准备数据</li>
<li>数据准备后才能开始传输</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221204234032663.png"><span class="image-caption">image-20221204234032663</span></li>
</ul>
</li>
</ul>
<h4 id="复杂例子"><a href="#复杂例子" class="headerlink" title="复杂例子"></a>复杂例子</h4><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221204235521515.png"><span class="image-caption">image-20221204235521515</span></p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221204235530559.png"><span class="image-caption">image-20221204235530559</span></p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221204235556052.png"><span class="image-caption">image-20221204235556052</span></p>
<ul>
<li>每次读 &#x3D;&#x3D; 每次总线时间</li>
<li>需要考虑最后一次空闲</li>
<li>读1-4&#x2F;5-8&#x2F;9-12个字时，同时传输（2）和准备（4）。最后一次只传输，故为2</li>
</ul>
<h3 id="提高传输率"><a href="#提高传输率" class="headerlink" title="提高传输率"></a>提高传输率</h3><p>万变不离其宗：<strong>数据量 &#x2F; 耗费时间</strong></p>
<ul>
<li>提高时钟频率，变相缩短时钟周期（时钟周期数不变的情况下）</li>
<li>增加数据总线宽度<ul>
<li>每次传输更多位的数据（成本：更多的总线线路）</li>
</ul>
</li>
<li>块传输<ul>
<li>传输一次地址就传输<strong>一块</strong>数据（成本：高复杂性）</li>
</ul>
</li>
<li>分离总线事务<ul>
<li>减少总线空闲时间（成本：复杂性高，增加每个事务的持续时间）</li>
</ul>
</li>
<li>分离地址线和数据线<ul>
<li>同时传输地址和数据（成本：更多的总线线路）</li>
</ul>
</li>
</ul>
<h2 id="总线层次结构"><a href="#总线层次结构" class="headerlink" title="总线层次结构"></a><strong>总线层次结构</strong></h2><ul>
<li><p>单总线结构</p>
<ul>
<li><p>CPU、存储器和 I&#x2F;O 模块都连接到一条<strong>系统总线</strong></p>
</li>
<li><p>优点：简单，易于扩展</p>
</li>
<li><p>缺点：</p>
<p>• 连接的设备越多，总线长度越大，<strong>传输延迟</strong>也就越大</p>
<p>• 聚集的传输请求接近总线容量时，总线成为瓶颈</p>
</li>
</ul>
</li>
<li><p><strong>双总线结构1</strong></p>
<ul>
<li>在CPU和存储器中间增加一个<strong>存储器总线</strong></li>
<li>增加CPU和存储器之间的传输效率</li>
</ul>
</li>
<li><p><strong>双总线结构2</strong></p>
<ul>
<li>将系统总线分为存储器总线、<strong>I&#x2F;O</strong> <strong>总线</strong> 和 <strong>IOP</strong> (input&#x2F;output processer)</li>
<li>降低I&#x2F;O对总线的负担</li>
</ul>
</li>
<li><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221205000947107.png"><span class="image-caption">image-20221205000947107</span></p>
</li>
<li><p>多总线结构1</p>
<ul>
<li>增加一个 本地总线（<strong>local bus</strong>）来连接 CPU 和 cache</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221205001159332.png"><span class="image-caption">image-20221205001159332</span></li>
</ul>
</li>
<li><p><strong>多总线结构2</strong></p>
<ul>
<li>将系统总线分为存储器总线、I&#x2F;O 总线和 <strong>DMA</strong> <strong>总线</strong></li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221205001149715.png"><span class="image-caption">image-20221205001149715</span></li>
</ul>
</li>
<li><p><strong>多总线结构3</strong></p>
<ul>
<li>增加一个 <strong>高速</strong> <strong>I&#x2F;O</strong> <strong>总线</strong> 来连接高速设备</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221205001315388.png"><span class="image-caption">image-20221205001315388</span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>计算机组成原理-学习笔记14-指令集</title>
    <url>/2023/02/10/Lecture%2014%20%E6%8C%87%E4%BB%A4%E9%9B%86/</url>
    <content><![CDATA[<p>计算机组成原理-学习笔记14-指令集</p>
<span id="more"></span>



<h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h1><ul>
<li>计算机执行程序，程序由指令组成，CPU执行指令</li>
<li>指令集：CPU能执行的各种不同指令的集合</li>
</ul>
<p>​	</p>
<ul>
<li>指令是计算机处理的最基本单位<ul>
<li>操作码（指令执行的内容）+ 操作数（要操作的对象）</li>
</ul>
</li>
<li>可以将一条指令的执行分解为一系列步骤<ul>
<li>取指令，</li>
<li>译码&#x2F;取寄存器，</li>
<li>执行&#x2F;有效地址&#x2F;完成分支，</li>
<li>访问内存，</li>
<li>存储结果</li>
</ul>
</li>
</ul>
<h1 id="2-指令的格式"><a href="#2-指令的格式" class="headerlink" title="2.指令的格式"></a>2.指令的格式</h1><ul>
<li><p><strong>指令的要素</strong>（一定存在，但不一定显式出现为二进制）</p>
<ul>
<li>操作码：<strong>指定将要完成的操作</strong></li>
<li>源操作数引用：<strong>操作会涉及一个或多个源操作数，这是操作所需的输入</strong></li>
<li>结果操作数引用：<strong>操作可能会产生一个结果</strong></li>
<li>下一指令引用：<strong>告诉处理器这条指令执行完成后到哪儿去取下一条指令</strong></li>
</ul>
</li>
<li><p>指令格式</p>
<ul>
<li>大多数指令集使用不止一种指令格式（ 如何避免指令的二义性？）</li>
<li>机器指令符号表示法：<ul>
<li>操作码被缩写成助记符来表示</li>
<li>ADD：加，SUB：减，MUL：乘，DIV：除，LOAD：由存储器装入，STOR：保存到存储器…</li>
</ul>
</li>
<li>操作数也可以用符号表示<ul>
<li>用寄存器编号或内存地址替换操作数</li>
</ul>
</li>
</ul>
</li>
<li><p>区分零指令、一指令、二指令</p>
</li>
</ul>
<h1 id="3-操作码"><a href="#3-操作码" class="headerlink" title="3.操作码"></a>3.操作码</h1><p>• 数据传送</p>
<p>• 算术运算</p>
<p>• 逻辑运算</p>
<p>• 转换</p>
<p>• 输入&#x2F;输出</p>
<p>• 系统控制</p>
<p>• 控制转移128</p>
<p><img src="https://quasdo.oss-cn-hangzhou.aliyuncs.com/img/image-20221201163012730.png"><span class="image-caption">image-20221201163012730</span></p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210180320248.png"><span class="image-caption">image-20230210180320248</span></p>
<h1 id="4-操作数"><a href="#4-操作数" class="headerlink" title="4.操作数"></a>4.操作数</h1><p>类型：</p>
<ul>
<li><p>地址</p>
<ul>
<li>4个地址引用：2个源操作数、1个目的操作数、下一指令地址</li>
<li>下一地址可能是隐含的</li>
</ul>
</li>
<li><p>数值</p>
</li>
<li><p>字符</p>
<ul>
<li>ascii：7</li>
<li>ebcdic：8</li>
<li>unicode：16</li>
</ul>
</li>
<li><p>逻辑数据</p>
</li>
<li><p>1&#x2F;0</p>
</li>
</ul>
<p>大端小端：大端顺小端逆（不是完全逆，<strong>1字节为单位</strong>）</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210110708594.png"></p>
<h1 id="5-寻址方式"><a href="#5-寻址方式" class="headerlink" title="5.寻址方式"></a>5.寻址方式</h1><ul>
<li><p>一些定义</p>
<ul>
<li><p>• A: 地址字段的<strong>内容</strong></p>
<p>• R: <strong>指向寄存器</strong>的指令地址字段内容</p>
<p>• EA: 被访问位置的<strong>实际（有效）地址</strong></p>
<p>• (X): 存储器位置 X 或寄存器 X 的内容</p>
<p>​	（EA）&#x3D; 操作数</p>
</li>
</ul>
</li>
<li><p>立即寻址</p>
<ul>
<li><strong>方式：</strong>操作数实际值出现在指令中</li>
<li><strong>用法：</strong>定义和使用常数或设置变量的初始值</li>
<li><strong>算法：</strong>操作数 &#x3D; A</li>
<li><strong>优点：</strong>快，除了取指令之外，获得操作数不要求另外的存储器访问</li>
<li><strong>缺点：</strong>数的大小受限于地址字段的长度</li>
</ul>
</li>
<li><p>直接寻址</p>
<ul>
<li><strong>方式：</strong>地址字段含有操作数的有效地址</li>
<li><strong>用法：</strong>早期计算机常用，在当代计算机体系结构中不多见</li>
<li><strong>算法：</strong>EA &#x3D; A</li>
<li><strong>优点：</strong>只要求1次存储器访问，且无需为生成地址而专门计算</li>
<li><strong>缺点：</strong>有限的地址空间</li>
</ul>
</li>
<li><p>间接寻址</p>
<ul>
<li><strong>方式：</strong>地址字段指示一个存储器字地址, 而此地址出保存有操作数的全长度地址（指针）</li>
<li><strong>算法：</strong>EA &#x3D; (A)</li>
<li><strong>优点：</strong>扩大了地址空间</li>
<li><strong>缺点：</strong>取操作数需要2次访问存储器</li>
<li><strong>解释：</strong>地址引用的数量限制可能是有益的</li>
</ul>
</li>
<li><p>寄存器寻址</p>
<ul>
<li>EA &#x3D; R</li>
<li><strong>优点：</strong>指令中仅需要一个较小的地址字段, 且不需要存储器访问  </li>
<li><strong>缺点：</strong>地址空间十分有限  </li>
<li><strong>解释：</strong>寄存器寻址只有在被有效使用的时候才有意义</li>
</ul>
</li>
<li><p>寄存器间接寻址</p>
<ul>
<li>EA &#x3D; (R)</li>
<li><strong>优点：</strong>扩大了地址空间，比间接寻址少1次存储器访问    </li>
<li><strong>缺点：</strong>相对于寄存器寻址，需要多1次存储器访问</li>
</ul>
</li>
</ul>
<h2 id="偏移寻址"><a href="#偏移寻址" class="headerlink" title="偏移寻址"></a>偏移寻址</h2><ul>
<li>EA &#x3D; (R) + A</li>
<li>要求指令有两个地址字段，至少<strong>其中一个是显式</strong></li>
<li><strong>结合直接寻址和寄存器间接寻址能力</strong></li>
<li>类型<ul>
<li>相对寻址<ul>
<li>EA&#x3D; （PC）+ A</li>
<li>隐含引用的寄存器是程序计数器（PC），此指令后续的下一条指令的地址加上地址字段的值产生有效地址  </li>
<li>用法： 大多数存储器访问都相对靠近正在执行的指令，相对寻址可节省指令中的地址位数；可用于转移控制指令。  </li>
<li>优点： 利用程序局部性原理，节省指令中地址的位数</li>
</ul>
</li>
<li>基址寄存器寻址<ul>
<li>EA &#x3D; （R） + A, B为寄存器中固定的储存器地址</li>
<li>被引用的寄存器含有一个存储器地址，地址字段含有一个相对于那个地<br>址的偏移量（通常是无符号整数表示）  </li>
<li>用法： 虚拟内存空间中的程序重定位</li>
</ul>
</li>
<li>变址寻址 <ul>
<li>EA &#x3D; （变址寄存器 IX）+ A</li>
<li>指令地址字段引用一个主存地址，被引用的寄存器含有对于该地址的一个正<br>的偏移量  </li>
<li>用法： 为完成重复操作提供一种高效机制</li>
</ul>
</li>
</ul>
</li>
<li>解释： 偏移寻址要求指令有两个地址字段，至少其中一个是<strong>显式</strong>的</li>
</ul>
<h2 id="栈寻址"><a href="#栈寻址" class="headerlink" title="栈寻址"></a>栈寻址</h2><ul>
<li>方式： 栈指针保存在寄存器中，对寄存器中栈位置的访问实际上是一种寄存器间接寻址方式</li>
<li>解释： 与栈相关的是一个指针，它的值是栈顶地址，或者当栈顶的两个元素已在CPU寄存器内，此时栈顶指针指向栈顶的第三个元素</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210112440703.png"><span class="image-caption">image-20230210112440703</span></p>
<p>栈的实现</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210112522435.png"><span class="image-caption">image-20230210112522435</span></p>
<h1 id="6-指令格式设计原则"><a href="#6-指令格式设计原则" class="headerlink" title="6.指令格式设计原则"></a>6.指令格式设计原则</h1><ul>
<li><p>指令尽量短</p>
<ul>
<li>最明显的权衡考虑是在强有力的指令清单和节省空间之间进行 </li>
<li>指令长度应该是字符长度或定点数长度的整数倍 （比如n个字节）  </li>
<li>指令长度应该等于存储器的传送长度（即数据总线宽度），或者这两个值其中之一是另一个的整数倍</li>
</ul>
</li>
<li><p>有足够的操作码位数</p>
<ul>
<li>变长操作码：要为操作类型不断增加预留</li>
</ul>
</li>
<li><p>操作码的编码必须有唯一的解释</p>
</li>
<li><p>指令长度是字节的整数倍</p>
<ul>
<li>与内存按照字节寻址相对应，便于指令的读取和地址计算</li>
</ul>
</li>
<li><p>合理选择地址字段的个数</p>
<ul>
<li>涉及到指令长度和规整性，是空间和时间开销权衡的结果</li>
</ul>
</li>
<li><p>指令尽量规整</p>
<ul>
<li>简化硬件的实现</li>
</ul>
</li>
<li><p>位的分配</p>
<ul>
<li>用变长的操作码  </li>
<li>使用寻址位的考虑因素：寻址方式的种数、操作数的数量、寄存器组的数目（对于固定数目的寄存器, 功能上的分开将使指令只需较少的位数）、地址范围、寻址粒度（使用较大的字时， 需要的地址位更少 ）</li>
</ul>
</li>
<li><p>变长指令</p>
<ul>
<li>定义：提供不同长度的各种指令格式  </li>
<li>优点<ul>
<li>易于提供大的操作码清单，而操作码具有不同的长度</li>
<li>寻址方式能更灵活，指令格式能将各种寄存器和存储器引用加上寻址方式予以组合</li>
</ul>
</li>
<li>缺点<ul>
<li>增加了CPU的复杂程度（效率也会降低）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="指令集设计"><a href="#指令集设计" class="headerlink" title="指令集设计"></a>指令集设计</h2><ul>
<li><p>指令集的设计是件很复杂的事情，影响计算机系统的诸多方面</p>
<ul>
<li>指令集定义了处理器应完成的多数功能，对处理器的实现有着显著的影响</li>
<li>指令集是程序员控制处理器的方式，设计时必须考虑程序员的要求</li>
</ul>
</li>
<li><p>设计的基本原则</p>
<ul>
<li>完备性</li>
<li>兼容性（兼容以前的指令系统）</li>
<li>均匀性（对多种类型数据都能处理）</li>
<li>可扩充性：操作码预留编码空间</li>
</ul>
</li>
<li><p>设计的基本问题</p>
<ul>
<li>操作指令表：应提供多少和什么样的操作，操作有多复杂</li>
<li>数据类型：对哪几种数据类型完成操作</li>
<li>指令格式：指令的位长度、地址数目、各个字段的大小等</li>
<li>寄存器：能被指令访问的寄存器数目以及它们的用途</li>
<li>寻址：寻址方式的种类以及有效地址的计算</li>
<li>下一条指令地址的确定：通常通过PC寄存器实现</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>计算机组成原理-学习笔记15-指令流水线</title>
    <url>/2023/02/10/Lecture%2015%20%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    <content><![CDATA[<p>计算机组成原理-学习笔记15-指令流水线</p>
<span id="more"></span>



<h1 id="1-指令周期"><a href="#1-指令周期" class="headerlink" title="1. 指令周期"></a>1. 指令周期</h1><h2 id="1-0指令周期纵观"><a href="#1-0指令周期纵观" class="headerlink" title="1.0指令周期纵观"></a>1.0<strong>指令周期纵观</strong></h2><ul>
<li><p>定义：处理单个指令的过程</p>
</li>
<li><p>分为取指周期、执行周期</p>
</li>
</ul>
<p><img src="/C:/Users/lar/AppData/Roaming/Typora/typora-user-images/image-20221208163611041.png"><span class="image-caption">image-20221208163611041</span></p>
<p>并非所有指令的周期都一样</p>
<h3 id="带中断的指令周期"><a href="#带中断的指令周期" class="headerlink" title="带中断的指令周期"></a>带中断的指令周期</h3><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210114423694.png"><span class="image-caption">image-20230210114423694</span></p>
<h3 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h3><p>把间接地址的读取看成是一个额外的指令子周期  </p>
<p>提出目的：与数据流，指令流水线有关</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210114806911.png"><span class="image-caption">image-20230210114806911</span></p>
<h3 id="在指令周期中的CPU"><a href="#在指令周期中的CPU" class="headerlink" title="在指令周期中的CPU"></a>在指令周期中的CPU</h3><ul>
<li><p>任务</p>
<ul>
<li><strong>取指令：</strong> CPU必须从存储器（寄存器、 cache、 主存） 读取指令  </li>
<li><strong>解释指令：</strong> 必须对指令进行译码， 以确定所要求的动作  </li>
<li><strong>取数据：</strong> 指令的执行可能要求从存储器或输入&#x2F;输出（I&#x2F;O） 模块中读取数据  </li>
<li><strong>处理数据</strong>： 指令的执行可能要求对数据完成某些算术或逻辑运算  </li>
<li><strong>写数据：</strong> 执行的结果可能要求写数据到存储器或I&#x2F;O模块</li>
</ul>
</li>
<li><p>需求：寄存器</p>
<ul>
<li>临时保存指令数据</li>
<li>记录当前指令位置</li>
<li>（需要小容量的内部储存器）</li>
<li>假定CPU已有的寄存器<ul>
<li>MAR存储地址</li>
<li>MBR存储缓冲&#x2F;MDR存储数据</li>
<li>IR指令寄存器</li>
<li>PC程序计数器</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-1取指周期"><a href="#1-1取指周期" class="headerlink" title="1.1取指周期"></a>1.1取指周期</h2><p>流程：</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210115704765.png"><span class="image-caption">image-20230210115704765</span></p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210115825621.png"><span class="image-caption">image-20230210115825621</span></p>
<ol>
<li>PC-&gt;MAR-&gt;地址总线</li>
<li>控制器通过控制线通知存储器地址就绪</li>
<li>存储器读取地址 地址总线-&gt;存储器  </li>
<li>存储器通过数据总线将（指令）数据发送给MBR-&gt;IR</li>
<li>如果是异步总线，存储器提供反馈 ，告知准备好了</li>
<li>指令取回来后， PC+“1”  （未画出,为控制器-&gt;PC）</li>
</ol>
<h2 id="1-2间址周期"><a href="#1-2间址周期" class="headerlink" title="1.2间址周期"></a>1.2间址周期</h2><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210120043533.png"><span class="image-caption">image-20230210120043533</span></p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210120208616.png"><span class="image-caption">image-20230210120208616</span></p>
<ol>
<li>将MBR缓存中的地址引用送入MAR得到地址（MAR可认为与地址总线绑定，MBR可认为与数据总线绑定）</li>
<li>MAR将地址传入地址总线</li>
<li>控制器通知存储器取地址  </li>
<li>存储器通过数据总线将有效地址发送给MBR</li>
</ol>
<p><strong>实际上间址周期取回的是一个有效地址，不是操作数本身</strong>。取操作数在执行周期</p>
<h2 id="1-3中断周期"><a href="#1-3中断周期" class="headerlink" title="1.3中断周期"></a>1.3中断周期</h2><p>中断周期的任务：处理中断请求。需保存旧地址和旧地址内容</p>
<p>假设程序断点存入堆栈中，并用SP指示栈顶地址,进栈操作是先修改栈顶指针，后存入数据。</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210120613987.png"><span class="image-caption">image-20230210120613987</span></p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210122314159.png"><br><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210120925912.png"></p>
<p>箭头往右，说明都是写的操作</p>
<ol>
<li>处理中断前，将<strong>下一条指令</strong>放到MBR中，再放到数据总线上 （以告知下一条指令需要返回到哪）（存入断点）</li>
<li>控制器将<strong>下一条指令的取值地址</strong>通过MAR放到地址总线上  </li>
<li>控制器通知存储器获得数据</li>
<li>存储器从地址线获得地址</li>
<li>存储器从数据线获得数据，并将数据写入到获得的地址</li>
</ol>
<h1 id="2-指令流水线"><a href="#2-指令流水线" class="headerlink" title="2.指令流水线"></a>2.指令流水线</h1><ul>
<li>流水处理（pipelining）<ul>
<li>如果一个产品要经过几个制作步骤，通过把制作过程安排在一条装配线上，多个产品能在各个阶段同时被加工</li>
</ul>
</li>
<li>指令流水线：一条指令的处理过程分成若干个阶段，每个阶段由相应的功能部<br>件完成  <ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210152420723.png"><span class="image-caption">image-20230210152420723</span></li>
</ul>
</li>
</ul>
<h2 id="2-1两阶段方法"><a href="#2-1两阶段方法" class="headerlink" title="2.1两阶段方法"></a>2.1两阶段方法</h2><ul>
<li>将指令处理分成两个阶段：取指令和执行指令</li>
<li>在当前指令的执行期间取下一条指令</li>
<li>问题： 执行时间一般要长于取指时间  <ul>
<li>性能瓶颈，工作量分配不均匀</li>
<li>主存访问冲突</li>
<li><strong>条件分支指令</strong>使下一条指令的地址是未知的（导致原指令作废，执行指令需等待）</li>
</ul>
</li>
</ul>
<h2 id="2-2六阶段方法"><a href="#2-2六阶段方法" class="headerlink" title="2.2六阶段方法"></a>2.2六阶段方法</h2><p>为了进一步的加速，流水线必须有更多的阶段</p>
<ul>
<li>取指令（Fetch instruction， FI）： 读下一条预期的指令到缓冲器</li>
<li>译码指令（Decode instruction， DI）： 确定操作码和操作数指定符</li>
<li>计算操作数（Calculate operands， CO）： 计算每个源操作数的有效地址</li>
<li>取操作数（Fetch operands， FO）： 从存储器取出每个操作数，寄存器中的操作不需要取</li>
<li>执行指令（Execute instruction， EI）： 完成指定的操作。若有指定的目的操作数位置，则将结果写入此位置</li>
<li>写操作数（Write operand， WO）： 将结果存入存储器</li>
</ul>
<p>各个阶段所需要的时间几乎是相等的 。</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210154320143.png"><span class="image-caption">image-20230210154320143</span></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>不是所有指令都包含6个阶段<ul>
<li>例：一条LOAD指令不需要WO阶段</li>
<li>为了简化流水线硬件设计，在<strong>假定每条指令都要求这6个阶段</strong>的基础上来建立时序</li>
</ul>
</li>
<li>不是所有的阶段都能并行完成<ul>
<li>例： FI、 FO和 WO都涉及存储器访问</li>
</ul>
</li>
<li>若6个阶段不全是相等的时间，则会在各个流水阶段涉及某种等待<ul>
<li>以最长的为基准</li>
</ul>
</li>
</ul>
<p><strong>条件转移指令损失图解</strong></p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210154624695.png"><span class="image-caption">image-20230210154624695</span></p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210155033296.png"><span class="image-caption">image-20230210155033296</span></p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210155042586.png"><span class="image-caption">image-20230210155042586</span></p>
<p>本质：转移指令需要清空流水线造成的损失</p>
<h2 id="2-3流水线性能"><a href="#2-3流水线性能" class="headerlink" title="2.3流水线性能"></a>2.3流水线性能</h2><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210155218162.png"><span class="image-caption">image-20230210155218162</span></p>
<p>𝑡𝑚 &#x3D; max [𝑡𝑖]</p>
<p><strong>单周期时间</strong>：𝑡 &#x3D; max [𝑡𝑖] + 𝑑 &#x3D; 𝑡𝑚 + 𝑑  </p>
<p><strong>总时间：</strong>𝑇𝑘,𝑛 &#x3D; [𝑘 + 𝑛 - 1] 𝑡（理想情况） </p>
<p><strong>加速比</strong> &#x3D;  没有使用流水线 &#x2F; 使用流水线  &gt;  1 </p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210155433099.png"><span class="image-caption">image-20230210155433099</span></p>
<p>根据公式推导加速</p>
<ul>
<li>误解<ul>
<li>流水线中的阶段数越多，执行速度越快</li>
</ul>
</li>
<li>原因  <ul>
<li>将数据从一个缓冲区移动到另一个缓冲区以及执行各种准备和传递功能都涉及一些开销（比如<strong>锁存延时</strong>）</li>
<li>处理内存和寄存器依赖以及优化管道使用所需的<strong>控制逻辑数量</strong>随着阶段的增加而急剧增加</li>
</ul>
</li>
</ul>
<h1 id="3-冒险"><a href="#3-冒险" class="headerlink" title="3.冒险"></a>3.冒险</h1><p>定义：在某些情况下，指令流水线会阻塞或停顿（stall），导致后续指令无法正确执行  </p>
<p>类型：</p>
<ul>
<li>结构冒险（Structure hazard） &#x2F; 硬件资源冲突<ul>
<li>不同指令同时使用相同的硬件资源，比如访存</li>
</ul>
</li>
<li>数据冒险（Data hazard） &#x2F; 数据依赖性<ul>
<li>有些数据要等前序计算完成</li>
</ul>
</li>
<li>控制冒险（Control hazard） <ul>
<li>比如条件转移</li>
</ul>
</li>
</ul>
<h2 id="结构冒险"><a href="#结构冒险" class="headerlink" title="结构冒险"></a>结构冒险</h2><ul>
<li><p>原因： 已进入流水线的不同指令在同一时刻访问相同的硬件资源</p>
</li>
<li><p>解决</p>
<ul>
<li>使用多个不同的硬件资源</li>
<li>或者分时使用同一个硬件资源 （分时复用）</li>
</ul>
</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210160237237.png"><span class="image-caption">image-20230210160237237</span></p>
<h2 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h2><p>原因：未生成指令所需要的数据  </p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210160554784.png"><span class="image-caption">image-20230210160554784</span></p>
<p>解决1：插入nop（啥都不做）</p>
<p>解决2：插入bubble </p>
<p>（都有时间开销）</p>
<p><strong>解决3：转发（forwarding） &#x2F; 旁路（bypassing）</strong>  </p>
<p>从ALU（或ALU后的步骤）直接提前打听R1</p>
<p>什么时候失效：非计算指令时（如load)</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210160712506.png"><span class="image-caption">image-20230210160712506</span></p>
<p><strong>解决方案4：交换指令顺序</strong>  </p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210161010109.png"><span class="image-caption">image-20230210161010109</span></p>
<h2 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h2><ul>
<li>原因：指令的执行顺序被更改<ul>
<li>转移（Transfer） : 分支（branch） , 循环（loop） , …</li>
<li>中断（Interrupt）</li>
<li>异常（Exception）</li>
<li>调用 &#x2F; 返回（Call &#x2F; return）</li>
</ul>
</li>
</ul>
<p><strong>解决方案1：取多条指令</strong></p>
<ul>
<li>多个指令流： 复制流水线的开始部分， 并允许流水线同时取这两条指令，  使用两个指令流</li>
<li>预取分支目标： 识别出一个条件分支指令时， 除了取此分支指令之后的指<br>令外， 分支目标处的指令也被取来</li>
</ul>
<p>缺点：指令膨胀</p>
<ul>
<li>循环缓冲器： 由流水线指令取指含有 n 条最近顺序取来的指令</li>
</ul>
<p>多线程终究有效率损害，于是有了预测</p>
<p><strong>解决方案2：分支预测</strong></p>
<ul>
<li>静态预测（规则不变）<ul>
<li>预测绝不发生跳转</li>
<li>预测总是发生跳转（到目标地址取指令 ）</li>
<li>依操作码预测</li>
</ul>
</li>
<li>动态预测（规则变化）<ul>
<li>发生 &#x2F; 不发生切换</li>
<li>转移历史表</li>
</ul>
</li>
</ul>
<h3 id="分支动态预测"><a href="#分支动态预测" class="headerlink" title="分支动态预测"></a>分支动态预测</h3><p><strong>方法一：发生 &#x2F; 不发生切换</strong>  </p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210164601006.png"><span class="image-caption">image-20230210164601006</span></p>
<p>初始状态-&gt;两次错误时改变状态</p>
<p>假设：状态的连贯性</p>
<p><strong>方法二：转移历史表</strong>  </p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210164736260.png"><span class="image-caption">image-20230210164736260</span></p>
<p>未命中时记录转移历史，查表来预测</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>计算机组成原理-学习笔记16-CPU控制器</title>
    <url>/2023/02/10/Lecture%2016%20%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<p>计算机组成原理-学习笔记16-CPU控制器</p>
<span id="more"></span>



<h1 id="1-处理器的结构"><a href="#1-处理器的结构" class="headerlink" title="1.处理器的结构"></a>1.处理器的结构</h1><p>CPU的进一步分解：</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210165711708.png"><span class="image-caption">image-20230210165711708</span></p>
<p>细黑线：CPU内部总线</p>
<p>灰线：控制通路</p>
<h2 id="1-1寄存器分类"><a href="#1-1寄存器分类" class="headerlink" title="1.1寄存器分类"></a>1.1寄存器分类</h2><p>上节偏重逻辑，这节偏重硬件</p>
<ul>
<li><p>用户可见寄存器</p>
<ul>
<li>允许编程人员通过机器语言或汇编语言访问，通过优化寄存器的使用而减少对主存的访问</li>
</ul>
</li>
<li><p>控制和状态寄存器</p>
<ul>
<li>由控制器来控制CPU的操作，并由拥有特权的操作系统程序来控制程序的执行</li>
<li>大多数控制和状态寄存器在大多数机器上是用户不可见的</li>
<li>某些在控制或操作系统模式下执行的机器指令是用户可见的</li>
</ul>
</li>
<li><p>以上两者界限不明确</p>
</li>
</ul>
<h3 id="用户可见寄存器"><a href="#用户可见寄存器" class="headerlink" title="用户可见寄存器"></a>用户可见寄存器</h3><p><strong>类型：</strong></p>
<ul>
<li>通用寄存器（general-purpose register）  <ul>
<li>可被程序员指派各种用途</li>
</ul>
</li>
<li>数据寄存器（data register）<ul>
<li>仅可用于保持数据而不能用于操作数地址的计算</li>
</ul>
</li>
<li>地址寄存器（address register）<ul>
<li>可以是自身有某些通用性，或是专用于某种具体的寻址方式</li>
<li>例如：段指针、变址寄存器、栈指针</li>
</ul>
</li>
<li>条件码寄存器（condition codes register） &#x2F; 标志（flag） 寄存器<ul>
<li>CPU硬件设置这些条件位作为操作的结果，也可以是控制寄存器</li>
<li>至少是部分用户可见的 （隐含读出）</li>
<li>并不是必须的</li>
</ul>
</li>
</ul>
<p><strong>设计的考量：</strong></p>
<ul>
<li>使用完全通用的寄存器还是规定各寄存器的用途<ul>
<li>影响指令集的设计</li>
</ul>
</li>
<li>寄存器数量<ul>
<li>太少的寄存器会导致更多的存储器访问</li>
<li>太多的寄存器又不能进一步减少存储器访问</li>
</ul>
</li>
<li>寄存器长度<ul>
<li>应能保存大多数数据类型的值</li>
<li>某些机器允许<strong>两个相邻的寄存器作为一个寄存器</strong>来保持两倍长度的值</li>
</ul>
</li>
</ul>
<p><strong>保存与恢复：</strong></p>
<ul>
<li>子程序调用会导致<strong>自动保存所有用户可见的寄存器</strong>，并在返回时自动取回<ul>
<li>这些保存和恢复是作为调用和返回指令执行功能的一部分，由CPU完成</li>
<li>这允许各个子程序独立地使用用户可见寄存器</li>
</ul>
</li>
<li>子程序调用之外保存用户可见寄存器的相关内容是程序员的责任，需要在程序<br>中为此编写专门的指令</li>
</ul>
<h3 id="控制和状态寄存器"><a href="#控制和状态寄存器" class="headerlink" title="控制和状态寄存器"></a>控制和状态寄存器</h3><p><strong>类型:</strong></p>
<ul>
<li>程序计数器（Program counter， PC）  <ul>
<li>存有待取指令的地址</li>
<li>通常在每次取指令之后， PC的内容即被CPU更改，转移或跳步指令也会修改PC的内容，因此<strong>总指向将被执行的下一条指令</strong></li>
</ul>
</li>
<li>指令寄存器（Instruction register， IR）<ul>
<li>存有最近取来的指令，在其中分析操作码和操作数</li>
</ul>
</li>
<li>存储器地址寄存器（Memory address register， MAR）<ul>
<li><strong>直接与地址总线相连，存有存储器位置的地址</strong></li>
</ul>
</li>
<li>存储器缓冲寄存器（Memory buffer register， MBR）<ul>
<li><strong>直接与数据总线相连，存有将被写入存储器的数据字或从存储器读出的字</strong>，用户可见寄存器再与MBR交换数据</li>
<li>ALU可对MBR和用户可见寄存器直接存取</li>
</ul>
</li>
</ul>
<p><strong>程序状态字：</strong></p>
<p>一个或<strong>一组</strong>包含状态信息的寄存器， 包含条件码加上其他状态信息</p>
<ul>
<li>包含的字段或标志：（略？）<ul>
<li>符号位 ：容纳算术运算结果的符号位  </li>
<li>零：当结果是0时被置位  </li>
<li>进位carry：若操作导致最高位有向上的进位（加法） 或借位（减法） 时被置位， 用于多字算数运算  </li>
<li>等于位：若逻辑比较的结果相等， 则置位  </li>
<li>溢出位：用于表示算术溢出  </li>
<li>中断允许&#x2F;禁止位：用于允许或禁止中断  </li>
<li>监管位：指出CPU是执行在监管模式中还是在用户模式中</li>
</ul>
</li>
</ul>
<p><strong>其他：</strong></p>
<p>指向含有附加状态信息的存储器块的<strong>指针寄存器</strong></p>
<p>在使用向量式中断的机器中， 可能提供有一个<strong>中断向量寄存器</strong></p>
<p>若栈用于实现某些功能， 需要有一个<strong>系统栈指针</strong></p>
<p>对于虚拟存储器系统， 会有一个<strong>页表指针寄存器</strong>  </p>
<p><strong>设计出发点：</strong></p>
<ul>
<li>对操作系统的支持  <ul>
<li>某些类型的控制信息是专门为操作系统使用的</li>
</ul>
</li>
<li>控制信息在寄存器和存储器之间的分配  <ul>
<li>一种普遍的做法是将存储器最前面（最低地址） 的几百或几千个字用于控制目的</li>
<li>在成本和速度之间进行权衡</li>
</ul>
</li>
</ul>
<h1 id="2-微操作"><a href="#2-微操作" class="headerlink" title="2.微操作"></a>2.微操作</h1><p>回顾：</p>
<p>数据流</p>
<p>指令周期</p>
<p>子周期：取指周期、间址周期、执行、中断  </p>
<p>本节：如何控制各种组件完成数据流功能</p>
<p><strong>定义：</strong>每个子周期由一系列涉及CPU寄存器操作的更小步骤组成，这些步骤称为微操作  </p>
<h2 id="2-1-取指周期微操作"><a href="#2-1-取指周期微操作" class="headerlink" title="2.1 取指周期微操作"></a>2.1 取指周期微操作</h2><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210173811498.png"><span class="image-caption">image-20230210173811498</span></p>
<p>PC-&gt;MAR是指令地址</p>
<p>Mem-&gt;MBR-&gt;IR是指令内容</p>
<ul>
<li>为什么t2&#x2F;t3有两个操作：因为微操作互不冲突</li>
<li>微操作不是唯一的，例如PC+1放在t2和t3都可以</li>
</ul>
<p><strong>微操作分组原则</strong></p>
<ul>
<li>事件的流动顺序必须是恰当的<ul>
<li>例： MAR &lt;- (PC) 必须先于MBR &lt;- 内存， 因为内存读操作要使用MAR中的地址</li>
</ul>
</li>
<li>必须避免冲突(出现同一寄存器)<ul>
<li>例： MBR &lt;- 内存 和IR &lt;- MBR 这两个微操作不应出现在同一时间单位里</li>
</ul>
</li>
<li>满足上述条件下， 所用的<strong>时间单位尽可能少</strong><ul>
<li>例： PC &lt;- (PC) + I不能放在一个单独的时间单位里成为t4</li>
</ul>
</li>
</ul>
<h2 id="2-2-间址周期微操作"><a href="#2-2-间址周期微操作" class="headerlink" title="2.2 间址周期微操作"></a>2.2 间址周期微操作</h2><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210181035586.png"><span class="image-caption">image-20230210181035586</span></p>
<p>t1:取数据地址</p>
<p>t2:取数据</p>
<p>t1和t2不能调换</p>
<h2 id="2-3-执行周期"><a href="#2-3-执行周期" class="headerlink" title="2.3 执行周期"></a>2.3 执行周期</h2><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210181148727.png"><span class="image-caption">image-20230210181148727</span></p>
<p>都不能再压缩</p>
<p>ADD:取操作数X，与R1加</p>
<p>BSA:存原地址到MBRhe1Mem,取新地址到MAR和PC</p>
<h2 id="2-4中断周期"><a href="#2-4中断周期" class="headerlink" title="2.4中断周期"></a>2.4中断周期</h2><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210181944789.png"><span class="image-caption">image-20230210181944789</span></p>
<p><strong>中断周期的任务：处理中断请求。需保存旧地址和旧地址内容</strong></p>
<p>存旧地址到主存和MAR，旧地址内容到MBR，新地址到PC</p>
<h2 id="2-5-指令周期代码（把微操作连起来）"><a href="#2-5-指令周期代码（把微操作连起来）" class="headerlink" title="2.5 指令周期代码（把微操作连起来）"></a>2.5 指令周期代码（把微操作连起来）</h2><p>取指、间址、中断周期各有一个微操作序列，执行周期则对于每个操作码有一个微操作序列  </p>
<p><strong>指令周期代码ICC：</strong></p>
<p>假设一个2位的ICC寄存器，明确CPU处于指令周期哪个阶段 </p>
<p>刚好4种状态</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210182613175.png"><span class="image-caption">image-20230210182613175</span></p>
<p>间接周期、执行周期、中断周期都类似上图。</p>
<h1 id="3-CPU内部控制"><a href="#3-CPU内部控制" class="headerlink" title="3.CPU内部控制"></a>3.CPU内部控制</h1><h2 id="3-1-门管理实例"><a href="#3-1-门管理实例" class="headerlink" title="3.1 门管理实例"></a>3.1 门管理实例</h2><p>ALU和寄存器都连接到CPU内部总线上</p>
<p>内部总线和寄存器之间有门和控制信号 </p>
<p>控制线控制着数据和系统总线（外部）的交换以及ALU的操作  </p>
<p>例子：<img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210202037860.png"><span class="image-caption">image-20230210202037860</span></p>
<p>Y、Z用来暂存，因为总线不能同时传两个数据。</p>
<p><strong>每次开两个门（一入一出）</strong></p>
<h2 id="3-2-控制CPU的功能需求"><a href="#3-2-控制CPU的功能需求" class="headerlink" title="3.2 控制CPU的功能需求"></a>3.2 控制CPU的功能需求</h2><ul>
<li>CPU的基本元素<ul>
<li>ALU，寄存器组，内部数据通路，控制器，外部数据通路</li>
</ul>
</li>
<li>CPU需要完成的微操作(内外 )<ul>
<li>在寄存器之间传送数据<br>将数据由寄存器传送到外部接口（如系统总线）<br>将数据由外部接口传送到寄存器<br>将寄存器作为输入和输出，完成算术和逻辑运算</li>
</ul>
</li>
<li>控制器的两个基本任务<ul>
<li><strong>定序（sequencing）</strong> ：根据正被执行的程序，控制器使CPU以正确的顺序通过一系列微操作</li>
<li><strong>执行（execution）</strong> ：控制器使每个微操作得以完成</li>
</ul>
</li>
</ul>
<h2 id="3-3-控制器的输入输出"><a href="#3-3-控制器的输入输出" class="headerlink" title="3.3 控制器的输入输出"></a>3.3 控制器的输入输出</h2><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210203112589.png"><span class="image-caption">image-20230210203112589</span></p>
<p><strong>输入：</strong></p>
<ul>
<li>指令寄存器： 当前指令的寻址方式（决定有无间址周期）和操作码（决定微操作）</li>
<li>标志： 确定CPU的状态和前一个ALU操作的结果  </li>
<li>时钟： 控制器要在每个时钟脉冲完成一个或一组同时的微操作  </li>
<li>来自控制总线的控制信号： 向控制器提供控制信号<ul>
<li>控制器一般为主动输出。偶尔为被动</li>
<li>例：中断请求</li>
</ul>
</li>
</ul>
<p><strong>输出：</strong></p>
<ul>
<li>CPU内的控制信号：<ul>
<li>用于寄存器之间传送数据</li>
<li>用于启动特定的ALU功能</li>
</ul>
</li>
<li>到控制总线的控制信号：<ul>
<li>到存储器的控制信号</li>
<li>到I&#x2F;O模块的控制信号</li>
</ul>
</li>
</ul>
<p><strong>所有的控制信号最终作为二进制输入量（0&#x2F;1）直接输入到各个逻辑门上</strong>  </p>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><p><strong>取指周期</strong></p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210204128417.png"><span class="image-caption">image-20230210204128417</span></p>
<p><strong>间接取指、中断</strong></p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210204200945.png"><span class="image-caption">image-20230210204200945</span></p>
<h2 id="3-4-控制器的细节实现"><a href="#3-4-控制器的细节实现" class="headerlink" title="3.4 控制器的细节实现"></a>3.4 控制器的细节实现</h2><p><strong>控制器的最小特性 ：</strong></p>
<ul>
<li>它只需要知道将被执行的指令和算术、逻辑运算结果的<strong>性质（如正负、溢出等）</strong>，而不需要知道正被处理的数据或得到的实际结果具体是什么（交由ALU）</li>
<li>它只是以少量的送到CPU内的和送到系统总线上的控制信号来实现控制</li>
</ul>
<p>即：尽可能简洁</p>
<h3 id="硬布线实现（hardwired-implementation）："><a href="#硬布线实现（hardwired-implementation）：" class="headerlink" title="硬布线实现（hardwired implementation）："></a><strong>硬布线实现（hardwired implementation）：</strong></h3><p>控制器是一个组合电路，把输入逻辑信号<strong>通过硬件</strong>转换为一组输出逻辑信号，即控制信号</p>
<ul>
<li><p>标志和控制总线信号  </p>
</li>
<li><p>指令寄存器  </p>
<ul>
<li>通过译码，使<strong>每一操作码有一个唯一的逻辑输入</strong></li>
<li>译码器有 n 个输入和 2^𝑛个输出<ul>
<li>控制器要考虑变长的操作码，译码器会更复杂些</li>
</ul>
</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210205002992.png"><span class="image-caption">image-20230210205002992</span></p>
</li>
<li><p>时钟</p>
<ul>
<li>在一个指令周期（子周期）内，控制器要在不同时间单位发送不同的控制信号</li>
<li>使用一个定时器作为控制器的输入，并且控制器在指令周期（或子周期）结束时必须通知定时器以使其重新开始计数</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210205421295.png"><span class="image-caption">image-20230210205421295</span></p>
</li>
</ul>
<p><strong>硬布线控制的逻辑本质：为每个输出的控制信号设计一个关于控制器输入的布尔表达式</strong>  </p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210205450049.png"><span class="image-caption">image-20230210205450049</span></p>
<h3 id="微程序-固件-实现（microprogrammed-implementation）："><a href="#微程序-固件-实现（microprogrammed-implementation）：" class="headerlink" title="微程序(固件)实现（microprogrammed implementation）："></a><strong>微程序(固件)实现（microprogrammed implementation）：</strong></h3><p><strong>基本概念：</strong></p>
<ul>
<li>控制逻辑是<strong>微程序</strong>指定的，控制器是一个<strong>相对简单的逻辑电路</strong>，通过执行每条<strong>微指令</strong>来产生控制信号 </li>
<li><strong>微程序</strong>（固件） <strong>介于硬件与软件</strong>之间  <ul>
<li>设计固件比设计硬件容易，但写固件程序比软件程序困难</li>
<li>微指令序列</li>
</ul>
</li>
<li><strong>微指令：</strong> 每行描述一个时间内出现的一组微操作</li>
</ul>
<p><strong>基本思路：</strong></p>
<ul>
<li>对于每个微操作，控制器的任务是产生一组控制信号，即控制器发出的每根控制线或开或关（每根控制线由一个二进制数字表示）  </li>
<li>构造一个<strong>控制字，每位代表一根控制线</strong>，这样每个微操作能用控制字中的不同的0和1的样式来表示  </li>
<li>将这些<strong>控制字串在一起</strong>，可以表示控制器需要完成的<strong>微操作序列</strong></li>
</ul>
<p><strong>具体实现：</strong></p>
<ul>
<li>由于微操作序列不是固定的，把<strong>控制字放入一个存储器单元</strong>中， 每个字有自己唯一的地址  </li>
<li>添加少数几位用于指示条件的真假<ul>
<li>若条件位指示的条件为假，则顺序执行下一条指令</li>
<li>若条件位指示的条件为真，则<strong>地址字段</strong>指向的微指令是将被执行的下一条微指令</li>
</ul>
</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210210755662.png"><span class="image-caption">image-20230210210755662</span></p>
<p>（长短表示控制字种类多少）</p>
<p><strong>微程序宏观执行：</strong></p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210211308771.png"><span class="image-caption">image-20230210211308771</span></p>
<p><strong>任务：</strong></p>
<ul>
<li>定序（microinstruction sequencing）  <ul>
<li>根据当前的微指令、 条件标志和指令寄存器的内容， <strong>产生下一微指令</strong>的控制存储器地址  </li>
<li>设计考虑 <ul>
<li>微指令的大小：减小微指令的大小就能节省<strong>控制存储器</strong>的成本</li>
<li>地址生成时间：尽可能快地执行微指令</li>
</ul>
</li>
</ul>
</li>
<li>执行（microinstruction execution）  <ul>
<li>产生控制信号：发往CPU内部， 送往外部控制总线或其他外部接口<ul>
<li>根据微指令中的二进制序列， 设置控制线</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="定序细节"><a href="#定序细节" class="headerlink" title="定序细节"></a>定序细节</h4><p><strong>多种地址格式：</strong></p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210212031773.png"><span class="image-caption">image-20230210212031773</span></p>
<p>单地址较常用。</p>
<p><strong>定序逻辑构成细节：</strong></p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210212057060.png"><span class="image-caption">image-20230210212057060</span></p>
<h4 id="微程序控制流程"><a href="#微程序控制流程" class="headerlink" title="微程序控制流程"></a>微程序控制流程</h4><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210212734243.png"><span class="image-caption">image-20230210212734243</span></p>
<ul>
<li>生成新地址的三个选择 ：<ul>
<li>取顺序下一条微指令：加1到控制地址寄存器</li>
<li>基于跳转微指令转移到一个新的例程：将控制缓冲寄存器的地址字段装入控制地址寄存器</li>
<li>转移到一个机器指令例程：根据IR中的操作码向控制地址寄存器装入机器指令例程的第一条微指令</li>
</ul>
</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230210230355597.png"><span class="image-caption">image-20230210230355597</span></p>
<p><strong>微程序设计优缺点：</strong></p>
<ul>
<li>简化了控制器的设计任务</li>
<li>实现起来既成本较低，也能减少出错机会<ul>
<li>便于更新</li>
</ul>
</li>
<li>缺点：要比采用相同或相近半导体工艺的硬布线控制器慢一些</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>计算机组成原理-学习笔记17-IO输入输出</title>
    <url>/2023/02/10/Lecture%2017%20IO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<p>计算机组成原理-学习笔记17-IO输入输出</p>
<span id="more"></span>

<h1 id="Lecture-17-IO输入输出"><a href="#Lecture-17-IO输入输出" class="headerlink" title="Lecture 17   IO输入输出"></a>Lecture 17   IO输入输出</h1><ul>
<li>外围设备：<ul>
<li>外部设备提供了在外部环境和计算机系统之间的数据交换，通常被称为外围设备（peripheral device），简称为外设（peripheral）。</li>
</ul>
</li>
<li>类型<ul>
<li>人可读设备：适用于与计算机用户通信<ul>
<li>显示器， 打印机， ……</li>
</ul>
</li>
<li>机器可读设备：适用于与设备通信<ul>
<li>磁盘， 磁带， ……</li>
</ul>
</li>
<li>通信设备：适用于与远程设备通信</li>
</ul>
</li>
</ul>
<h1 id="1-IO模块"><a href="#1-IO模块" class="headerlink" title="1.IO模块"></a>1.IO模块</h1><p>产生背景</p>
<ul>
<li>不可以将外设直接连接到系统总线上<ul>
<li>外设操作方法多种多样</li>
<li>外设数据传送速度比cpu和存储器慢得多</li>
<li>某些外设数据传送速度比cpu和存储器快（反正就是不一样）</li>
<li>数据格式和字长度和cpu不同</li>
</ul>
</li>
</ul>
<p>IO模块是计算机内部系统和外设之间的桥梁。（仍属于计算机系统的一部分）</p>
<ul>
<li>通过系统总线和中央交换器和存储器连接</li>
<li>通过专用数据线与一个或多个外设连接</li>
</ul>
<p>采用统一的接口格式</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230223232738686.png"><span class="image-caption">image-20230223232738686</span></p>
<ul>
<li>输入&#x2F;输出模块的接口以<strong>控制、状态和数据</strong>信号的形式出现  </li>
<li>与设备相关的控制逻辑控制外设的操作，以响应来自输入&#x2F;输出模块的命令</li>
<li>缓冲器用于缓存输入&#x2F;输出模块和外设之间传送的数据<ul>
<li>目的：解决IO太快或太慢</li>
<li>缓冲器的大小一般为8位或16位</li>
</ul>
</li>
<li>转换器：模拟信号与数字信号</li>
</ul>
<h2 id="1-1-IO模块的功能"><a href="#1-1-IO模块的功能" class="headerlink" title="1.1.IO模块的功能"></a>1.1.IO模块的功能</h2><p>双向通信</p>
<ul>
<li>与处理器通信<ul>
<li><strong>命令译码：</strong> 输入&#x2F;输出模块接收来自处理器的命令，这些命令一般作为信号发送到<strong>控制总线</strong></li>
<li><strong>状态报告：</strong> 由于外设速度很慢, 所以知道输入&#x2F;输出模块的状态很重要  </li>
<li><strong>数据：</strong> 数据是在处理器和输入&#x2F;输出模块之间经由数据总线来交换的  </li>
<li><strong>地址识别：</strong> 输入&#x2F;输出模块必须能识别它所控制的每个外设的唯一地址</li>
</ul>
</li>
<li>设备通信<ul>
<li>通信内容包含命令、 状态信息和数据</li>
</ul>
</li>
</ul>
<p>数据缓冲</p>
<ul>
<li>类比银行柜员处理文件，排队</li>
</ul>
<p>控制和定时</p>
<ul>
<li>原因<ul>
<li>处理器会非预期的与一个或几个外设进行通信</li>
<li>一些内部资源， 如主存和系统总线， 是被共享的</li>
</ul>
</li>
</ul>
<p>检错</p>
<ul>
<li>检错并把差错信息报告给处理器</li>
<li>差错类型<ul>
<li>设备报告的机械和电路故障</li>
<li>传输过程中数据位的变化</li>
</ul>
</li>
</ul>
<h2 id="1-2-IO模块的结构"><a href="#1-2-IO模块的结构" class="headerlink" title="1.2.IO模块的结构"></a>1.2.IO模块的结构</h2><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230223234124654.png"><span class="image-caption">image-20230223234124654</span></p>
<p>大图&#x3D;小图逆时针转了90°</p>
<ul>
<li><p>左侧：状态&#x2F;控制寄存器用来保存<strong>CPU对外设的命令</strong></p>
<ul>
<li>寄存器复用，知道状态才能控制</li>
</ul>
</li>
<li><p>右侧：有多组外部设备</p>
</li>
</ul>
<p>外部接口（上图左右的细化）</p>
<ul>
<li>串行（用的多）：只有一根线用于传输数据，每次只传输一位数据<ul>
<li>传得远，时钟频率高</li>
</ul>
</li>
<li>并行：多根线连接输入&#x2F;输出模块和外设，同时传送多位数据 <ul>
<li><strong>并行多条线需要保持信息同步</strong>（多人走路）</li>
<li>当传输速度和总线长度增加时， 总线的时钟频率会受到限制<ul>
<li>相邻传输间隔时间变长，避免混淆</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230223234912904.png"><span class="image-caption">image-20230223234912904</span></p>
<ul>
<li>例子<ul>
<li>FireWire： IEEE标准1394串行总线</li>
<li>USB： 通用串行总线（Universal Serial Bus） <ul>
<li>更主流，更快</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-3-IO操作技术"><a href="#1-3-IO操作技术" class="headerlink" title="1.3.IO操作技术"></a>1.3.IO操作技术</h2><ul>
<li><p>编程式I&#x2F;O：<strong>处理器</strong>通过<strong>执行程序</strong>来直接控制I&#x2F;O操作，当处理器发送一条命令到I&#x2F;O模块时，它必须等待，直到I&#x2F;O操作完成</p>
</li>
<li><p>中断驱动式 I&#x2F;O： <strong>处理器</strong>发送一条I&#x2F;O命令后，<strong>继续执行其他指令</strong>；并且当I&#x2F;O模<br>块完成其工作后， 才去中断处理器工作  </p>
</li>
<li><p>直接存储器读取（Direct Memory Access，DMA） ： I&#x2F;O模块<strong>与主存直接交换</strong>数据， 而<strong>不需要处理器</strong>的干涉</p>
<ul>
<li>仅指数据处理不需要cpu。其他可能要用cpu</li>
</ul>
</li>
</ul>
<h3 id="编程式IO"><a href="#编程式IO" class="headerlink" title="编程式IO"></a>编程式IO</h3><ul>
<li><p>当处理器在执行过程中遇到一条与I&#x2F;O操作有关的指令时， 它通过发送指令到适当的I&#x2F;O模块来执行这条指令  </p>
<ul>
<li>读状态-&gt;未就绪 &#x2F; 就绪 &#x2F; 出错</li>
<li>若就绪，由IO读取字</li>
</ul>
</li>
<li><p>I&#x2F;O不会中断处理器， 因此<strong>处理器需要周期性地检查I&#x2F;O模块的状态</strong>， 直到发现该操作完成  </p>
</li>
<li><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230224121950485.png"><span class="image-caption">image-20230224121950485</span></p>
</li>
<li><p>CPU全程100%投入</p>
</li>
</ul>
<p><strong>IO命令</strong></p>
<ul>
<li>处理器发送一个<strong>指定具体I&#x2F;O模块和外设的地址</strong>， 并发送一条I&#x2F;O命令  </li>
<li><strong>控制命令：</strong> 激活外设并告诉它要做什么</li>
<li><strong>测试命令：</strong> 测试I&#x2F;O模块及其外设相关的各种状态条件</li>
<li><strong>读命令：</strong> 使I&#x2F;O模块从外设获得一个数据， 把它存入内部缓冲区</li>
<li><strong>写命令：</strong> 使I&#x2F;O模块从数据总线获得一个数据， 把它传入外设</li>
</ul>
<p><strong>IO指令</strong></p>
<ul>
<li>I&#x2F;O指令很容易映射为I&#x2F;O命令, 并且两者之间通常是简单的<strong>一一对应关系</strong></li>
<li>编址方式<ul>
<li>存储器映射式IO：存储单元和I&#x2F;O设备有统一的地址空间  <ul>
<li>pros：能使用大的指令系统，可进行更有效的编程<br>cons：I&#x2F;O设备占用地址空间</li>
</ul>
</li>
<li>分离式IO：让总线既有存储器的读线和写线，同时也有输入和输出命令线</li>
</ul>
</li>
</ul>
<h3 id="中断驱动式IO"><a href="#中断驱动式IO" class="headerlink" title="中断驱动式IO"></a>中断驱动式IO</h3><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230224124611822.png"><span class="image-caption">image-20230224124611822</span></p>
<ul>
<li>处理器发送一个I&#x2F;O命令到模块，然后去处理其它有用的工作</li>
<li>当I&#x2F;O模块准备和处理器交换数据时，它<strong>中断处理器</strong>以请求服务</li>
</ul>
<p><strong>从IO模块角度：</strong></p>
<ul>
<li>I&#x2F;O模块接收来自处理器的读命令</li>
<li>I&#x2F;O模块从相关的<strong>外设中读入数据</strong></li>
<li>一旦数据进入I&#x2F;O模块的数据寄存器后， 该模块通过<strong>控制总线</strong>给处理器<strong>发送中断信号</strong><ul>
<li>对应上方1.2 IO模块的结构</li>
</ul>
</li>
<li>I&#x2F;O模块<strong>等待</strong>直到处理器请求该数据时为止<ul>
<li>CPU可能有更重要的事</li>
</ul>
</li>
<li>当处理器有数据请求时， I&#x2F;O模块把数据传送到数据总线上， 并准备另一个I&#x2F;O操作</li>
</ul>
<p>**从处理器的角度来看 **</p>
<ul>
<li>处理器发送一个读命令</li>
<li>处理器离开去做其它的事情， 并在<strong>每个指令周期结束时检查中断</strong></li>
<li>当来自I&#x2F;O模块的<strong>中断出现</strong>时， 处理器<strong>保存当前程序的现场</strong></li>
<li>处理器从I&#x2F;O模块读取数据字并保存到主存中</li>
<li>处理器<strong>恢复</strong>刚才正在运行的<strong>程序的现场</strong>， 并继续运行原来的程序</li>
</ul>
<h4 id="两种状态：中断允许-x2F-禁止"><a href="#两种状态：中断允许-x2F-禁止" class="headerlink" title="两种状态：中断允许&#x2F;禁止"></a>两种状态：中断允许&#x2F;禁止</h4><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230224125420695.png"><span class="image-caption">image-20230224125420695</span></p>
<ul>
<li>有时数据过多，需要传送数据时便设为“中断禁止”</li>
<li>中断处理时，也是“中断允许”状态<ul>
<li>可嵌套中断，涉及优先级</li>
</ul>
</li>
</ul>
<p><strong>响应优先级和处理优先级</strong>  </p>
<ul>
<li>例子：公交车上抢座位，<strong>响应优先级</strong>是小伙子腿脚麻利。<strong>处理优先级</strong>是老太太有让座权</li>
<li>存在两个优先级都高的中断源。而高中断源会屏蔽低中断源，只看到更高中断源</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230224130208975.png"><span class="image-caption">image-20230224130208975</span></p>
<ul>
<li>掩码字：根据<strong>处理优先级</strong>，表示会不会屏蔽其他中断。1表示屏蔽<ul>
<li>行屏蔽列</li>
<li>主程序的优先级可以看作最低的</li>
</ul>
</li>
<li>例子流程：<ul>
<li>1：主程序</li>
<li>2：先中断1（响应优先级）<ul>
<li>中断关闭，处理保存，中断1开始</li>
</ul>
</li>
<li>3：处理完1，恢复主程序（pop栈）</li>
<li>4：响应3（push栈3）（响应优先级）</li>
<li>5：中断4抢夺3（push栈4）（处理优先级）（3还没动）</li>
<li>6：恢复3，对2视而不见（处理优先级）</li>
<li>7：恢复主程序</li>
<li>8：push2</li>
<li>9：恢复主程序</li>
</ul>
</li>
</ul>
<h4 id="设备识别"><a href="#设备识别" class="headerlink" title="设备识别"></a>设备识别</h4><p>例：设备有多个USB插口</p>
<ul>
<li><p>多条中断线： 处理器仅仅<strong>挑选具有最高优先级的中断线</strong></p>
<ul>
<li>固定优先级</li>
<li>即使有多条中断线可用， 每条线上也需要采用其它三种技术中的一种</li>
</ul>
</li>
<li><p>软件轮询： 模块的<strong>轮询次序</strong>就决定了模块的优先级</p>
<ul>
<li>轮询顺序决定优先级</li>
<li>轮询每一个I&#x2F;O模块来确定是哪个模块发生的中断</li>
</ul>
</li>
<li><p>菊花链： 链接模块次序就决定了模块的优先级</p>
<ul>
<li>总线结构决定优先级</li>
<li>所有的I&#x2F;O模块<strong>共享一条中断请求线</strong>， 中断应答线采用菊花链穿过这些中断模块</li>
</ul>
</li>
<li><p>独立请求： 中断控制器决定</p>
<ul>
<li>特定的<strong>中断控制器</strong>用于解码和分析优先级</li>
</ul>
</li>
</ul>
<h3 id="DMA直接存储器存取"><a href="#DMA直接存储器存取" class="headerlink" title="DMA直接存储器存取"></a>DMA直接存储器存取</h3><p>前两种技术的不足</p>
<ul>
<li>I&#x2F;O传送速度受<strong>处理器测试和服务设备速度</strong>的限制</li>
<li>处理器负责管理I&#x2F;O传送，对于每一次I&#x2F;O传送，处理器必须执行很多指令</li>
</ul>
<p>DMA：无需经过处理器即可直接访问内存的模块  </p>
<ul>
<li><p>解放了CPU，需要另一个硬件去控制</p>
</li>
<li><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230224155053193.png"><span class="image-caption">image-20230224155053193</span></p>
</li>
<li><p>CPU需要通知DMA</p>
<ul>
<li>处理器通过发送以下信息向DMA模块发出命令：读&#x2F;写、 I&#x2F;O设备地址、 内存中的起始位置、 字数</li>
<li>处理器继续进行其他工作</li>
<li>DMA模块将全部数据块， 每次一个字， <strong>直接将数据传输到存储器</strong>或从存储器读出， 而无需经过处理器</li>
<li>当传输完成时，DMA模块向处理器发送一个中断信号  </li>
<li>DMA优先于CPU访问内存，因为IO设备更快</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230224160653238.png"><span class="image-caption">image-20230224160653238</span></li>
</ul>
</li>
</ul>
<h4 id="DMA访问法"><a href="#DMA访问法" class="headerlink" title="DMA访问法"></a>DMA访问法</h4><ul>
<li><strong>CPU停止法</strong></li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230224161449205.png"><span class="image-caption">image-20230224161449205</span></p>
<p>优点： 控制简单<br>缺点： 影响CPU，没有充分利用内存<br>适用： 高速I&#x2F;O设备的块传输<strong>（数据连续）</strong></p>
<ul>
<li><strong>周期窃取法</strong></li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230224161540555.png"><span class="image-caption">image-20230224161540555</span></p>
<p>优点： <strong>充分利用CPU</strong>和内存，及时响应I&#x2F;O请求<br>缺点： DMA每次都请求总线<br>适用： <strong>I&#x2F;O周期大于存储周期</strong>（一波波数据）</p>
<ul>
<li><strong>交替分时访问法</strong>（各占一半）</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230224161731176.png"><span class="image-caption">image-20230224161731176</span></p>
<p>优点： CPU未停止或等待， DMA不请求总线<br>缺点： CPU周期大于存储周期  </p>
<h4 id="DMA配置"><a href="#DMA配置" class="headerlink" title="DMA配置"></a>DMA配置</h4><p>(以下方式IO聚合度逐渐提高)</p>
<ul>
<li>单总线分离DMA  <ul>
<li>相当于编程式直接分离CPU</li>
</ul>
</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230224162052936.png"><span class="image-caption">image-20230224162052936</span></p>
<ul>
<li>单总线集合的DMA-I&#x2F;O<ul>
<li>DMA成为IO的一部分</li>
</ul>
</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230224162223050.png"><span class="image-caption">image-20230224162223050</span></p>
<ul>
<li>I&#x2F;O 总线 <ul>
<li>共享DMA</li>
</ul>
</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230224162334994.png"><span class="image-caption">image-20230224162334994</span></p>
<h4 id="DMA总流程"><a href="#DMA总流程" class="headerlink" title="DMA总流程"></a>DMA总流程</h4><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230224162507820.png"><span class="image-caption">image-20230224162507820</span></p>
<p>由此可知：查询传送参数、寻道、查找扇区、校验都需要CPU，DMA只在连续读写发挥作用。</p>
<h2 id="1-4-IO模块的演变"><a href="#1-4-IO模块的演变" class="headerlink" title="1.4.IO模块的演变"></a>1.4.IO模块的演变</h2><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230224163354333.png"><span class="image-caption">image-20230224163354333</span></p>
<p>发展趋势：效率提高、模块分离。</p>
<h1 id="2-exam"><a href="#2-exam" class="headerlink" title="2.exam"></a>2.exam</h1><p>4&#x2F;5为重点</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230224172337405.png"><span class="image-caption">image-20230224172337405</span></p>
<p>本质上是寻址题。分辨有几位端口就是2的几次方</p>
<p>“隐含”并不影响结果</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230224172551429.png"><span class="image-caption">image-20230224172551429</span></p>
<p>知识点：扫描能使缓存清空。扫描间隔必须小于缓冲区存满的时间</p>
<p>频率（次数） &#x3D; 1 &#x2F; 时间</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230224174121224.png"><span class="image-caption">image-20230224174121224</span></p>
<p>(a)每秒传64kb，中断64x1000&#x2F;8 &#x3D; 8k次，共计 8k * 100μs &#x3D; 800ms，80%</p>
<ul>
<li>1秒(s) ＝1000毫秒(ms)<br>1毫秒(ms)＝1000微秒 (μs)<br>1微秒(μs)＝1000纳秒 (ns)<br>1纳秒(ns)＝1000皮秒 (ps)</li>
</ul>
<p>(b)</p>
<ul>
<li><p>中断处理 ≠ 中断服务</p>
</li>
<li><p>中断耗时 &#x3D; 中断处理时间 + 中断服务（题中说“延长”，故增加(16-1)*8μs）</p>
</li>
<li><p>处理间隔变长了</p>
</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230224181938553.png"><span class="image-caption">image-20230224181938553</span></p>
<p>a)直接查询方式</p>
<ul>
<li>夺取总线+交回总线200+200</li>
<li>IO数据传送与总线数据传送<strong>同时进行</strong><ul>
<li>故有max(128*500ns，128B&#x2F;400kbs) + 500ns（最后一次一定为总线上）</li>
<li>ms和ns隔了6次方</li>
</ul>
</li>
<li>0.02ms是从？</li>
</ul>
<p>b)周期窃取</p>
<ul>
<li><p>仅计算切换时间和总线传输时间。</p>
</li>
<li><p>IO传输时间2.56ms&#x2F;128 &#x3D; 0.02ms为什么不计？</p>
</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230225085646829.png"><span class="image-caption">image-20230225085646829</span></p>
<p>类似题4</p>
<ul>
<li>直接查询方式 <img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230225093908586.png"><span class="image-caption">image-20230225093908586</span><ul>
<li>1GHz&#x3D;1000MHz &#x3D; 10^9Hz</li>
<li>比较IO传输时间(20μs)与总线传输时间(1000 * 1ns)，最后加上总线时间1μs</li>
<li>CPU占用率一定为100%</li>
</ul>
</li>
<li>中断驱动<img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230225093914432.png"><span class="image-caption">image-20230225093914432</span><ul>
<li>a)中断 &#x3D; 中断请求 + 中断响应 + 中断执行 &#x3D; 1202周期</li>
<li>b)每个字节传送时间(<strong>IO-&gt;CPU-&gt;内存</strong>，和cpu处理IO无关) + 处理每次中断时间 &#x3D; 总时间</li>
</ul>
</li>
<li>DMA<ul>
<li>a)CPU时间只与DMA初始化后处理有关。2000 x 1s x 1000</li>
<li>b)总时间 &#x3D; 每个字节传送时间 + DMA挪用时间(1000周期) + DMA处理时间(a中时间)</li>
</ul>
</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230225100033436.png"><span class="image-caption">image-20230225100033436</span></p>
<p>缓冲区易丢失</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230225100115214.png"><span class="image-caption">image-20230225100115214</span></p>
<p>a)</p>
<ul>
<li>用缓冲区大小 + 中断处理次数 * 中断处理时间 <strong>判断能否中断</strong><ul>
<li>单位时间最小中断次数 &#x3D; 数据传输率 &#x2F; 缓冲区大小</li>
</ul>
</li>
<li>总时间 &#x3D; 最小次数 * 1&#x2F;时钟频率 * 时钟周期数</li>
</ul>
<p>b)同比计算</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230225100953723.png"><span class="image-caption">image-20230225100953723</span></p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230225101024998.png"><span class="image-caption">image-20230225101024998</span></p>
<p>类似PPT例题</p>
<ol>
<li>即使要抢夺，也得先处理响应较快的</li>
<li>回归后也不会第一时间被抢夺</li>
<li>被屏蔽的中断，需要等待回归主程序，再抢夺主程序</li>
</ol>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230225101819003.png"><span class="image-caption">image-20230225101819003</span></p>
<p>a) 直接查询，条件是<strong>查询</strong>间隔时间 &lt; 每个字节IO设备传输率</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230225103515327.png"><span class="image-caption">image-20230225103515327</span></p>
<p>c)中断驱动，条件是<strong>响应中断</strong>间隔时间 &lt; 每个字节IO设备传输率</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>计算机组成原理-学习笔记7-存储器</title>
    <url>/2023/02/10/Lecture%207%20%E5%82%A8%E5%AD%98%E5%99%A8/</url>
    <content><![CDATA[<p>计算机组成原理-学习笔记7-存储器</p>
<span id="more"></span>

<h2 id="Lecture-7-存储器"><a href="#Lecture-7-存储器" class="headerlink" title="Lecture 7 存储器"></a>Lecture 7 存储器</h2><h3 id="1-存储器概念"><a href="#1-存储器概念" class="headerlink" title="1.存储器概念"></a>1.存储器概念</h3><p>存储器由一定数量单元构成</p>
<p>每个单元可被唯一标识</p>
<p>每个单元都能储存一个数值</p>
<ul>
<li>地址：单元的唯一标识符</li>
<li>地址空间：单元总数（标识符总数）</li>
<li><strong>寻址能力：</strong>储存在每个单元中的信息的位数<ul>
<li>大多数存储器是字节（8）寻址的，而执行科学计算的计算机通常是64位寻址的</li>
</ul>
</li>
</ul>
<h3 id="2-层次结构"><a href="#2-层次结构" class="headerlink" title="2.层次结构"></a>2.层次结构</h3><p>原因：达到容量和速度间的平衡。成本的约束</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20221020162140913.png"><span class="image-caption">image-20221020162140913</span></p>
<h3 id="3-半导体存储器"><a href="#3-半导体存储器" class="headerlink" title="3.半导体存储器"></a>3.半导体存储器</h3><p>目前的主流做法。半导体芯片</p>
<ul>
<li>半稳态：类似弹簧</li>
</ul>
<p><strong>位元：</strong></p>
<ul>
<li><p>基本元件。存储1位数据</p>
</li>
<li><p>特性</p>
<p>• 呈现两种稳态（或半稳态）：分别表示二进制的0和1</p>
<p>• 它们能够至少被写入（write）数据一次：用来设置状态</p>
<p>• 它们能够被读取（read）来获得状态信息</p>
</li>
</ul>
<p><img src="/C:/Users\lar\AppData\Roaming\Typora\typora-user-images\image-20221020162749697.png"><span class="image-caption">image-20221020162749697</span></p>
<p><img src="/C:/Users\lar\AppData\Roaming\Typora\typora-user-images\image-20221020162924146.png"><span class="image-caption">image-20221020162924146</span></p>
<p>RAM的写、擦除效率相对EPROM最高</p>
<h3 id="3-1-RAM-Random-Access-Memory"><a href="#3-1-RAM-Random-Access-Memory" class="headerlink" title="3.1 RAM Random-Access Memory"></a>3.1 RAM Random-Access Memory</h3><ul>
<li>Random 随机访问：对存储器中任意数据访问花费时间  与数据所在位置无关</li>
<li>特性：<ul>
<li>可以简单快速读写</li>
<li>易失的（Volatile）</li>
</ul>
</li>
<li>类型：SRAM &#x2F; DRAM 静态 &#x2F; 动态</li>
</ul>
<h4 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a><strong>SRAM</strong></h4><p><img src="/C:/Users\lar\AppData\Roaming\Typora\typora-user-images\image-20221020164747124.png"><span class="image-caption">image-20221020164747124</span></p>
<ul>
<li>RS触发器：即锁存器。储存一个1&#x2F;0。</li>
<li>T1 T2为1时联通，T3 T4为0时连通</li>
</ul>
<p>读：CS&#x3D;0 RW &#x3D; 1</p>
<p>写：CS&#x3D;1 RW &#x3D; 0</p>
<p>WL始终为1，BL由CS、RW决定</p>
<p>一个SRAM位元，共需要6个晶体管,成本较高。</p>
<h4 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a><strong>DRAM</strong></h4><p><img src="/C:/Users\lar\AppData\Roaming\Typora\typora-user-images\image-20221020165342433.png"><span class="image-caption">image-20221020165342433</span></p>
<p>放大器补充电荷</p>
<h4 id="SRAM和DRAM对比"><a href="#SRAM和DRAM对比" class="headerlink" title="SRAM和DRAM对比"></a>SRAM和DRAM对比</h4><p><img src="/C:/Users\lar\AppData\Roaming\Typora\typora-user-images\image-20221020165629786.png"><span class="image-caption">image-20221020165629786</span></p>
<p>根据优缺点<strong>应用</strong>：SRAM常用于Cache, DRAM常用于内存条</p>
<h3 id="3-2-ROM与PROM-只读存储器"><a href="#3-2-ROM与PROM-只读存储器" class="headerlink" title="3.2 ROM与PROM 只读存储器"></a>3.2 ROM与PROM 只读存储器</h3><p>Read Only。</p>
<p><strong>ROM</strong></p>
<ul>
<li>特性:<ul>
<li>非易失的，断电后信息仍保存</li>
<li>可读，不可写入数据</li>
</ul>
</li>
<li>无出错处理机会</li>
<li>用户无法写入数据：唯一的数据写入机会在出厂时完成</li>
</ul>
<p><strong>PROM</strong></p>
<ul>
<li><p>非易失的</p>
</li>
<li><p>只能被写入一次</p>
<ul>
<li>写过程是用电信号执行</li>
<li>需要特殊设备来完成写或“编程”过程</li>
</ul>
</li>
</ul>
<h3 id="3-3-EPROM光可擦除-EEPROM电可擦除-快闪储存器"><a href="#3-3-EPROM光可擦除-EEPROM电可擦除-快闪储存器" class="headerlink" title="3.3 EPROM光可擦除 EEPROM电可擦除 快闪储存器"></a>3.3 EPROM光可擦除 EEPROM电可擦除 快闪储存器</h3><p>• Read-Mostly Memory</p>
<p>• 特性</p>
<p>​	• 非易失的</p>
<p>​	• 写操作与读操作相比，较为困难</p>
<p>• 应用</p>
<p>​	• 读操作比写操作频繁得多的场景</p>
<p>• 类型</p>
<p>​	• EPROM</p>
<p>​	• EEPROM</p>
<p>​	• Flash memory</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/image-20221103111650302.png"><span class="image-caption">image-20221103111650302</span></p>
<h2 id="4-从存储位元到主存储器"><a href="#4-从存储位元到主存储器" class="headerlink" title="4.从存储位元到主存储器"></a>4.从存储位元到主存储器</h2><p><strong>位元-&gt;寻址单元-&gt;储存阵列-&gt;芯片 ➔ 模块组织 ➔ 主存</strong></p>
<h3 id="4-1如何寻址"><a href="#4-1如何寻址" class="headerlink" title="4.1如何寻址"></a>4.1如何寻址</h3><p>寻址单元（Addressable unit）：由若干相同地址的位元组成</p>
<ul>
<li>位元 比特指二进制中的一位</li>
</ul>
<p>寻址模式</p>
<p>• 字节（Byte）：常用</p>
<p>• 字（Word）</p>
<p><strong>存储阵列（Memory Array）：由大量寻址单元组成</strong></p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/image-20221103112534056.png"><span class="image-caption">image-20221103112534056</span></p>
<h3 id="4-2-如何刷新"><a href="#4-2-如何刷新" class="headerlink" title="4.2 如何刷新"></a>4.2 如何刷新</h3><p><strong>约束：刷新会占用片选线、地址线、地址译码器</strong></p>
<p>• <strong>集中式刷新（<strong><strong>Centralized refresh</strong></strong>）</strong></p>
<p>​	• 停止读写操作，并<strong>逐行刷新</strong></p>
<p>​	• 刷新时无法操作内存（死区）</p>
<p>• <strong>分散式刷新（<strong><strong>Decentralized refresh</strong></strong>）</strong></p>
<p>​	• 在<strong>每个存储周期</strong>中，当读写操作完成时进行刷新</p>
<p>​	• 一次读写刷新一行，逐行刷新</p>
<p>​	• 会增加每个存储周期的时间</p>
<p>• <strong>异步刷新（<strong><strong>Asynchronous refresh</strong></strong>）</strong></p>
<p>​	• 每一行各自以固定间隔（小于最大刷新周期，毫秒级）刷新</p>
<p>​	• 将DRAM的刷新<strong>安排在CPU对指令的译码阶段</strong>，可有效避免死区</p>
<p>​	• 效率高：常用 </p>
<h3 id="4-3-DRAM架构"><a href="#4-3-DRAM架构" class="headerlink" title="4.3 DRAM架构"></a>4.3 DRAM架构</h3><p><strong>问题：传统DRAM是异步的</strong></p>
<p>​	• 传统的DRAM芯片受到其<strong>内部架构和与处理器内存总线接口</strong>的限制</p>
<p>​	• 处理器向内存提供地址和控制信号，表示内存中特定单元的一组数据应该被读出或写入DRAM</p>
<p>​	• DRAM执行各种内部功能，如激活行和列地址线的高电容，读取数据，以及通过输出缓冲将数据输出，处理器只能等待这段延迟，即存取时间</p>
<p>​	• 延时后，DRAM才写入或读取数据</p>
<p>• <strong>解决：高级DRAM架构是同步的</strong></p>
<p>​	• 同步DRAM（Synchronous DRAM, SDRAM）</p>
<p>​	• 双速率SDRAM（Double-Data-Rate SDRAM，DDR SDRAM &#x2F; DDR）</p>
<h4 id="DDR-SDRAM"><a href="#DDR-SDRAM" class="headerlink" title="DDR SDRAM"></a>DDR SDRAM</h4><p>Double Data Rate：每个时钟周期发送两次数据，一次在时钟脉冲的上升沿，一次在下降沿。</p>
<p>优化：1、增加操作频率。2、增加预取缓冲区</p>
<p><strong>主要提升的是带宽</strong>。</p>
<h3 id="4-4-模块组织"><a href="#4-4-模块组织" class="headerlink" title="4.4 模块组织"></a>4.4 模块组织</h3><p><strong>储存阵列-&gt;芯片 ➔ 模块组织 ➔ 主存</strong></p>
<ul>
<li>位扩展(每字的位)：地址线不变，数据线增加<ul>
<li>使用 8 块 4K*1 bit 的芯片组成 4K*8 bit的存储器</li>
<li>需增加7根数据线</li>
</ul>
</li>
<li>字扩展(含多少字)：地址线增加，数据线不变<ul>
<li>使用 4 个 16K *8 bit 的芯片组成 64K*8 bit 的存储器</li>
<li>需增加2根地址线 (log2[（64&#x2F;16）])<ul>
<li>地址是寻字的</li>
</ul>
</li>
</ul>
</li>
<li>字、位同时扩展：地址线增加，数据线增加<ul>
<li>使用 8 个 16K*4 bit 的芯片组成 64K*8 bit 的存储器</li>
</ul>
</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/image-20221103120054038.png"><span class="image-caption">image-20221103120054038</span></p>
<p>(左侧地址线，右侧数据线)</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>计算机组成原理-学习笔记8-cache</title>
    <url>/2023/02/10/Lecture%208%20cache/</url>
    <content><![CDATA[<p>计算机组成原理-学习笔记8-cache</p>
<span id="more"></span>



<p>主板内储存器：寄存器 &#x2F; Cache &#x2F; 主存</p>
<h1 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h1><p>内存墙：CPU运算速度比内存的速度快，且两者差距不断扩大</p>
<p>解决： CPU和内存之间增加Cache</p>
<ul>
<li>在使用主存（相对大而慢）之余，添加一块小而快的cache</li>
<li>Cache位于CPU和主存之间，可以<strong>集成在CPU内部</strong>或作为主板上的一个模块</li>
<li>Cache中存放了主存中的<strong>部分信息的副本</strong></li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/image-20221101165348656.png"><span class="image-caption">image-20221101165348656</span></p>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>• <strong>检查（Check）</strong>：当CPU试图访问主存中的某个字时，首先检查这个字是否在cache中</p>
<ul>
<li>检查后分两种情况处理：</li>
</ul>
<p>• <strong>命中（Hit）</strong>：如果在cache中，则把这个字传送给CPU</p>
<p>• <strong>未命中（Miss）</strong>：如果不在cache中, 则将主存中包含这个字固定大小的块（block）读入cache中，然后再从cache传送该字给CPU</p>
<h2 id="1-Questions"><a href="#1-Questions" class="headerlink" title="1.Questions"></a>1.Questions</h2><h4 id="如何判断是命中还是未命中"><a href="#如何判断是命中还是未命中" class="headerlink" title="如何判断是命中还是未命中?"></a>如何判断是命中还是未命中?</h4><p>• CPU通过<strong>位置</strong>对主存中的内容进行寻址，不关心存储在其中的内容</p>
<p>• Cache通过<strong>标记（tags）</strong>来标识其内容在主存中的对应位置（tag存放在块之前）</p>
<h4 id="如果未命中，为什么不直接把所需要的字从内存传送到CPU"><a href="#如果未命中，为什么不直接把所需要的字从内存传送到CPU" class="headerlink" title="如果未命中，为什么不直接把所需要的字从内存传送到CPU?"></a>如果未命中，为什么不直接把所需要的字从内存传送到CPU?</h4><p>以便再次访问时命中。</p>
<p>局部性原理：处理器频繁访问主存中相同或相邻位置的现象。</p>
<ul>
<li>时间局部性 ：短时间周期访问相同位置</li>
<li>空间局部性：短时间周期内访问相邻储存位置<ul>
<li>顺序局部性：线性排列（如数组）</li>
</ul>
</li>
</ul>
<h4 id="如果未命中，为什么从内存中读入一个块而不只读入一个字"><a href="#如果未命中，为什么从内存中读入一个块而不只读入一个字" class="headerlink" title="如果未命中，为什么从内存中读入一个块而不只读入一个字?"></a>如果未命中，为什么从内存中读入一个块而不只读入一个字?</h4><p>利用空间局部性。</p>
<ul>
<li>块是预先划分好的</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/image-20221101172526290.png"><span class="image-caption">image-20221101172526290</span></p>
<h4 id="使用Cache后需要更多的操作，为什么还可以节省时间"><a href="#使用Cache后需要更多的操作，为什么还可以节省时间" class="headerlink" title="使用Cache后需要更多的操作，为什么还可以节省时间"></a>使用Cache后需要更多的操作，为什么还可以节省时间</h4><p>假设p是<strong>命中率</strong>， 𝑇𝐶 是cache的访问时间， 𝑇𝑀 是主存的访问时间，使用cache时的<strong>平均访问时间</strong>𝑇𝐴为：</p>
<p>𝑇𝐴 &#x3D; 𝑝 × 𝑇𝐶 + 1 − 𝑝 × 𝑇𝐶 + 𝑇𝑀</p>
<p>&#x3D; 𝑇𝐶 + (1 − 𝑝) × 𝑇𝑀</p>
<p>命中率p越大， 𝑇𝐶越小， 效果越好（降低TM很难，故要么提高p要么减少TC）</p>
<ul>
<li><p>如果想要 𝑇𝐴 &lt; 𝑇𝑀, 必须要求</p>
<ul>
<li>𝑝 &gt; 𝑇𝐶 &#x2F; 𝑇𝑀</li>
</ul>
</li>
<li><p>难点：cache的容量远远小于主存的容量（随机访问时𝑝 &#x3D; Cache容量 &#x2F;主存容量）</p>
</li>
</ul>
<h2 id="2-未命中的原因"><a href="#2-未命中的原因" class="headerlink" title="2.未命中的原因"></a>2.未命中的原因</h2><p><strong>义务失效（Compulsory Miss）&#x2F; 冷启动失效（Cold Start Miss）</strong></p>
<ul>
<li>第一次访问一个块时</li>
</ul>
<p>• 例如：第一次访问一个数组，会发生义务失效</p>
<ul>
<li><strong>容量失效 （Capacity Miss）</strong></li>
</ul>
<p>• Cache无法保存程序访问所需的所有数据块，则当某数据块被替换后，又重新被访问，则发生失效</p>
<p>• 例如： cache大小为8KB，如果需要重复访问一个16KB大小的数组，数组无法全部放入cache，会发生容量失效</p>
<ul>
<li><strong>冲突失效（Conflict Miss）</strong></li>
</ul>
<p>• 多个存储器位置映射到同一Cache位置</p>
<p>• 例如：有两个4KB大小的数组都映射到了相同的地址，需要来回访问，则发生冲突失效</p>
<h2 id="3-设计Cache所需考虑要素"><a href="#3-设计Cache所需考虑要素" class="headerlink" title="3.设计Cache所需考虑要素"></a>3.设计Cache所需考虑要素</h2><h3 id="3-1Chche容量"><a href="#3-1Chche容量" class="headerlink" title="3.1Chche容量"></a>3.1Chche容量</h3><p>扩大cache容量带来的结果：</p>
<p>good: 增大了命中率𝑝</p>
<p>bad: 增加了cache的开销和访问时间 𝑇𝐶</p>
<h3 id="3-2映射功能"><a href="#3-2映射功能" class="headerlink" title="3.2映射功能"></a>3.2映射功能</h3><h4 id="1-直接映射："><a href="#1-直接映射：" class="headerlink" title="1.直接映射："></a>1.直接映射：</h4><p>地址中最高𝑛位, 𝑛 &#x3D; 𝑙𝑜𝑔2𝑀 − 𝑙𝑜𝑔2C**(M为块的数量)**</p>
<p>每个块映射到<strong>一个固定可用的</strong>cache行中.</p>
<p>假设𝑖是cache行号，𝑗是主存储器的块号，𝐶是cache的行数,则i &#x3D; j mod c</p>
<p>（同行号则低l𝑜𝑔2 𝐶位相同）</p>
<p><strong>主存地址映射为：</strong>标记 | Cache行号 | 块内地址</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/image-20221103162423116.png"><span class="image-caption">image-20221103162423116</span></p>
<ul>
<li>主存标记与字块标记比较</li>
<li>未命中，则说明映射到同mod块，需替换</li>
</ul>
<p><strong>优缺点</strong></p>
<ul>
<li>优点<ul>
<li>简单</li>
<li>快速映射</li>
<li>快速检查</li>
</ul>
</li>
<li>缺点<ul>
<li>抖动现象（Thrashing）：如果一个程序重复访问两个需要映射到同一行中,且来自不同块的字，则这两个块不断地被交换到cache中，cache的命中率将会降低，即发生冲突失效</li>
</ul>
</li>
<li>适合<strong>大容量的cache</strong><ul>
<li>行数变多，发生冲突失效的概率降低</li>
<li>硬件电路简单，增大容量对𝑇𝐶的影响不明显，且能增大p</li>
</ul>
</li>
</ul>
<h4 id="2-关联映射"><a href="#2-关联映射" class="headerlink" title="2.关联映射"></a>2.关联映射</h4><p>一个主存块可以装入cache<strong>任意一行</strong></p>
<p>地址中最高𝑛位, 𝑛 &#x3D; 𝑙𝑜𝑔2𝑀（M为块的数量）</p>
<p>主存地址映射为：标记 | 字</p>
<p><strong>示例</strong></p>
<p>• 假设cache有4行，每行包含8个字；主存中包含128个字。访问主存的地址长度为7&#x3D;log2(128)位，则：</p>
<p>​	• 最低的3位：块内地址</p>
<p>​	• 最高的4位：块号，记录为Cache标记</p>
<p><strong>优缺点</strong></p>
<p>• 优点</p>
<p>​	• 避免抖动</p>
<p>• 缺点</p>
<p>​	• 实现起来比较复杂</p>
<p>​	• Cache搜索代价很大，即在检查的时候需要去访问cache的每一行</p>
<p>• 适合<strong>容量较小的cache</strong></p>
<p>​	• 小容量更容易发生冲突失效</p>
<p>​	• 小容量检查的时间短</p>
<h4 id="3-组关联映射"><a href="#3-组关联映射" class="headerlink" title="3.组关联映射"></a>3.组关联映射</h4><p>结合上两种映射方式的优点（也结合了缺点）：</p>
<ul>
<li>Cache分为若干组，每一组包含相同数量的行，每个主存块被映射到<strong>固定组的任意一行</strong></li>
<li>假设𝑠是cache组号，𝑗是主存块号，𝑆是组数<ul>
<li>s &#x3D; 𝑗 𝑚𝑜𝑑 𝑆</li>
</ul>
</li>
<li>K-路（K路：每组有多少行）组关联映射：<ul>
<li>𝐾 &#x3D; 𝐶&#x2F;𝑆 （总行数column&#x2F;总组数segment）（小心考试弄反）</li>
</ul>
</li>
</ul>
<p>​	</p>
<p>标记：地址中最高𝑛位，𝑛 &#x3D; 𝑙𝑜𝑔2𝑀 − 𝑙𝑜𝑔2𝑆</p>
<p><strong>主存地址映射为：</strong>标记 | Cache<strong>组</strong>号 | 块内地址</p>
<h4 id="4-三种比较"><a href="#4-三种比较" class="headerlink" title="4.三种比较"></a>4.三种比较</h4><p>• 关联度（Correlation）：一个主存块映射到cache中可能存放的位置个数</p>
<p>​	• 直接映射：1</p>
<p>​	• 关联映射：𝐶</p>
<p>​	• 组关联映射：𝐾</p>
<p>• 关联度越低，<strong>命中率越低</strong></p>
<p>​	• 直接映射的命中率最低，关联映射的命中率最高</p>
<p>• 关联度越低，判断是否命中的时间越短（即<strong>搜索成本越低）</strong></p>
<p>​	• 直接映射的命中时间最短，关联映射的命中时间最长</p>
<p>• 关联度越低，标记所占额外空间开销越小（即<strong>标记长度越短</strong>）</p>
<p>​	• 直接映射的标记最短，关联映射的标记最长</p>
<h3 id="3-3-替换算法"><a href="#3-3-替换算法" class="headerlink" title="3.3 替换算法"></a>3.3 替换算法</h3><ul>
<li>采用替换算法的情景是，多行可选且多行均被占（直接映射不需要算法，直接换）</li>
<li>替换算法通过<strong>硬件</strong>来实现</li>
<li>设计替换算法的<strong>目标是提高命中率</strong>（比随机好）</li>
</ul>
<h4 id="最近最少使用算法（Least-Recently-Used-LRU）"><a href="#最近最少使用算法（Least-Recently-Used-LRU）" class="headerlink" title="最近最少使用算法（Least Recently Used, LRU）"></a>最近最少使用算法（Least Recently Used, LRU）</h4><p>假设：<strong>最近使用</strong>过的数据块有可能会被再次使用</p>
<p>策略：替换在cache中<strong>最长时间未被访问</strong>的数据块</p>
<p>2路组实现实例：</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/image-20221103165510353.png"><span class="image-caption">image-20221103165510353</span></p>
<p>4路组实例：</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/image-20221103170805466.png"><span class="image-caption">image-20221103170805466</span></p>
<p>即：命中时清零，其他加一。</p>
<p>未命中时，淘汰k-1的,其他加一</p>
<h4 id="先进先出算法（First-In-First-Out-FIFO）"><a href="#先进先出算法（First-In-First-Out-FIFO）" class="headerlink" title="先进先出算法（First In First Out, FIFO）"></a>先进先出算法（First In First Out, FIFO）</h4><p>• <strong>假设：</strong>最近由<strong>主存载入</strong>Cache的数据块更有可能被使用</p>
<p>• <strong>策略：</strong>替换掉在Cache中停留时间最长的块</p>
<p>• <strong>实现：</strong>时间片轮转法 或 环形缓冲技术</p>
<p>​	• 每行包含一个标识位</p>
<p>​	• 当同一组中的某行被替换时，将其标识位设为1，同时将其下一行的标识位设为0</p>
<p>​		• 如果被替换的是该组中的最后一行，则将该组中的第一行的标识位设为0</p>
<p>​	• 当将新的数据块读入该组时，替换掉标识位为0的行中的数据块</p>
<p><strong>样例：</strong></p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221103172513489.png"><span class="image-caption">image-20221103172513489</span></p>
<ul>
<li><strong>与LRU的区别：LRU是访问时间，FIFO为总停留时间</strong></li>
</ul>
<h4 id="最不经常使用算法（Least-Frequently-Used-LFU）"><a href="#最不经常使用算法（Least-Frequently-Used-LFU）" class="headerlink" title="最不经常使用算法（Least Frequently Used, LFU）"></a>最不经常使用算法（Least Frequently Used, LFU）</h4><p>• 假设：访问越频繁的数据块越有可能被再次使用</p>
<p>• 策略：替换掉cache中被访问次数最少的数据块</p>
<p>• 实现：为每一行设置计数器LFU</p>
<ul>
<li><strong>与LRU的区别：LRU是访问时间，LFU为访问次数</strong></li>
</ul>
<h4 id="随机替换算法（Random）"><a href="#随机替换算法（Random）" class="headerlink" title="随机替换算法（Random）"></a>随机替换算法（Random）</h4><p>• 假设：每个数据块被再次使用的可能性是相同的</p>
<p>• 策略：随机替换cache中的数据块</p>
<p>• 实现：随机替换</p>
<p>• 随机替换算法在性能上只稍逊于使用其它替换算法</p>
<h3 id="3-4-写策略"><a href="#3-4-写策略" class="headerlink" title="3.4 写策略"></a>3.4 写策略</h3><ul>
<li><p>主存和cache的一致性</p>
<ul>
<li>cache被替换时，需考虑该cache数据块是否被修改</li>
</ul>
</li>
<li><p>替换时</p>
<ul>
<li>如果没被修改，则该数据块可以直接被替换</li>
<li>如果被修改，则在替换之前必须将修改后的数据块写入主存</li>
</ul>
</li>
<li><p><strong>写策略</strong></p>
<p>• 写直达（Write Through）</p>
<p>• 写回法（Write Back）</p>
</li>
</ul>
<h4 id="缓存命中时的写策略"><a href="#缓存命中时的写策略" class="headerlink" title="缓存命中时的写策略"></a>缓存命中时的写策略</h4><ol>
<li><strong>写直达</strong></li>
</ol>
<p>• <strong>所有写操作同时对cache和主存进行</strong></p>
<p>• <strong>优点</strong>：确保主存中的数据总是和cache中的数据一致，总是最新的（例如多CPU同步的场景）</p>
<p>• <strong>缺点</strong>：产生大量的主存访问，减慢写操作</p>
<p>• 搭配写不分配</p>
<ol start="2">
<li><strong>写回法</strong></li>
</ol>
<p>• <strong>先更新cache中的数据，当cache中某个数据块被替换时，如果它被修改了，才被写回主存</strong></p>
<p>• <strong>利用一个脏位（dirty bit）或者使用位（use bit）来表示块是否被修改</strong></p>
<p>• <strong>优点</strong>：减少了访问主存的次数</p>
<p>• <strong>缺点</strong></p>
<p>​	• 部分主存数据可能不是最新的（例如未发生替换但需要读主存的场景）</p>
<p>​		• I&#x2F;O模块存取时可能无法获得最新的数据，为解决该问题会使得电路设计更加复杂且有可能带来性能瓶颈</p>
<p>• 搭配写分配</p>
<h4 id="缓存未命中时的写策略"><a href="#缓存未命中时的写策略" class="headerlink" title="缓存未命中时的写策略"></a>缓存未命中时的写策略</h4><p>• <strong>写不分配（<strong><strong>Write Non-Allocate</strong></strong>）：</strong>直接将数据写入主存，无需读入cache</p>
<p>​	• 优点：避免cache和主存中的数据不一致</p>
<p>​	• 通常搭配：写直达</p>
<p>• <strong>写分配（<strong><strong>Write Allocate</strong></strong>）：</strong>将数据所在的块读入cache后，在cache中更新内容</p>
<p>​	• 优点：利用了cache的高速特性，<strong>减少写内存次数</strong></p>
<p>​	• 通常搭配：写回法</p>
<h3 id="3-5-行大小"><a href="#3-5-行大小" class="headerlink" title="3.5 行大小"></a>3.5 行大小</h3><p>Cache命中率先升后降</p>
<ul>
<li><p>假设从行的大小为一个字开始，随着<strong>行大小的逐步增大</strong>，则Cache命中率会增加</p>
<ul>
<li>原因：装入了<strong>更多数据</strong></li>
</ul>
</li>
<li><p>行大小变得较大之后，<strong>继续增加行大小</strong>，则Cache命中率会下降</p>
<ul>
<li>Cache容量一定的前提下，较大的行会导致Cache中的行数变少，导致装入cache中的<strong>数据块数量减少</strong>，进而造成<strong>数据块被频繁替换</strong></li>
<li>每个数据块中包含的数据在主存中位置变远，被使用的可能性减小</li>
</ul>
</li>
<li><p>行大小与命中率之间的关系较为复杂</p>
<ul>
<li>行太小，<strong>行数太多</strong>反时间局部性</li>
<li>行太大<strong>，行数太少</strong>反空间局部性</li>
</ul>
</li>
</ul>
<h3 id="3-6-Cache数目"><a href="#3-6-Cache数目" class="headerlink" title="3.6 Cache数目"></a>3.6 Cache数目</h3><ul>
<li>一级<ul>
<li>cache与处理器至于同一芯片</li>
<li>减少处理器在总线上的执行时间</li>
</ul>
</li>
<li>多级<ul>
<li>当L1（一级缓存）未命中时，减少处理器对总线上DRAM或ROM的访问</li>
<li>使用单独的数据路径，代替系统总线在L2缓存和处理器之间传输数据，部分处理器将L2（二级缓存） cache结合到处理器芯片上</li>
</ul>
</li>
</ul>
<p>统一VS分立</p>
<ul>
<li>统一<ul>
<li>更高的命中率，在获取<strong>指令和数据</strong>的负载之间自动进行平衡</li>
<li>只需要设计和实现一个cache</li>
</ul>
</li>
<li>分立<ul>
<li>实现多个cache</li>
<li>消除cache在指令的<strong>取值&#x2F;译码单元和执行单元</strong>之间的竞争，在任何基于指令流水线的设计中都是重要的</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>计算机组成原理-学习笔记9-外部存储器</title>
    <url>/2023/02/10/Lecture%209%20%E5%A4%96%E9%83%A8%E5%82%A8%E5%AD%98%E5%99%A8/</url>
    <content><![CDATA[<p>计算机组成原理-学习笔记9-外部存储器</p>
<span id="more"></span>



<h1 id="lecture-9-互连及输入输出组织"><a href="#lecture-9-互连及输入输出组织" class="headerlink" title="lecture 9 互连及输入输出组织"></a>lecture 9 互连及输入输出组织</h1><p>金字塔的下半部分</p>
<h2 id="外部存储设备"><a href="#外部存储设备" class="headerlink" title="外部存储设备"></a>外部存储设备</h2><ul>
<li>特性<ul>
<li>储存不常使用的 数据量较大的信息</li>
<li>非易失</li>
</ul>
</li>
<li>类型<ul>
<li>磁盘储存器</li>
<li>光储存器</li>
<li>磁带</li>
<li>U盘 固态硬盘</li>
</ul>
</li>
</ul>
<h1 id="磁盘存储器"><a href="#磁盘存储器" class="headerlink" title="磁盘存储器"></a>磁盘存储器</h1><ul>
<li>磁盘是由涂有<strong>可磁化材料</strong>的<strong>非磁性材料</strong>（基材）构成的圆形盘片<ul>
<li>基材：铝、铝合金、<strong>玻璃</strong>……</li>
<li><strong>玻璃基材的优势（稳定可靠、为存储更多信息提供基础）</strong><ul>
<li>改善磁膜表面的均匀性，提高磁盘的可靠性</li>
<li>显著减少整体表面瑕疵，以帮助减少读写错误</li>
<li>能够支持（磁头）较低的<strong>飞行高度</strong>（更强的磁信号）<ul>
<li>磁头飞行在磁盘上面，其实是利用微空气动力学，磁盘高速旋转带来了高速的气流，附的气体磁头提供了升力。</li>
</ul>
</li>
<li>更高的硬度，使磁盘转动时更加稳定</li>
<li>更强的抗冲击和抗损伤能力</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>类型：硬盘、软盘</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221109143209663.png"><span class="image-caption">image-20221109143209663</span></p>
<ul>
<li>轴逆时针转</li>
<li>每个盘片有一个读写磁头，通过机械方式固定的同时移动</li>
<li>任何时候，所有磁头都等距离位于磁道上</li>
</ul>
<p>磁头：</p>
<ul>
<li><p>对盘片进行<strong>读写操作</strong>的装置叫做磁头</p>
<ul>
<li><p>磁头产生&#x2F;感应电磁场</p>
</li>
<li><p>磁头越窄，<strong>电磁感应能力</strong>越弱，离盘片的距离越近</p>
</li>
<li><p>更高的<strong>数据密度</strong>需要更窄的磁头和更窄的磁道，这将导致更高的出错风险</p>
</li>
<li><p>硬盘必须密封</p>
</li>
<li><p><strong>温彻斯特磁头</strong>（Winchester head）</p>
<p>• 一个空气动力箔片，当磁盘静止时，它轻轻地停留在盘片的表面上</p>
<p>• 旋转圆盘时产生的空气压力足以使箔片上升到盘片表面上方</p>
</li>
</ul>
</li>
</ul>
<h2 id="磁头读写机制"><a href="#磁头读写机制" class="headerlink" title="磁头读写机制"></a>磁头读写机制</h2><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221109144837544.png"><span class="image-caption">image-20221109144837544</span></p>
<ul>
<li>读或写期间，磁头静止，盘片在下方旋转</li>
<li>磁头数量<ul>
<li>单磁头：读写公用（软盘&#x2F;早期硬盘）</li>
<li>双磁头：单独的读写（当代硬盘）</li>
</ul>
</li>
</ul>
<h3 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h3><ul>
<li>电流脉冲被发送到写入磁头</li>
<li>变化的电流发出磁场</li>
<li><strong>磁性图案（磁针）</strong>被记录在下方盘片<ul>
<li>反转电流方向，则记录介质上的磁化方向也会反转</li>
<li>感应<strong>电流稳定需要时间</strong></li>
<li><strong>单磁头时，不加电流可以读</strong></li>
</ul>
</li>
</ul>
<h3 id="读取机制"><a href="#读取机制" class="headerlink" title="读取机制"></a>读取机制</h3><ul>
<li>由部分屏蔽（为了精准获取下方）的<strong>磁阻（MR）敏感器</strong>组成，其电阻取决于<strong>下方介质的磁化方向</strong></li>
<li>恒定电流通过MR敏感器时，通过电压检测电阻变化（U&#x3D; IR）</li>
<li>MR敏感器允许更高频率的操作，实现更高的存储密度和更快的操作速度<ul>
<li>电压改变比电流更快（<strong>读比写更快</strong>）</li>
<li>比单磁头对磁性介质的要求低</li>
</ul>
</li>
</ul>
<h2 id="数据组织（结构）"><a href="#数据组织（结构）" class="headerlink" title="数据组织（结构）"></a>数据组织（结构）</h2><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221109144933827.png"><span class="image-caption">image-20221109144933827</span></p>
<ul>
<li>一组同心圆环，称为<strong>磁道</strong></li>
<li>数据以<strong>扇区</strong>的形式传输或传出到磁盘<ul>
<li>默认512B</li>
</ul>
</li>
<li>磁道间有间隙</li>
<li>从外往里编号递增，磁头停止时在磁道0外侧</li>
</ul>
<h3 id="扇区划分"><a href="#扇区划分" class="headerlink" title="扇区划分"></a>扇区划分</h3><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221109151721899.png"><span class="image-caption">image-20221109151721899</span></p>
<ul>
<li>恒定角速度<ul>
<li>增大信息位区隔，使得磁盘能够以恒定的速度扫描信息，即<strong>恒定的数据传输率</strong></li>
<li>优点：能直接从<strong>磁道号和扇区号寻址</strong>数据块</li>
<li>缺点：磁盘储存容量受到最内层磁道的最大记录密度的限制</li>
</ul>
</li>
<li>多带式记录&#x2F;多重区域记录<ul>
<li>距离中心较远的分区包含的扇区数多于距离中心较近的分区</li>
<li><strong>优点：</strong>提升存储容量</li>
<li><strong>缺点：</strong>需要更复杂的电路</li>
</ul>
</li>
<li><strong>所有盘片上处于相同的相对位置的一组磁道被称为柱面(cylinder)</strong></li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221130001959538.png"><span class="image-caption">image-20221130001959538</span></li>
</ul>
<h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221109152855187.png"><span class="image-caption">image-20221109152855187</span></p>
<ul>
<li><p>低级格式化&#x2F;<strong>物理格式化</strong></p>
<ul>
<li>清除数据</li>
<li>有损：是一种损伤性操作，它对硬盘寿命有影响</li>
<li>建议场景：硬盘受到外部强磁体、强磁场的影响而受到物理性损伤的情况</li>
</ul>
</li>
<li><p><strong>高级格式化&#x2F;逻辑格式化</strong></p>
<ul>
<li><p>在磁盘的特定区域写入特定数据，以达到初始化磁盘或磁盘分区、清除原磁盘或磁盘分区中所有文件的一个操作</p>
<ul>
<li><p><strong>快速格式化</strong>：会删除目标磁盘上原有的<strong>文件分配表和根目录</strong>，不检测坏道，</p>
<p>不备份数据，它格式化的速度很快，但不是很稳定。</p>
</li>
<li><p><strong>一般&#x2F;完全格式化</strong>：会清除目标磁盘上的所有的数据。重新生成引导信息、初始化文件分配表、标注逻辑坏道，一样不备份数据。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="IO访问时间"><a href="#IO访问时间" class="headerlink" title="IO访问时间"></a>IO访问时间</h2><ul>
<li>寻道时间：<ul>
<li>磁头定位到所需移动到的磁道所花费的时间。<ul>
<li>初始启动时间:跨越若干磁道所用的时间</li>
</ul>
</li>
</ul>
</li>
<li>旋转延迟<ul>
<li>等待响应扇区的起始处到达磁头所需的时间</li>
<li>通常是磁道旋转半周所需的时间1&#x2F;2r</li>
</ul>
</li>
<li>传送时间<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221130083624412.png"></li>
</ul>
</li>
</ul>
<p>T &#x3D; 秒&#x2F;每转 * 圈数b&#x2F;N</p>
<ul>
<li><p>平均访问时间</p>
<ul>
<li><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221130083839385.png"><span class="image-caption">image-20221130083839385</span></p>
</li>
<li><p>对于每个磁道都需要考虑旋转延迟</p>
</li>
<li><p><strong>通常</strong>只需要考虑第一个磁道的寻道时间，但在明确知道跨越每个磁道</p>
<p>需要的时间时需要考虑</p>
</li>
</ul>
</li>
<li><p>1 &#x2F;(15000rpm) &#x3D; 4ms</p>
<ul>
<li>rpm &#x3D; 转 每60s</li>
</ul>
</li>
</ul>
<h2 id="磁头寻道算法"><a href="#磁头寻道算法" class="headerlink" title="磁头寻道算法"></a>磁头寻道算法</h2><p>• 目标：<strong>当有 多个访问磁盘任务 时，使得 平均寻道时间最小</strong></p>
<p>• 常见的磁头寻道&#x2F;磁盘<strong>调度算法</strong></p>
<p>​	• 先来先服务（First Come First Service，FCFS）</p>
<p>​	• 最短寻道时间优先（Shortest Seek Time First，SSTF）</p>
<p>​	• 扫描&#x2F;电梯（SCAN）</p>
<p>​	• 循环扫描（C-SCAN）</p>
<p>​	• LOOK</p>
<p>​	• C-LOOK</p>
<h3 id="先来先服务（FCFS"><a href="#先来先服务（FCFS" class="headerlink" title="先来先服务（FCFS)"></a>先来先服务（FCFS)</h3><ul>
<li><p><strong>按照请求访问磁盘的先后次序进行处理</strong></p>
</li>
<li><p><strong>优点：</strong>公平简单</p>
</li>
<li><p><strong>缺点：</strong>如果有大量访问磁盘的任务，且请求<strong>访问的磁道很分散，则性</strong></p>
<p><strong>能上很差</strong>，寻道时间长</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221130153724164.png"><span class="image-caption">image-20221130153724164</span></p>
</li>
</ul>
<h3 id="最短寻道时间优先（-SSTF-）"><a href="#最短寻道时间优先（-SSTF-）" class="headerlink" title="最短寻道时间优先（ SSTF ）"></a><strong>最短寻道时间优先（</strong> <strong>SSTF</strong> <strong>）</strong></h3><ul>
<li>优先处理起始位置<strong>与当前磁头位置最接近</strong>的读写任务<ul>
<li><strong>优点</strong>：每次的寻道时间最短（局部最优），平均寻道时间缩短</li>
<li><strong>缺点</strong>：可能产生<strong>饥饿现象</strong>，尤其是位于两端的磁道请求</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221130153804668.png"><span class="image-caption">image-20221130153804668</span></li>
</ul>
</li>
</ul>
<h3 id="扫描-x2F-电梯（SCAN）"><a href="#扫描-x2F-电梯（SCAN）" class="headerlink" title="扫描&#x2F;电梯（SCAN）"></a>扫描&#x2F;电梯（SCAN）</h3><ul>
<li><p><strong>总是按照一个方向进行磁盘调度，直到该方向上的边缘，然后改变方向</strong></p>
<ul>
<li>优点：<strong>性能较好，平均寻道时间短，不会产生饥饿现象</strong></li>
<li>缺点：只有到最边上的磁道才能改变磁头的移动方向，对于各个位置磁</li>
</ul>
<p>道<strong>响应频率不平均</strong></p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221130154209832.png"><span class="image-caption">image-20221130154209832</span></p>
</li>
</ul>
<h3 id="循环扫描（-C-SCAN-）"><a href="#循环扫描（-C-SCAN-）" class="headerlink" title="循环扫描（ C-SCAN ）"></a><strong>循环扫描（</strong> <strong>C-SCAN</strong> <strong>）</strong></h3><ul>
<li><strong>只有磁头朝某个方向移动时才会响应请求，移动到边缘后立即让磁头返</strong> <strong>回起点，返回途中不做任何处理</strong><ul>
<li>优点：<strong>与SCAN算法相比，对于各位置磁道的响应频率平均</strong></li>
<li>缺点：与SCAN算法相比，平均寻道时间更长</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221130154312152.png"><span class="image-caption">image-20221130154312152</span></li>
</ul>
</li>
</ul>
<h3 id="LOOK算法"><a href="#LOOK算法" class="headerlink" title="LOOK算法"></a>LOOK算法</h3><ul>
<li><strong>SCAN算法的升级</strong>，只要磁头移动方向上不再有请求就<strong>立即改变磁头的方向</strong></li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221130154533757.png"><span class="image-caption">image-20221130154533757</span></li>
</ul>
<h2 id="C-LOOK算法"><a href="#C-LOOK算法" class="headerlink" title="C-LOOK算法"></a>C-LOOK算法</h2><ul>
<li><strong>C-SCAN算法的改进</strong>，只要在磁头移动方向上不再有请求，就立即让磁头返回起点</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221130154604440.png"><span class="image-caption">image-20221130154604440</span></li>
</ul>
<h1 id="光储存器"><a href="#光储存器" class="headerlink" title="光储存器"></a>光储存器</h1><ul>
<li><p>类型</p>
<ul>
<li><p>光盘（Compact disk CD）</p>
</li>
<li><p>光盘只读存储器（CD read-only memory，CD-ROM）</p>
</li>
<li><p>可刻录光盘（CD recordable，CD-R）</p>
</li>
<li><p>可重写光盘（CD rewritable，CD-RW）</p>
</li>
<li><p>数字多功能光盘（digital versatile disk，DVD）</p>
</li>
<li><p>可刻录DVD（DVD recordable，DVD-R）</p>
<p>• 可重写DVD（DVD rewritable，DVD-RW）</p>
<p>• 高清晰视频光盘（High definition video disk，Blu-Ray DVD）</p>
</li>
</ul>
</li>
</ul>
<h3 id="CD和CD-ROM"><a href="#CD和CD-ROM" class="headerlink" title="CD和CD-ROM"></a>CD和CD-ROM</h3><p>CD-ROM更加耐用且有纠错功能</p>
<ul>
<li>制作过程<ul>
<li>用精密聚焦的高强度激光束制造一个母盘</li>
<li>以母盘作为模板压印出<strong>聚碳酸酯的复制品</strong></li>
<li>在<strong>凹坑</strong>表面上镀上一层高反射材料</li>
<li>使用<strong>丙烯酸树脂</strong>保护高反射材料</li>
<li>在丙烯酸树脂层上用<strong>丝网印刷术印制个性化标签</strong></li>
</ul>
</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221110163431534.png"><span class="image-caption">image-20221110163431534</span></p>
<ul>
<li><p>读取</p>
<ul>
<li><p>通过安装在光盘播放器或驱动装置内的<strong>低强度激光束</strong>从CD或CD-ROM处读</p>
<p>取信息</p>
<ul>
<li><p>如果激光束照在<strong>凹坑（pit）</strong>上，由于凹坑表面有些不平，因此光被散</p>
<p>射，反射回<strong>低强度</strong>的激光</p>
<p>如果激光束照在<strong>台（land）</strong>上，台的表面光滑平坦，反射回来的是高</p>
<p>强度的<strong>激光</strong></p>
</li>
</ul>
</li>
<li><p>盘片上包含一条<strong>单螺旋</strong>的轨道，轨道上<strong>所有扇区长度相同</strong></p>
<ul>
<li>轨道由内向外转，角速度变小</li>
<li>凹坑被激光以<strong>恒定线速度</strong>读出（扇区长度相同）</li>
</ul>
</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>大规模廉价复制</li>
<li>光盘可更换</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>只读的不可更改</li>
<li>存取时间比磁盘长的多</li>
</ul>
</li>
</ul>
<h3 id="CD-R和CD-RW"><a href="#CD-R和CD-RW" class="headerlink" title="CD-R和CD-RW"></a>CD-R和CD-RW</h3><p>反射率可改变</p>
<p>材料老化最终会永久失去相位可变的特性，当前的材料可用于50万次到100万次的擦除  </p>
<h3 id="DVD"><a href="#DVD" class="headerlink" title="DVD"></a>DVD</h3><p>组装更紧密</p>
<p>有多层结构，有半反射层， 可<strong>调整焦距</strong>读取每一层</p>
<p>DVD-ROM 可以用两面记录数据  </p>
<h3 id="高清晰光盘"><a href="#高清晰光盘" class="headerlink" title="高清晰光盘"></a>高清晰光盘</h3><ul>
<li>使用更短波长的激光（在蓝-紫光范围），可以实现更高的位密度（数据凹坑相对更小）</li>
<li>和衍射公式相关</li>
</ul>
<h3 id="磁带"><a href="#磁带" class="headerlink" title="磁带"></a>磁带</h3><p>和磁盘类似的记录和读取技术</p>
<ul>
<li><strong>记录</strong><ul>
<li>介质是柔韧的<strong>聚酯薄膜带</strong>，外涂磁性材料</li>
</ul>
</li>
<li><strong>读取</strong><ul>
<li>磁带：<strong>顺序读取</strong>（sequential-access）</li>
<li>磁盘：<strong>直接读取</strong>（direct-access）(能寻道)</li>
<li>并行记录 （图b）vs. 串行记录（蛇形记录图a）</li>
</ul>
</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221110170609076.png"><span class="image-caption">image-20221110170609076</span></p>
<h3 id="U盘和固态硬盘"><a href="#U盘和固态硬盘" class="headerlink" title="U盘和固态硬盘"></a>U盘和固态硬盘</h3><ul>
<li>U盘<ul>
<li>采用了<strong>快闪存储器</strong>，属于非易失性半导体存储器</li>
<li>相比于软盘和光盘：体积小，容量大，携带方便，寿命长达数年</li>
</ul>
</li>
<li>固态硬盘<ul>
<li>与U盘没有本质区别：容量更大，存储性能更好</li>
<li>与硬磁盘存储器相比：抗振性好，无噪声，能耗低，发热量低</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-树-学习笔记</title>
    <url>/2023/01/10/algorithm-Lecture%204%20Tree/</url>
    <content><![CDATA[<p>部分树算法学习</p>
<span id="more"></span>

<h1 id="Lecture-4-Tree"><a href="#Lecture-4-Tree" class="headerlink" title="Lecture 4 Tree"></a>Lecture 4 Tree</h1><h1 id="1-Tree-树"><a href="#1-Tree-树" class="headerlink" title="1. Tree 树"></a>1. Tree 树</h1><ol>
<li>定义: A tree T is a collection of nodes(element). 树T是结点的集合</li>
<li>The collection can be empty; otherwise, a tree consists of a  distinguished node r, called the root, and zero or more  nonempty(sub)trees T1, T2, ……, Tk(这个集合可能为空，否则这个树是由一个特殊的根节点和0个或多个子树组成)</li>
</ol>
<h2 id="1-1-树的一些定义"><a href="#1-1-树的一些定义" class="headerlink" title="1.1. 树的一些定义"></a>1.1. 树的一些定义</h2><ol>
<li>Degree of an elements(node) 节点的度数:有多少个子节点</li>
<li>Degree of a tree 树的度:树里面结点的最大的度数。</li>
<li>Leaf 叶节点:树里面度数为0的节点。</li>
<li>Branch <strong>分支</strong>节点:树里面度数不为0的节点。</li>
<li>Level 层:根节点的层次为0或1，节点的层次等于其父结点的层次+1</li>
<li>树的高度:所有节点的最大层次数。</li>
</ol>
<h1 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2. 二叉树"></a>2. 二叉树</h1><ol>
<li>二叉树的定义:A binary tree t is a finite (possibly empty) collection of elements.(二叉树 t 是一个有限的节点的集合)</li>
<li>二叉树的特点:<ul>
<li>二叉树的每个结点的度数为2</li>
<li>如果有子树，则子树均为二叉树，并且被称为左子树和右子树。</li>
<li>二叉树的左右子树是有区别的</li>
</ul>
</li>
</ol>
<h2 id="2-1-二叉树的应用"><a href="#2-1-二叉树的应用" class="headerlink" title="2.1. 二叉树的应用"></a>2.1. 二叉树的应用</h2><ol>
<li>运算式的计算:转化成语法树后自带括号(运算次序)</li>
</ol>
<h2 id="2-2-二叉树的性质-考前重点"><a href="#2-2-二叉树的性质-考前重点" class="headerlink" title="2.2. 二叉树的性质(考前重点)"></a>2.2. 二叉树的性质(考前重点)</h2><ol>
<li>n个结点的二叉树之间有n-1条边edges。</li>
<li>第i层的节点数最多是2^i个</li>
<li>高度为h(<strong>从0开始计</strong>)的二叉树中结点最少h+1个，最多2^(h+1)-1</li>
<li>如果一颗二叉树有n0个树叶，并且结点度数为2的节点有n2个，则n0&#x3D;n2+1个<ul>
<li>证明:设度数为1的节点为n1，则n&#x3D;n0+n1+n2</li>
<li>n &#x3D; B + 1,B为边数(<strong>总节点数 &#x3D; 边数 + 1</strong>)</li>
<li>B &#x3D; 1 * n1+ 2 * n2</li>
<li>不会证明用数学归纳法</li>
</ul>
</li>
<li>有n个结点的二叉树的高度最大为n-1，最小为log2(n+1)(<strong>向上取整</strong>)-1（对应定理3）</li>
</ol>
<h2 id="2-3-满full二叉树"><a href="#2-3-满full二叉树" class="headerlink" title="2.3. 满full二叉树"></a>2.3. 满full二叉树</h2><ol>
<li>将二叉树排满，也就是如果高度为n的树，其节点数为2n+1-1个</li>
</ol>
<h3 id="2-3-1-完全complete二叉树"><a href="#2-3-1-完全complete二叉树" class="headerlink" title="2.3.1. 完全complete二叉树"></a>2.3.1. 完全complete二叉树</h3><ol>
<li><p>定义:Suppose we number the elements in a full binary tree of height h using the number 1 through 2h+1(假设我们为一个高度为h的满二叉树进行使用1 - 2^h+1的数字进行编码)</p>
</li>
<li><p>We began at level 0 and go down to level h.Within levels the elements are numbered left to right. (我们从0层到h层，从左向右进行编码)</p>
</li>
<li><p>从上到下，从左到右进行编码</p>
</li>
<li><p>性质六: Let i, 0 &lt;&#x3D; i &lt;&#x3D; n-1,be the number  assigned to an element of a complete binary tree. The following are  true.(假设i,0&lt;&#x3D;i&lt;&#x3D;n-1，是一个确定二叉树的一个节点的编号)(手画一个试试就好)</p>
<ul>
<li><ol>
<li>if i&#x3D;0, then this element is the root of the binary tree. if  i&gt;0,then the parent of this element has been assigned the number <strong>(i-1)&#x2F;2</strong>(向下取整)(如果i&#x3D;0，则是根节点，不然其父结点的编号为 <strong>(i-1)&#x2F;2</strong>(向下取整))</li>
</ol>
</li>
<li><ol>
<li>if 2*i+1 &gt;&#x3D; n,then this element has no left child. Otherwise,its left child has been assigned the number 2*i+1.(如果2*i+1&gt;&#x3D;n，那么这个元素没有左子女，不然左子女的编号就是这个数字)</li>
</ol>
</li>
<li><ol>
<li>if 2<em>i+2&gt;&#x3D;n, then this element has no right child, Otherwise its right child has been assigned the number *<em>2</em>i+2*</em>.(如果2*i+2&gt;&#x3D;n，那么这个元素没有右子女，不然右子女的编号就是这个数字)</li>
</ol>
</li>
</ul>
</li>
<li><p>完全二叉树和满二叉树是不同的，<strong>完全二叉树的最后一层可以不全满，但是必须从左开始顺序无空缺。</strong></p>
</li>
</ol>
<h2 id="2-4-物理实现二叉树"><a href="#2-4-物理实现二叉树" class="headerlink" title="2.4. 物理实现二叉树"></a>2.4. 物理实现二叉树</h2><h3 id="2-4-1-数组实现二叉树"><a href="#2-4-1-数组实现二叉树" class="headerlink" title="2.4.1. 数组实现二叉树"></a>2.4.1. 数组实现二叉树</h3><ol>
<li>其标记为其在数组中的下标，使用数组来存储。</li>
<li>常规二叉树的数组表示的位置上一定有空的。<ul>
<li>很稀疏的二叉树会导致数组存储二叉树有大量的内存空间被浪费掉。</li>
</ul>
</li>
</ol>
<h3 id="2-4-2-链表实现二叉树"><a href="#2-4-2-链表实现二叉树" class="headerlink" title="2.4.2. 链表实现二叉树"></a>2.4.2. 链表实现二叉树</h3><ol>
<li>Linked representation( also called L-R linked storage) 也被称为L-R链表存储。</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/1.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/1.png"><span class="image-caption">img</span></a></p>
<ol>
<li>二叉树节点</li>
</ol>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">class <span class="hljs-keyword">BinaryNode </span>&#123;<br>    <span class="hljs-keyword">BinaryNode()&#123;Left=Right=0;&#125;</span><br><span class="hljs-keyword"></span>    <span class="hljs-keyword">BinaryNode(Object </span>e)<br>        &#123;element=e<span class="hljs-comment">; Left=Right=0;&#125;</span><br>    <span class="hljs-keyword">BinaryNode(Object </span>e,  <span class="hljs-keyword">BinaryNode </span>l, <span class="hljs-keyword">BinaryNode </span>r)<br>        &#123;element=e<span class="hljs-comment">;  Left=l;  Right=r; &#125;</span><br>    Object element;<br>    <span class="hljs-keyword">BinaryNode </span>left<span class="hljs-comment">;//left subtree</span><br>    <span class="hljs-keyword">BinaryNode </span>right<span class="hljs-comment">;//right subtree</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ol>
<li>二叉树</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryTree</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">BinaryTree</span>()&#123;root=<span class="hljs-number">0</span>;&#125;;<br>        ~<span class="hljs-built_in">BinaryTree</span>()&#123;&#125;;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span><br><span class="hljs-function">            </span>&#123;<span class="hljs-keyword">return</span> ((root)?<span class="hljs-literal">false</span>:<span class="hljs-literal">true</span>);&#125;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Root</span><span class="hljs-params">(T&amp; x)</span><span class="hljs-type">const</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MakeTree</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; data, BinaryTree&lt;T&gt;&amp; leftch, BinaryTree&lt;T&gt;&amp; rightch)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BreakTree</span><span class="hljs-params">(T&amp; data , BinaryTree&lt;T&gt;&amp; leftch, BinaryTree&lt;T&gt;&amp; rightch)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrder</span><span class="hljs-params">(<span class="hljs-type">void</span>(*visit)(BinaryNode&lt;T&gt;*u))</span> </span>&#123;<span class="hljs-built_in">PreOrder</span>(visit, root);&#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrder</span><span class="hljs-params">(<span class="hljs-type">void</span>(*visit)(BinaryNode&lt;T&gt;*u))</span> </span>&#123;<span class="hljs-built_in">InOrder</span>(visit, root);&#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostOrder</span> <span class="hljs-params">(<span class="hljs-type">void</span>(*visit)(BinaryNode&lt;T&gt;*u))</span> </span>&#123;<span class="hljs-built_in">PostOrder</span>(visit, root);&#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LevelOrder</span> <span class="hljs-params">(<span class="hljs-type">void</span>(*visit)(BinaryNode&lt;T&gt; *u))</span></span>;<br>    <span class="hljs-keyword">private</span>:<br>        BinaryNode&lt;T&gt;* root;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrder</span><span class="hljs-params">(<span class="hljs-type">void</span>(*visit)(BinaryNode&lt;T&gt; *u),    BinaryNode&lt;T&gt;*t)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrder</span><span class="hljs-params">(<span class="hljs-type">void</span>(*visit)(BinaryNode&lt;T&gt; *u),   BinaryNode&lt;T&gt;*t)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostOrder</span><span class="hljs-params">(<span class="hljs-type">void</span>(*visit) (BinaryNode&lt;T&gt; *u),  BinaryNode&lt;T&gt;*t)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<ol>
<li>正常二叉树操作<ul>
<li>In this class ,we employ a linked representation for binary trees.在这个class中我们使用链表来代表二叉树</li>
<li>The function visit is used as parameter to the traversal methods,so  that different operations can be implemented easily  函数visit被用作遍历方法的一个参数所以我们可以实现不同的操作更加简单</li>
</ul>
</li>
</ol>
<h3 id="2-4-3-链表具体实现方法细节"><a href="#2-4-3-链表具体实现方法细节" class="headerlink" title="2.4.3. 链表具体实现方法细节"></a>2.4.3. 链表具体实现方法细节</h3><ol>
<li>补充C++知识:<ul>
<li>Class::f()实现Class中的f()方法</li>
</ul>
</li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">BinaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">MakeTree</span>(<span class="hljs-symbol">const</span> <span class="hljs-symbol">T</span>&amp; <span class="hljs-symbol">data, <span class="hljs-symbol">BinaryTree</span></span>&lt;<span class="hljs-symbol">T</span>&gt;&amp; <span class="hljs-symbol">leftch,<span class="hljs-symbol">BinaryTree</span></span>&lt;<span class="hljs-symbol">T</span>&gt;&amp; <span class="hljs-symbol">rightch</span>)&#123;<br>    root=new BinaryNode&lt;T&gt;(data, leftch.root, rightch.root);<br>    leftch.root = rightch.root=<span class="hljs-number">0</span>;<br>&#125;<br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">BinaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">BreakTree</span>(<span class="hljs-symbol">T</span>&amp; <span class="hljs-symbol">data, <span class="hljs-symbol">BinaryTree</span></span>&lt;<span class="hljs-symbol">T</span>&gt;&amp; <span class="hljs-symbol">leftch,<span class="hljs-symbol">BinaryTree</span></span>&lt;<span class="hljs-symbol">T</span>&gt;&amp; <span class="hljs-symbol">rightch</span>)<br>&#123;<br>    <span class="hljs-keyword">if</span>(!root) throw BadInput();<span class="hljs-comment">//tree empty </span><br>    data=root.element;<br>    leftch.root=root.Left; rightch.root=root.Right;<br>    delete root;<br>    root=<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>二叉树的应用</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;binary.h&gt;</span></span><br><span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>BinaryTree&lt;<span class="hljs-type">int</span>&gt;a,x,y,z;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ct</span><span class="hljs-params">(BinaryTreeNode&lt;T&gt;*t)</span></span>&#123;count++;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    a.<span class="hljs-built_in">MakeTree</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    z.<span class="hljs-built_in">MakeTree</span>(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    x.<span class="hljs-built_in">MakeTree</span>(<span class="hljs-number">3</span>,a,z);<br>    y.<span class="hljs-built_in">MakeTree</span>(<span class="hljs-number">4</span>,x,<span class="hljs-number">0</span>);<br>    y.<span class="hljs-built_in">PreOrder</span>(ct);<br>    cout&lt;&lt;count&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-5-二叉树遍历"><a href="#2-5-二叉树遍历" class="headerlink" title="2.5. 二叉树遍历"></a>2.5. 二叉树遍历</h2><ol>
<li>以下算法中的二叉树是通过链表实现的。</li>
<li>Each element is visited exactly once<ul>
<li>V—–表示访问一个结点 vertice</li>
<li>L—–表示访问V的左子树 left tree</li>
<li>R—–表示访问V的右子树 right tree</li>
<li>所有的遍历顺序:VLR\LVR、LRV、VRL、RVL、RLV</li>
</ul>
</li>
<li>常用的遍历顺序<ul>
<li>先序遍历:VLR</li>
<li>中序遍历:LVR</li>
<li>后序遍历:LRV</li>
<li>广度优先遍历:先处理树根节点，然后处理靠近的第一层的节点</li>
</ul>
</li>
</ol>
<h3 id="2-5-1-例子"><a href="#2-5-1-例子" class="headerlink" title="2.5.1. 例子"></a>2.5.1. 例子</h3><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/2.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/2.png"><span class="image-caption">img</span></a></p>
<h3 id="2-5-2-先序遍历"><a href="#2-5-2-先序遍历" class="headerlink" title="2.5.2. 先序遍历"></a>2.5.2. 先序遍历</h3><ol>
<li>VLR</li>
</ol>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">//递归实现先序遍历</span><br>template&lt;class T&gt;<br>void <span class="hljs-built_in">PreOrder</span>(BinaryNode&lt;T&gt;* t) &#123;<br>    <span class="hljs-comment">// preorder traversal of *t.</span><br>    <span class="hljs-built_in">if</span>(t)&#123;<br>        <span class="hljs-built_in">visit</span>(t);<br>        <span class="hljs-built_in">PreOrder</span>(t-&gt;Left);<br>        <span class="hljs-built_in">PreOrder</span>(t-&gt;Right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-5-3-中序遍历"><a href="#2-5-3-中序遍历" class="headerlink" title="2.5.3. 中序遍历"></a>2.5.3. 中序遍历</h3><hr>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//递归实现中序遍历</span><br>template&lt;<span class="hljs-keyword">class</span> T&gt;<br>void <span class="hljs-constructor">InOrder(BinaryNode&lt;T&gt;<span class="hljs-operator">*</span> <span class="hljs-params">t</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t)&#123;<br>        <span class="hljs-constructor">InOrder(<span class="hljs-params">t</span>-&gt;Left)</span>;<br>        visit(t);<br>        <span class="hljs-constructor">InOrder(<span class="hljs-params">t</span>-&gt;Right)</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//非递归使用stack实现中序遍历</span><br>void <span class="hljs-constructor">Inorder(BinaryNode &lt;T&gt;<span class="hljs-operator">*</span><span class="hljs-params">t</span>)</span>&#123;  <br>    Stack&lt;BinaryNode&lt;T&gt;*&gt; s(<span class="hljs-number">10</span>);<br>    BinaryNode&lt;T&gt;*p = t;<br>    <span class="hljs-keyword">for</span> (;;)&#123;<br>        <span class="hljs-comment">//无条件进行循环</span><br>        <span class="hljs-keyword">while</span>(p!=NULL)&#123;<br>            <span class="hljs-comment">//一直进行压栈，直到最左下部分</span><br>            s.push(p);<br>            p = p-&gt;Left;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!s.<span class="hljs-constructor">IsEmpty()</span>)&#123;<br>            <span class="hljs-comment">//出栈输出，然后指向右子树，之后重复上面计算到右子树的最左边的节点。</span><br>            p = s.pop<span class="hljs-literal">()</span>;<br>            cout &lt;&lt; p-&gt;element;<br>            p = p-&gt;Right;<br>        &#125;<span class="hljs-keyword">else</span><br>            return;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-5-4-后序遍历"><a href="#2-5-4-后序遍历" class="headerlink" title="2.5.4. 后序遍历"></a>2.5.4. 后序遍历</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//递归实现后序遍历</span><br>template&lt;<span class="hljs-keyword">class</span> T&gt;<br>void <span class="hljs-constructor">InOrder(BinaryNode&lt;T&gt;<span class="hljs-operator">*</span> <span class="hljs-params">t</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t)&#123;<br>        <span class="hljs-constructor">InOrder(<span class="hljs-params">t</span>-&gt;Left)</span>;<br>        <span class="hljs-constructor">InOrder(<span class="hljs-params">t</span>-&gt;Right)</span>;<br>        visit(t);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//非递归实现后序遍历</span><br><span class="hljs-comment">//结点的实现</span><br><span class="hljs-keyword">struct</span> StkNode &#123;<br>    BinaryNode &lt;T&gt;<span class="hljs-operator"> * </span>ptr;<br>    <span class="hljs-built_in">int</span> tag;<span class="hljs-comment">//用来标记是否标记过了，第一次进栈为1，第二次进栈为2.</span><br>&#125;<br><span class="hljs-comment">//非递归实现后序遍历</span><br>void <span class="hljs-constructor">Postorder(BinaryNode &lt;T&gt; <span class="hljs-operator">*</span> <span class="hljs-params">t</span>)</span> &#123;<br>    Stack &lt;StkNode&lt;T&gt;&gt; s(<span class="hljs-number">10</span>);<br>    StkNode&lt;T&gt; Cnode;<br>    BinaryNode&lt;T&gt;*p = t;<br>    <span class="hljs-keyword">for</span>(;;) &#123;<br>        <span class="hljs-comment">//优先访问到最左下</span><br>        <span class="hljs-keyword">while</span> (p!=NULL)&#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Cnode</span>.</span></span>ptr = p;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Cnode</span>.</span></span>tag = <span class="hljs-number">0</span>;<br>            s.push(Cnode);<br>            p = p-&gt;Left;<br>        &#125;<br>        <span class="hljs-comment">//将最左下结点出栈</span><br>        Cnode = s.pop<span class="hljs-literal">()</span>;<br>        p = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Cnode</span>.</span></span>ptr;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Cnode</span>.</span></span>tag<span class="hljs-operator"> == </span><span class="hljs-number">1</span>)<span class="hljs-comment">//从右子树回来 </span><br>        &#123;<br>            <span class="hljs-comment">//如果已经被访问一次了才进行输出</span><br>            cout &lt;&lt; p-&gt;element;<br>            <span class="hljs-keyword">if</span> (!s.<span class="hljs-constructor">IsEmpty()</span>)&#123;<br>                Cnode = s.pop<span class="hljs-literal">()</span>;<br>                p = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Cnode</span>.</span></span>ptr;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//访问结束</span><br>                return;<br>            &#125;   <br>        &#125;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Cnode</span>.</span></span>tag = <span class="hljs-number">1</span>;<span class="hljs-comment">//从左子树遍历完，而右子树还没有动。</span><br>        s.push(Cnode);<br>        p = p-&gt;Right;<span class="hljs-comment">//从左子树回来</span><br>    &#125;<span class="hljs-comment">//for</span><br>&#125;      <br></code></pre></td></tr></table></figure>

<h3 id="2-5-5-广度优先遍历"><a href="#2-5-5-广度优先遍历" class="headerlink" title="2.5.5. 广度优先遍历"></a>2.5.5. 广度优先遍历</h3><ol>
<li>根据level order(树的层数)</li>
</ol>
<h2 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h2><ol>
<li>直接按顺序访问数组即可</li>
</ol>
<h2 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h2><figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss">template&lt;class T&gt; void <span class="hljs-built_in">LevelOrder</span>(BinaryNode&lt;T&gt;* t) &#123;<br>    LinkedQueue&lt;BinaryNode&lt;T&gt;*&gt; <span class="hljs-selector-tag">Q</span>;<br>    <span class="hljs-built_in">while</span>(t)&#123;<br>        <span class="hljs-built_in">visit</span>(t);<span class="hljs-comment">//visit t</span><br>        <span class="hljs-built_in">if</span>(t-&gt;Left) <span class="hljs-selector-tag">Q</span><span class="hljs-selector-class">.Add</span>(t-&gt;Left);<br>        <span class="hljs-built_in">if</span>(t-&gt;Right) <span class="hljs-selector-tag">Q</span><span class="hljs-selector-class">.Add</span>(t-&gt;Right);<br>        try&#123;<span class="hljs-selector-tag">Q</span><span class="hljs-selector-class">.Delete</span>(t);&#125;<span class="hljs-built_in">catch</span>(OutOfBounds)&#123;return;&#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//每次出队列一个数据，就会从队列中压进去之后的数组</span><br></code></pre></td></tr></table></figure>

<h2 id="2-6-建立二叉树"><a href="#2-6-建立二叉树" class="headerlink" title="2.6. 建立二叉树"></a>2.6. 建立二叉树</h2><h3 id="2-6-1-利用MakeTree函数"><a href="#2-6-1-利用MakeTree函数" class="headerlink" title="2.6.1. 利用MakeTree函数"></a>2.6.1. 利用MakeTree函数</h3><h3 id="2-6-2-利用先序、中序唯一的构造一颗二叉树"><a href="#2-6-2-利用先序、中序唯一的构造一颗二叉树" class="headerlink" title="2.6.2. 利用先序、中序唯一的构造一颗二叉树"></a>2.6.2. 利用先序、中序唯一的构造一颗二叉树</h3><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/3.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/3.png"><span class="image-caption">img</span></a></p>
<h3 id="2-6-3-利用二叉树的中序、后序遍历确定一颗二叉树"><a href="#2-6-3-利用二叉树的中序、后序遍历确定一颗二叉树" class="headerlink" title="2.6.3. 利用二叉树的中序、后序遍历确定一颗二叉树"></a>2.6.3. 利用二叉树的中序、后序遍历确定一颗二叉树</h3><p>后序的最后是根节点，根据中序进行划分</p>
<h3 id="2-6-4-利用二叉树的广义表来构造一颗二叉树"><a href="#2-6-4-利用二叉树的广义表来构造一颗二叉树" class="headerlink" title="2.6.4. 利用二叉树的广义表来构造一颗二叉树"></a>2.6.4. 利用二叉树的广义表来构造一颗二叉树</h3><h3 id="2-6-5-利用二叉树的后缀表示来构造一颗二叉树"><a href="#2-6-5-利用二叉树的后缀表示来构造一颗二叉树" class="headerlink" title="2.6.5. 利用二叉树的后缀表示来构造一颗二叉树"></a>2.6.5. 利用二叉树的后缀表示来构造一颗二叉树</h3><h3 id="2-6-6-利用二叉树的后缀表示来构造一颗二叉树"><a href="#2-6-6-利用二叉树的后缀表示来构造一颗二叉树" class="headerlink" title="2.6.6. 利用二叉树的后缀表示来构造一颗二叉树"></a>2.6.6. 利用二叉树的后缀表示来构造一颗二叉树</h3><h1 id="3-精讲-利用先序、中序唯一的构造一颗二叉树-string"><a href="#3-精讲-利用先序、中序唯一的构造一颗二叉树-string" class="headerlink" title="3. 精讲:利用先序、中序唯一的构造一颗二叉树(string)"></a>3. 精讲:利用先序、中序唯一的构造一颗二叉树(string)</h1><ol>
<li>字符串(简称串)的定义以及一些术语<ul>
<li>串：是n(n&gt;&#x3D;0)个字符的一个有限序列，开头结尾用双引号””括起来。</li>
<li>串的长度：串中所包含的字符个数n(不包括分界符‘ “ ’，也不包括串的结束符‘\0’)</li>
<li>空串：长度为0的串。或者说只包含串结束符‘\0’的串，空串不等同于空白串。</li>
<li>子串：串中任一连续子序列</li>
</ul>
</li>
</ol>
<h2 id="3-1-其他的二叉树的方法"><a href="#3-1-其他的二叉树的方法" class="headerlink" title="3.1. 其他的二叉树的方法"></a>3.1. 其他的二叉树的方法</h2><ol>
<li>PreOutput():output the data fields in preorder</li>
<li>InOutput():output the data fields in inorder</li>
<li>PostOutput():output the data fields in postorder</li>
<li>LevelOutput():output the data fields in level order</li>
<li>Delete():delete a binary tree,freeing up its nodes</li>
<li>Height():return the tree height</li>
<li>Size():return the number of nodes in the tree</li>
<li>The height of the tree is determined as: max{hl, hr}+1</li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//计算二叉树的高度</span><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T</span>&gt; <span class="hljs-symbol">int</span> <span class="hljs-symbol">BinaryTree</span>&lt;<span class="hljs-symbol">T</span>&gt;::<span class="hljs-symbol">Height</span>(<span class="hljs-symbol">BinaryNode</span>&lt;<span class="hljs-symbol">T</span>&gt; *<span class="hljs-symbol">t</span>)<span class="hljs-symbol">const</span> &#123;<br>    <span class="hljs-keyword">if</span>(!t) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span> hl=Height(t-&gt;Left);<br>    <span class="hljs-built_in">int</span> hr=Height(t-&gt;Right);<br>    <span class="hljs-comment">//选择高的一颗树，将其高度增加</span><br>    <span class="hljs-keyword">if</span>(hl&gt;hr) <span class="hljs-keyword">return</span> ++ hl;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> ++hr; &#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-2-String"><a href="#3-2-String" class="headerlink" title="3.2. String"></a>3.2. String</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxlen=<span class="hljs-number">128</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">String</span> &amp; ob);<br>        <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * init);<br>        <span class="hljs-built_in">String</span>( );<br>        ~<span class="hljs-built_in">String</span>( ) &#123;<span class="hljs-keyword">delete</span>[ ] ch;&#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Length</span><span class="hljs-params">( )</span><span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> curlen;&#125;<br>        <span class="hljs-function"><span class="hljs-type">String</span> &amp; <span class="hljs-title">operator</span><span class="hljs-params">( )</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> len)</span></span>;<span class="hljs-comment">//取子串</span><br>        <span class="hljs-type">int</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-type">const</span> <span class="hljs-type">String</span> &amp; ob) <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(ch, ob.ch)= =<span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-comment">//判别相等否？</span><br>        <span class="hljs-type">int</span> <span class="hljs-keyword">operator</span> !=(<span class="hljs-type">const</span> <span class="hljs-type">String</span> &amp;ob) <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(ch, ob.ch)!=<span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-keyword">operator</span> ! () <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">return</span> curlen= =<span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">String</span> &amp; <span class="hljs-keyword">operator</span> = (<span class="hljs-type">const</span> <span class="hljs-type">String</span> &amp; ob);<span class="hljs-comment">//串赋值</span><br>        <span class="hljs-type">String</span> &amp; <span class="hljs-keyword">operator</span> +=(<span class="hljs-type">const</span> <span class="hljs-type">String</span> &amp; ob);<span class="hljs-comment">//并置运算</span><br>        <span class="hljs-type">char</span> &amp; <span class="hljs-keyword">operator</span>[ ](<span class="hljs-type">int</span> i);<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">String</span> pat)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> curLen;<br>        <span class="hljs-type">char</span> * ch;<br>&#125;  <br></code></pre></td></tr></table></figure>

<h2 id="3-3-String部分方法的实现"><a href="#3-3-String部分方法的实现" class="headerlink" title="3.3. String部分方法的实现"></a>3.3. String部分方法的实现</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//重载括号</span><br><span class="hljs-function"><span class="hljs-type">String</span> &amp; <span class="hljs-title">String::operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span>  pos, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>    <span class="hljs-type">String</span> *temp=<span class="hljs-keyword">new</span> <span class="hljs-type">String</span>;<br>    <span class="hljs-keyword">if</span> (pos&lt;<span class="hljs-number">0</span> || pos+len<span class="hljs-number">-1</span> &gt;= maxlen ||len&lt;<span class="hljs-number">0</span>) &#123; <br>        temp-&gt;curLen=<span class="hljs-number">0</span>;<br>        temp-&gt;ch[<span class="hljs-number">0</span>]=<span class="hljs-string">&quot;\0&quot;</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span> (pos+len<span class="hljs-number">-1</span>&gt;=curLen)<br>            len=curLen-pos;<br>        temp-&gt;curLen=len;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>, j=pos; i&lt;len; i++, j++)<br>            temp-&gt;ch[i] = ch[j];<br>        temp-&gt;ch[len]=‗<span class="hljs-string">&#x27;\0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> *temp;<br>&#125;<br><span class="hljs-type">String</span> &amp; <span class="hljs-type">String</span> ::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> <span class="hljs-type">String</span> &amp;ob) &#123;<br>    <span class="hljs-keyword">if</span> (&amp;ob!=<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-keyword">delete</span> [ ] ch;<br>        ch=<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[maxLen+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(!ch)&#123;<br>            cerr&lt;&lt; <span class="hljs-string">&quot;Out Of Memory! \n&quot;</span>‖;<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        curLen=ob.curLen;<br>        <span class="hljs-built_in">strcpy</span>(ch, ob.ch); <br>    &#125;<span class="hljs-keyword">else</span><br>        cout&lt;&lt;<span class="hljs-string">&quot;Attempted assignment of a String to itself! \n&quot;</span>;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-4-根据先序遍历和中序遍历生成二叉树的思路"><a href="#3-4-根据先序遍历和中序遍历生成二叉树的思路" class="headerlink" title="3.4. 根据先序遍历和中序遍历生成二叉树的思路"></a>3.4. 根据先序遍历和中序遍历生成二叉树的思路</h2><ol>
<li>先序遍历的第一个一定是树根，然后在中序遍历中找树根，然后在中序中树根左边是左子树，右边是右子树</li>
</ol>
<h2 id="3-5-C-实现"><a href="#3-5-C-实现" class="headerlink" title="3.5. C++实现"></a>3.5. C++实现</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">//是一个递归算法<br>BinaryNode&lt;<span class="hljs-keyword">Type</span>&gt;*<span class="hljs-type">void</span> CreateBT (String pres, ins) &#123;<br>    <span class="hljs-type">int</span> inpos;<br>    BinaryNode &lt;<span class="hljs-keyword">Type</span>&gt;* <span class="hljs-keyword">temp</span>;//当前二叉树的节点<br>    String prestemp, instemp;<br>    <span class="hljs-keyword">if</span> (pres.length()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">NULL</span>;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">temp</span> = <span class="hljs-built_in">new</span> BinaryNode; <br>        <span class="hljs-keyword">temp</span>-&gt;element=pres.ch[<span class="hljs-number">0</span>];<br>        inpos=<span class="hljs-number">0</span>;<br>        //从中序遍历中找到根节点的位置，这样子根节点左侧的是左子树，右侧的是右子树<br>        <span class="hljs-keyword">while</span> (ins.ch[inpos]!=<span class="hljs-keyword">temp</span>-&gt;element) <br>            inpos++;<br>        <br>        prestemp = pres(<span class="hljs-number">1</span>,inpos);//小括号是重载的，将先序遍历字符串的<span class="hljs-number">1</span>到inpos取出来，赋给中间变量<br>        instemp= ins(<span class="hljs-number">0</span>,inpos<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">temp</span>-&gt;left = CreateBT(prestemp, instemp);<br>        <br>        prestemp=pres(inpos+<span class="hljs-number">1</span>, pres.length()<span class="hljs-number">-1</span>);<br>        instemp=ins(inpos+<span class="hljs-number">1</span>, pres.length()<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">temp</span>-&gt;right = CreateBT(prestemp, instemp);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">temp</span>;//完成组装返回<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-6-已知其他的遍历顺序来生成二叉树"><a href="#3-6-已知其他的遍历顺序来生成二叉树" class="headerlink" title="3.6. 已知其他的遍历顺序来生成二叉树"></a>3.6. 已知其他的遍历顺序来生成二叉树</h2><h3 id="3-6-1-已知后序遍历和中序遍历"><a href="#3-6-1-已知后序遍历和中序遍历" class="headerlink" title="3.6.1. 已知后序遍历和中序遍历"></a>3.6.1. 已知后序遍历和中序遍历</h3><ol>
<li>先序遍历的树根在头部，而后序遍历串的树根在尾部。</li>
</ol>
<h3 id="3-6-2-已知先序遍历和后续遍历串"><a href="#3-6-2-已知先序遍历和后续遍历串" class="headerlink" title="3.6.2. 已知先序遍历和后续遍历串"></a>3.6.2. 已知先序遍历和后续遍历串</h3><ol>
<li>先序遍历串的第二个位置是左子树(左右子树分界点)，然后我们和后序遍历串结合。</li>
</ol>
<h2 id="3-7-二叉树的应用"><a href="#3-7-二叉树的应用" class="headerlink" title="3.7. 二叉树的应用"></a>3.7. 二叉树的应用</h2><h3 id="3-7-1-二叉树的表示方式"><a href="#3-7-1-二叉树的表示方式" class="headerlink" title="3.7.1. 二叉树的表示方式"></a>3.7.1. 二叉树的表示方式</h3><ol>
<li>Binary-Tree Representation of a Tree 树的存储方式：三种<ul>
<li>广义表表示：a(b(f,g),c,d(h,i,j),e)</li>
<li>双亲表示法；记下自己的父结点位置，问题是:找子节点需要遍历一遍。</li>
<li>左子女—右兄弟表示法</li>
</ul>
</li>
</ol>
<p>!(img&#x2F;cpt5&#x2F;4.png)</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">//左子女——右兄弟表示法</span><br>class TreeNode:<br>    T <span class="hljs-keyword">data</span>;<br>    TreeNode *firstchild, *nextsibling;<br><br>class Tree:<br>    TreeNode * root,  *current;<br><br>template &lt;class T&gt; void Tree &lt;T&gt;::Insertchild(T value) &#123;<br>    TreeNode&lt;T&gt;*newnode = new TreeNode&lt;T&gt;(value);<br>    <span class="hljs-function"><span class="hljs-title">if</span>(current-&gt;</span>firstchild == NULL) <br>        <span class="hljs-function"><span class="hljs-title">current</span>-&gt;</span>firstchild = newnode;<br>    <span class="hljs-keyword">else</span> &#123;<br>        T<span class="hljs-function"><span class="hljs-title">reeNode</span>&lt;T&gt;*p = current-&gt;</span>firstchild;<br>        <span class="hljs-function"><span class="hljs-title">while</span> ( p-&gt;</span>nextsibling!=NULL)<br>            <span class="hljs-function"><span class="hljs-title">p</span> = p-&gt;</span>nextsibling;<br>        <span class="hljs-function"><span class="hljs-title">p</span>-&gt;</span>nextsibling = newnode;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>

<h3 id="3-7-2-将森林转换成二叉树"><a href="#3-7-2-将森林转换成二叉树" class="headerlink" title="3.7.2. 将森林转换成二叉树"></a>3.7.2. 将森林转换成二叉树</h3><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/5.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/5.png"><span class="image-caption">img</span></a><br> <a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/6.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/6.png"><span class="image-caption">img</span></a><br> <a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/7.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/7.png"><span class="image-caption">img</span></a></p>
<h2 id="3-8-树的遍历"><a href="#3-8-树的遍历" class="headerlink" title="3.8. 树的遍历"></a>3.8. 树的遍历</h2><h3 id="3-8-1-深度优先遍历-DFS"><a href="#3-8-1-深度优先遍历-DFS" class="headerlink" title="3.8.1. 深度优先遍历(DFS)"></a>3.8.1. 深度优先遍历(DFS)</h3><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/8.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/8.png"><span class="image-caption">img</span></a></p>
<h3 id="3-8-2-广度优先遍历"><a href="#3-8-2-广度优先遍历" class="headerlink" title="3.8.2. 广度优先遍历"></a>3.8.2. 广度优先遍历</h3><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/9.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/9.png"><span class="image-caption">img</span></a></p>
<h2 id="3-9-森林的遍历"><a href="#3-9-森林的遍历" class="headerlink" title="3.9. 森林的遍历"></a>3.9. 森林的遍历</h2><ol>
<li>应用左子女-右兄弟的二叉树进行遍历</li>
</ol>
<h3 id="3-9-1-深度优先遍历"><a href="#3-9-1-深度优先遍历" class="headerlink" title="3.9.1. 深度优先遍历"></a>3.9.1. 深度优先遍历</h3><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/10.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/10.png"><span class="image-caption">img</span></a></p>
<ol>
<li>Eg.</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/11.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/11.png"><span class="image-caption">img</span></a></p>
<ol>
<li>生成左子女-右兄弟二叉树后正常遍历即可</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/12.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/12.png"><span class="image-caption">img</span></a></p>
<h1 id="4-线索二叉树"><a href="#4-线索二叉树" class="headerlink" title="4. 线索二叉树"></a>4. 线索二叉树</h1><ol>
<li>目的:让二叉树遍历的速度更快</li>
<li>特点:在树的节点中加入一个指针(比如指向下一个节点)</li>
<li>n个结点的二叉树有2n个链域，其中真正有用的是n–1个，其它n+1个都是空域(null)。为了充分利用结点中的空域，使得对某些运算更快，如前驱或后继等运算。</li>
</ol>
<h2 id="4-1-例子"><a href="#4-1-例子" class="headerlink" title="4.1. 例子"></a>4.1. 例子</h2><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/13.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/13.png"><span class="image-caption">img</span></a></p>
<ol>
<li>虚线是本身被置为NULL的部分</li>
<li>使用左指针指向中序遍历前项，使用右指针指向中序遍历的后项。<ul>
<li>唯二空指针:最左边节点的左指针，最右边节点的右指针</li>
</ul>
</li>
<li>整个树只会有两个空指针</li>
</ol>
<h2 id="4-2-线索二叉树的结点的数据结构"><a href="#4-2-线索二叉树的结点的数据结构" class="headerlink" title="4.2. 线索二叉树的结点的数据结构"></a>4.2. 线索二叉树的结点的数据结构</h2><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/14.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/14.png"><span class="image-caption">img</span></a></p>
<h2 id="4-3-线索二叉树类的实现"><a href="#4-3-线索二叉树类的实现" class="headerlink" title="4.3. 线索二叉树类的实现"></a>4.3. 线索二叉树类的实现</h2><figure class="highlight fortran"><table><tr><td class="code"><pre><code class="hljs fortran">template&lt; <span class="hljs-keyword">class</span> <span class="hljs-keyword">Type</span>&gt; <span class="hljs-keyword">class</span> ThreadNode &#123;<br>    friend <span class="hljs-keyword">class</span> ThreadTree;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-built_in">int</span> leftThread, rightThread; <br>        ThreadNode&lt;<span class="hljs-keyword">Type</span>&gt;* leftchild, *rightchild;<br>        <span class="hljs-keyword">Type</span> <span class="hljs-keyword">data</span>;<br>    <span class="hljs-keyword">public</span>:<br>        ThreadNode(const <span class="hljs-keyword">Type</span> item):<span class="hljs-keyword">data</span>(item), leftchild(<span class="hljs-number">0</span>), rihgtchild(<span class="hljs-number">0</span>), leftThread(<span class="hljs-number">0</span>), rightThread(<span class="hljs-number">0</span>) &#123;&#125;//<span class="hljs-keyword">data</span>初始化为item...<br>&#125;;<br><br>template&lt; <span class="hljs-keyword">class</span> <span class="hljs-keyword">Type</span>&gt; <span class="hljs-keyword">class</span> ThreadTree &#123; <br>    <span class="hljs-keyword">public</span>:<br>        //线索二叉树的公共操作<br>    <span class="hljs-keyword">private</span>:<br>        ThreadNode&lt;<span class="hljs-keyword">Type</span>&gt; * root; <br>        ThreadNode&lt;<span class="hljs-keyword">Type</span>&gt; *current<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="4-4-中序遍历已有的中序线索二叉树"><a href="#4-4-中序遍历已有的中序线索二叉树" class="headerlink" title="4.4. 中序遍历已有的中序线索二叉树"></a>4.4. 中序遍历已有的中序线索二叉树</h2><ol>
<li>按中序遍历中序线索树<ul>
<li>遍历算法(以中序为例)：<ul>
<li>递归， 非递归(需用工作栈)</li>
</ul>
</li>
<li>这里前提是中序线索树， 所以既不要递归， 也不要栈。</li>
<li>遍历算法：<ul>
<li>找到中序下的第一个结点(first)</li>
<li>不断找后继(Next)</li>
</ul>
</li>
<li>如何找后继？</li>
</ul>
</li>
<li>情况一:如果p结点没有右子树(p-&gt;rightthread &#x3D;&#x3D; 1)则 p&#x3D;p-&gt;rightchild(右链就是后继)</li>
<li>p有右子树(p-&gt;rightThread&#x3D;&#x3D;0) 则<ol>
<li>p&#x3D;p-&gt;rightchild</li>
<li>while(p-&gt;leftThread&#x3D;&#x3D;0) p&#x3D;p-&gt;leftchild;</li>
</ol>
</li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//使用是current来记录下来当前节点</span><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">Type</span>&gt; <span class="hljs-symbol">ThreadNode</span>&lt;<span class="hljs-symbol">Type</span>&gt;* <span class="hljs-symbol">ThreadInorderIterator</span>&lt;<span class="hljs-symbol">Type</span>&gt;::<span class="hljs-symbol">First</span>() &#123;<br>    <span class="hljs-keyword">while</span> (current-&gt;leftThread==<span class="hljs-number">0</span>)&#123;<br>        current = current-&gt;leftchild;<br>    &#125;<br>    <span class="hljs-keyword">return</span> current;<span class="hljs-comment">//找中序遍历的第一个节点</span><br>&#125;<br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">Type</span>&gt; <span class="hljs-symbol">ThreadNode</span>&lt;<span class="hljs-symbol">Type</span>&gt;* <span class="hljs-symbol">ThreadInorderIterator</span>&lt;<span class="hljs-symbol">Type</span>&gt;::<span class="hljs-symbol">Next</span>() &#123;<br>    ThreadNode&lt;Type&gt;*p = current-&gt;rightchild;<span class="hljs-comment">//可能是右子树的根节点，也可能是右链 </span><br>    <span class="hljs-keyword">if</span>(current-&gt;rightThread==<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">while</span>(p-&gt;leftThread==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//如果有右子树就要搜索到最左下部分</span><br>            p=p-&gt;leftchlid;<br>        &#125;<br>    current=p;<br>&#125;<br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">Type</span>&gt; <span class="hljs-symbol">void</span> <span class="hljs-symbol">ThreadInorderIterator</span>&lt;<span class="hljs-symbol">Type</span>&gt;:: <span class="hljs-symbol">Inorder</span>() &#123; <br>    ThreadNode&lt;Type&gt; *p;<br>    <span class="hljs-keyword">for</span> ( p=Frist(); p!=NULL; p=Next()) <br>        cout&lt;&lt; p-&gt;data &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-5-建立中序线索二叉树"><a href="#4-5-建立中序线索二叉树" class="headerlink" title="4.5. 建立中序线索二叉树"></a>4.5. 建立中序线索二叉树</h2><ol>
<li>对已存在的一棵二叉树建立中序线索树</li>
<li>分析：与中序遍历算法差不多，但是要填左空域，右空域的前驱、后继指针。所以除了流动指针p外，还要加一个pre指针，它总是指向遍历指针p的中序下的前驱结点。<ul>
<li>pre相当于记录下来整个遍历顺序来完成链接</li>
</ul>
</li>
<li>Eg.</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/15.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/15.png"><span class="image-caption">img</span></a></p>
<figure class="highlight xl"><table><tr><td class="code"><pre><code class="hljs xl">Void Inthread(threadNode&lt;T&gt; * T) &#123;<br>    stack &lt;threadNode &lt;T&gt;*&gt; s(<span class="hljs-number">10</span>)<br>    ThreadNode &lt;T&gt; *p = T ;<br>    ThreadNode &lt;T&gt; *pre = NULL;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">//查找到最左下部分的</span><br>        <span class="hljs-keyword">while</span> (p!=NULL) &#123;<br>            s.push(p);<br>            <span class="hljs-function"><span class="hljs-title">p</span> = p -&gt;</span>leftchild;<br>        &#125;<br>        <span class="hljs-comment">//开始弹出栈</span><br>        <span class="hljs-keyword">if</span> (!s.IsEmpty())&#123;<br>            p = s.pop;<br>            <span class="hljs-keyword">if</span> (pre != NULL) &#123;<br>                <span class="hljs-comment">//添加的代码，在这时候处理pre</span><br>                <span class="hljs-function"><span class="hljs-title">if</span> (pre -&gt;</span>rightchild == NULL)&#123;<br>                    <span class="hljs-function"><span class="hljs-title">pre</span> -&gt;</span>rightchild = p;  <br>                    <span class="hljs-function"><span class="hljs-title">pre</span> -&gt;</span>rightthread = <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-comment">//处理p</span><br>                <span class="hljs-function"><span class="hljs-title">if</span>( p -&gt;</span> leftchild == NULL) &#123;<br>                    <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> leftchild = pre;<br>                    <span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span>leftthread = <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-comment">//添加的代码</span><br>            &#125;<br>            pre = p ;<br>            <span class="hljs-function"><span class="hljs-title">p</span> = p -&gt;</span> rightchild ;<br>        &#125;<br>        <span class="hljs-keyword">else</span> return;<br>    &#125;<span class="hljs-comment">//for </span><br>&#125;<span class="hljs-comment">//建议把pre和p存储成全局变量</span><br></code></pre></td></tr></table></figure>

<h1 id="5-树的应用"><a href="#5-树的应用" class="headerlink" title="5. 树的应用"></a>5. 树的应用</h1><h2 id="5-1-哈夫曼树-Huffman-Tree"><a href="#5-1-哈夫曼树-Huffman-Tree" class="headerlink" title="5.1. 哈夫曼树(Huffman Tree)"></a>5.1. 哈夫曼树(Huffman Tree)</h2><h3 id="5-1-1-一些概念"><a href="#5-1-1-一些概念" class="headerlink" title="5.1.1. 一些概念"></a>5.1.1. 一些概念</h3><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/16.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/16.png"><span class="image-caption">img</span></a></p>
<ol>
<li><p>增长树(使得原来的树的每一个度数都为2)</p>
<ul>
<li>对原二叉树中度为1的结点，增加一个空树叶</li>
<li>对原二叉树中的树叶，增加两个空树叶</li>
</ul>
</li>
<li><p>外通路长度(外路径)E </p>
<p>根到每个外结点</p>
<p>(增长树的叶子)的路径长度的总和(边数)</p>
<ul>
<li>E &#x3D; 3+3+2+3+4+4+3+3&#x3D;25，如右上图例</li>
</ul>
</li>
<li><p>内通路长度(内路径)I：</p>
<p>根到每个内结点</p>
<p>(非叶子)的路径长度的总和(边数)。原来的树上每一个节点到树根的长度的综合</p>
<ul>
<li>I&#x3D;2+1+0+3+2+2+1&#x3D;11 如右上图例</li>
</ul>
</li>
<li><p>结点的带权路径长度：一个结点的权值与结点的路径长度的乘积。</p>
<ul>
<li>每个结点的权重占有一定的值</li>
</ul>
</li>
<li><p>带权的外路径长度：各叶结点的带权路径长度之和。</p>
</li>
<li><p>带权的内路径长度：各非叶结点的带权路径长度之和。</p>
</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/17.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/17.png"><span class="image-caption">img</span></a></p>
<p>例子如下</p>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/18.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/18.png"><span class="image-caption">img</span></a></p>
<ol>
<li>从形状上来讲，二叉树有以上三种大致形状。</li>
</ol>
<h3 id="5-1-2-Huffman算法"><a href="#5-1-2-Huffman算法" class="headerlink" title="5.1.2. Huffman算法"></a>5.1.2. Huffman算法</h3><ol>
<li>思想：权大的外结点靠近根，权小的远离根。</li>
<li>算法：从m个权值中找出两个最小值W1，W2构成</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/19.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/19.png"><span class="image-caption">img</span></a></p>
<ol>
<li>就是把计算结果放进去和其他节点一起选出两个，进行迭代</li>
<li>所以我们就是把数字比较大的挂到距离根比较近的地方</li>
<li>内节点不会只有一个叶节点。</li>
</ol>
<h3 id="5-1-3-霍夫曼编码"><a href="#5-1-3-霍夫曼编码" class="headerlink" title="5.1.3. 霍夫曼编码"></a>5.1.3. 霍夫曼编码</h3><ol>
<li>是霍夫曼树在数据编码中一种应用。具体的讲用于通信的二进制编码中。设一电文出现的字符为D&#x3D;{M，S，T，A，Q， K}，每个字符出现的频率为W&#x3D;{10，29，4，8，15，7}，如何对上面的诸字符进行二进制编码，使得<ul>
<li>该电文的总长度最短。</li>
<li>为了译码，任一字符的编码不应是另一字符的编码的前缀</li>
</ul>
</li>
<li>根据树情况，我们知道编码是不具有二义性的，必然唯一对应，一个叶节点就一个结果</li>
</ol>
<h1 id="6-考研例题"><a href="#6-考研例题" class="headerlink" title="6. 考研例题"></a>6. 考研例题</h1><h2 id="6-1-2019年"><a href="#6-1-2019年" class="headerlink" title="6.1. 2019年"></a>6.1. 2019年</h2><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/25.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/25.png"><span class="image-caption">img</span></a></p>
<ol>
<li>D</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/26.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/26.png"><span class="image-caption">img</span></a></p>
<ol>
<li>4题:C 第七层48+前六层63(第六层:8个叶节点+24个根节点)</li>
<li>5题:B 左子女右兄弟，枚举法，v有四种情况，按照左子女右兄弟即可<ul>
<li>最左边:不是父子也不是兄弟关系</li>
<li>第二个:父子</li>
<li>第三个:无关系</li>
<li>第四个:兄弟</li>
</ul>
</li>
</ol>
<h2 id="6-2-2020年"><a href="#6-2-2020年" class="headerlink" title="6.2. 2020年"></a>6.2. 2020年</h2><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/27.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/27.png"><span class="image-caption">img</span></a></p>
<ol>
<li>3题:D</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/28.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/28.png"><span class="image-caption">img</span></a></p>
<ol>
<li>5题:B<ul>
<li>总结点数:（20*4+10*3+1*2+10*1+1）-(20+10+1+10)&#x3D;82 所有节点-有子节点</li>
</ul>
</li>
<li>6题:A<ul>
<li>根节点度数可以为1，树中不含树根</li>
</ul>
</li>
</ol>
<h1 id="7-广义表"><a href="#7-广义表" class="headerlink" title="7. 广义表"></a>7. 广义表</h1><h2 id="7-1-广义表定义"><a href="#7-1-广义表定义" class="headerlink" title="7.1. 广义表定义"></a>7.1. 广义表定义</h2><ol>
<li>定义为n(n&gt;&#x3D;0)个表元素a0,a1,a2,……an-1组成的有限序列, 记作: LS&#x3D;(a0,a1,a2,……an-1)<ul>
<li>其中每个表元素ai可以是原子,也可以是子表.</li>
<li>原子: 某种类型的对象,在结构上不可分(用小写字母表示).</li>
<li>子表: 有结构的。(用大写字母表示)</li>
</ul>
</li>
<li>Eg.L &#x3D; (3,(),(b,c),(((d))))</li>
</ol>
<h2 id="7-2-广义表基础概念"><a href="#7-2-广义表基础概念" class="headerlink" title="7.2. 广义表基础概念"></a>7.2. 广义表基础概念</h2><ol>
<li>长度:表中元素的个数</li>
<li>广义表的表头，表尾<ul>
<li>head&#x3D; a0;</li>
<li>tail&#x3D; (a1, a2,……an-1)</li>
<li>C&#x3D;(a,(5,3,x))  表头为a,表尾为((5,3,x))</li>
</ul>
</li>
<li>广义表的深度:表中所含括号的最大层数</li>
</ol>
<h2 id="7-3-广义表的性质"><a href="#7-3-广义表的性质" class="headerlink" title="7.3. 广义表的性质"></a>7.3. 广义表的性质</h2><ol>
<li>有序性</li>
<li>有长度,有深度</li>
<li>可递归,如上面例6</li>
<li>可共享,如E中B为E,D所共享</li>
<li>各种广义表都可用一种示意图来表示,用圆表示表元素, 用长方形表示原子</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/20.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/20.png"><span class="image-caption">img</span></a></p>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/21.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/21.png"><span class="image-caption">img</span></a></p>
<h2 id="7-4-广义表的操作"><a href="#7-4-广义表的操作" class="headerlink" title="7.4. 广义表的操作"></a>7.4. 广义表的操作</h2><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/22.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/22.png"><span class="image-caption">img</span></a></p>
<h2 id="7-5-广义表的实现"><a href="#7-5-广义表的实现" class="headerlink" title="7.5. 广义表的实现"></a>7.5. 广义表的实现</h2><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/23.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/23.png"><span class="image-caption">img</span></a></p>
<h2 id="7-6-广义表的类声明"><a href="#7-6-广义表的类声明" class="headerlink" title="7.6. 广义表的类声明"></a>7.6. 广义表的类声明</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> HEAD 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTGR 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CH 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LST 3</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GenList</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GenListNode</span> &#123;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenList</span>;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> utype;<br>        GenListNode * tlink;<br>        <span class="hljs-keyword">union</span> &#123;<br>            <span class="hljs-type">int</span> ref;<br>            <span class="hljs-type">int</span> intgrinfo;<br>            <span class="hljs-type">char</span> charinfo;<br>        GenListNode * hlink;<br>        &#125; value;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function">GenListNode &amp; <span class="hljs-title">info</span> <span class="hljs-params">(GenListNode * elem)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nodetype</span> <span class="hljs-params">(GenListNode * elem)</span> </span>&#123;<span class="hljs-keyword">return</span> elem-&gt;utype;&#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setinfo</span> <span class="hljs-params">(GenListNode * elem,GenListNode &amp; x)</span></span>;<br>    &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GenList</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>        GenListNode * first;<br>        <span class="hljs-function">GenListNode * <span class="hljs-title">Copy</span> <span class="hljs-params">(GenListNode * ls)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">depth</span> <span class="hljs-params">(GenListnode * ls)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">equal</span> <span class="hljs-params">(GenlistNode * s, Genlistnode * t)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Remove</span> <span class="hljs-params">(GenlistNode * ls)</span></span>;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">GenList</span> ( );<br>        ~<span class="hljs-built_in">GenList</span> ( );<br>        <span class="hljs-function">GenListNode &amp; <span class="hljs-title">Head</span> <span class="hljs-params">( )</span></span>;<br>        <span class="hljs-function">GenListNode * <span class="hljs-title">Tail</span> <span class="hljs-params">( )</span></span>;<br>        <span class="hljs-function">GenlistNode * <span class="hljs-title">First</span> <span class="hljs-params">( )</span></span>;<br>        <span class="hljs-function">GenlistNode * <span class="hljs-title">Next</span> <span class="hljs-params">(GenListNode * elem)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Push</span> <span class="hljs-params">(GenListNode &amp; x)</span></span>;<br>        <span class="hljs-function">GenList &amp; <span class="hljs-title">Addon</span> <span class="hljs-params">( GenList &amp; list, GenListNode  &amp; x)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setHead</span> <span class="hljs-params">(GenListNode  &amp; x)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setNext</span> <span class="hljs-params">(GenlistNode  * elem1, GenlistNode  * elem2)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setTail</span><span class="hljs-params">(GenList &amp; list)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Copy</span> <span class="hljs-params">(<span class="hljs-type">const</span> GenList &amp; l)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">depth</span> <span class="hljs-params">( )</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Createlist</span> <span class="hljs-params">(GenListNode  * ls, <span class="hljs-type">char</span> * s)</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="7-7-广义表的实现"><a href="#7-7-广义表的实现" class="headerlink" title="7.7. 广义表的实现"></a>7.7. 广义表的实现</h2><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/24.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt5/24.png"><span class="image-caption">img</span></a></p>
<h3 id="7-7-1-求解广义表深度"><a href="#7-7-1-求解广义表深度" class="headerlink" title="7.7.1. 求解广义表深度"></a>7.7.1. 求解广义表深度</h3><figure class="highlight zephir"><table><tr><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> GenList::depth( ) &#123; <br>        <span class="hljs-keyword">return</span> depth(first);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> GenList::depth(GenListNode*ls) &#123;<br>        <span class="hljs-keyword">if</span>( ls--&gt;tlink==NULL) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        GenListNode*temp=ls--&gt;tlink;<br>        <span class="hljs-keyword">int</span> m=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>( temp!=NULL) &#123;<br>            <span class="hljs-keyword">if</span>( temp--&gt;utype==LST) &#123;<br>                <span class="hljs-keyword">int</span> n=depth(temp--&gt;value.hlink);<br>                <span class="hljs-keyword">if</span>(m&lt;n)m=n;<br>            &#125;<br>            temp=temp--&gt;tlink;<br>        &#125;<br>    <span class="hljs-keyword">return</span> m+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="7-7-2-判断两个广义表的相等关系"><a href="#7-7-2-判断两个广义表的相等关系" class="headerlink" title="7.7.2. 判断两个广义表的相等关系"></a>7.7.2. 判断两个广义表的相等关系</h3><ol>
<li>相等的条件: 具有相同的结构，对应的数据元素具有相等的值</li>
</ol>
<figure class="highlight xl"><table><tr><td class="code"><pre><code class="hljs xl"><span class="hljs-keyword">if</span>(两个广义表都为空表) return相等<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(都为原子^值相等) 递归比较同一层的后面的表元素<br><span class="hljs-keyword">else</span> return 不相等. <br><span class="hljs-function"><span class="hljs-title">int</span> operator==(const GenList&amp;l,const GenList&amp;m)//假设是友元&#123;  return equal(l.first, m.first); &#125;int equal(GenListNode*s, GenListNode*t)//假设是友元&#123;    int  x;    <span class="hljs-keyword">if</span>(s--&gt;</span><span class="hljs-function"><span class="hljs-title">tlink</span>==NULL&amp;&amp;t--&gt;</span><span class="hljs-function"><span class="hljs-title">tlink</span>==NULL) return 1;    <span class="hljs-keyword">if</span>((s--&gt;</span><span class="hljs-function"><span class="hljs-title">tlink</span>!=NULL&amp;&amp;t--&gt;</span><span class="hljs-function"><span class="hljs-title">tlink</span>!=NULL&amp;&amp;s--&gt;</span><span class="hljs-function"><span class="hljs-title">tlink</span>--&gt;</span><span class="hljs-function"><span class="hljs-title">utype</span>==t--&gt;</span><span class="hljs-function"><span class="hljs-title">tlink</span>--&gt;</span><span class="hljs-function"><span class="hljs-title">utype</span>) &#123;        <span class="hljs-keyword">if</span>(s--&gt;</span><span class="hljs-function"><span class="hljs-title">tlink</span>--&gt;</span><span class="hljs-function"><span class="hljs-title">utype</span>==INTGR)            <span class="hljs-keyword">if</span>(s--&gt;</span><span class="hljs-function"><span class="hljs-title">tlink</span>--&gt;</span><span class="hljs-function"><span class="hljs-title">value</span>.intgrinfo== t--&gt;</span><span class="hljs-function"><span class="hljs-title">tlink</span>--&gt;</span><span class="hljs-function"><span class="hljs-title">value</span>.intgrinfo)x=1;            <span class="hljs-keyword">else</span>  x=0;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s--&gt;</span><span class="hljs-function"><span class="hljs-title">tlink</span>--&gt;</span><span class="hljs-function"><span class="hljs-title">utype</span>==CH)            <span class="hljs-keyword">if</span>(s--&gt;</span><span class="hljs-function"><span class="hljs-title">tlink</span>--&gt;</span><span class="hljs-function"><span class="hljs-title">value</span>.charinfo==t--&gt;</span><span class="hljs-function"><span class="hljs-title">tlink</span>--&gt;</span><span class="hljs-function"><span class="hljs-title">value</span>.charinfo)x=1;            <span class="hljs-keyword">else</span>  x=0;        <span class="hljs-keyword">else</span>  x=equal(s--&gt;</span><span class="hljs-function"><span class="hljs-title">tlink</span>--&gt;</span><span class="hljs-function"><span class="hljs-title">value</span>.hlink, t--&gt;</span><span class="hljs-function"><span class="hljs-title">tlink</span>--&gt;</span><span class="hljs-function"><span class="hljs-title">value</span>.hlink);        <span class="hljs-keyword">if</span>(x)return equal(s--&gt;</span><span class="hljs-function"><span class="hljs-title">tlink</span>,  t--&gt;</span>tlink);    &#125;    return <span class="hljs-number">0</span>;&#125;<br></code></pre></td></tr></table></figure>

<h3 id="7-7-3-广义表的复制算法"><a href="#7-7-3-广义表的复制算法" class="headerlink" title="7.7.3. 广义表的复制算法"></a>7.7.3. 广义表的复制算法</h3><ol>
<li>分别复制表头,表尾,然后合成，前提是广义表不可以是共享表或递归表</li>
</ol>
<figure class="highlight zephir"><table><tr><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">public</span>:<br>    void  GenList::copy(<span class="hljs-keyword">const</span> GenList&amp;l) &#123;first=copy(l.first);&#125;<br><span class="hljs-keyword">private</span>:<br>    GenListNode*GenList::copy(GenListNode*ls) &#123;<br>        GenListNode*q=NULL;<br>        <span class="hljs-keyword">if</span>(ls!=NULL) &#123;<br>            q=<span class="hljs-keyword">new</span> GenListNode; q--&gt;utype=ls--&gt;utype;<br>            Switch(ls--&gt;utype) &#123;<br>                <span class="hljs-keyword">case</span>  HEAD:  <br>                    q--&gt;value.ref=ls--&gt;value.ref;<br>                    <span class="hljs-keyword">break</span>;<span class="hljs-comment">//表头结点</span><br>                <span class="hljs-keyword">case</span>   INTGR: <br>                    q--&gt;value.intgrinfo=ls--&gt;value.intgrinfo;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span>  CH:<br>                    q--&gt;value.charinfo=ls--&gt;value.charinfo;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span>  LST: <br>                    q--&gt;value.hlink=ls--&gt;value.hlink;<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>            q--&gt;tlink=copy(ls--&gt;tlink);<br>        &#125;<br>    <span class="hljs-keyword">return</span> q;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="7-7-4-广义表析构函数"><a href="#7-7-4-广义表析构函数" class="headerlink" title="7.7.4. 广义表析构函数"></a>7.7.4. 广义表析构函数</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">public:<br>    GenList::~GenList()&#123;<br>        <span class="hljs-built_in">remove</span>(first);<br>    &#125;<br>private:<br>    void GenList::<span class="hljs-built_in">remove</span>(GenListNode*ls) &#123;<br>        ls-&gt;value.ref--;<br>        <span class="hljs-keyword">if</span> (!ls-&gt;value.ref) &#123;<br>            GenListNode*<span class="hljs-attribute">y</span>=ls;<br>            <span class="hljs-keyword">while</span>(y--&gt;tlink!=<span class="hljs-literal">NULL</span>) &#123;  <br>                <span class="hljs-attribute">y</span>=y--&gt;tlink;<br>                <span class="hljs-keyword">if</span>(y--&gt;utype= =LST)<br>                    <span class="hljs-built_in">remove</span>(y--&gt;value.hlink);<br>            &#125;<br>            y--&gt;<span class="hljs-attribute">tlink</span>=av;<br>            <span class="hljs-attribute">av</span>=ls;//回收顶点到可利用空间表中<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>







<p>​           </p>
<h1 id="Lecture-4-5-特殊树"><a href="#Lecture-4-5-特殊树" class="headerlink" title="Lecture 4.5 特殊树"></a>Lecture 4.5 特殊树</h1><h1 id="1-二叉搜索树"><a href="#1-二叉搜索树" class="headerlink" title="1. 二叉搜索树"></a>1. 二叉搜索树</h1><ol>
<li>Definition: A binary search tree is a binary tree that may be empty. A nonempty binary search tree satisfies the following  properties:(二叉搜索树是一个可以为空的二叉树。一个非空的二叉树都满足如下性质)<ol>
<li>Every element has a key and no two elements have the same key;  therefore,all keys are distinct. (每一个元素都含有一个关键字，并且每一个元素都有独一无二的关键字)</li>
<li>The keys(if any)in the left subtree of the root are smaller than the key in the root.(一个树的<strong>左子树的关键字小</strong>于根中的关键字)</li>
<li>The keys(if any)in the right subtree of the root are larger than the key in the root.(一个树的<strong>右子树的关键字大</strong>于根中的关键字)</li>
<li>The left and right subtrees of the root are also binary search trees.(根的左右子树还是二叉搜索树)</li>
</ol>
</li>
<li>二叉搜索树需要满足的事情:在很大的数据量下，要能够</li>
</ol>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryNode</span> </span>&#123;<br>    BinaryNode( <span class="hljs-built_in">Comparable</span> theElement ) &#123;<br>        <span class="hljs-keyword">this</span>( theElement, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span> );<span class="hljs-comment">//调用本类中的其他构造方法</span><br>    &#125;<br>    BinaryNode( <span class="hljs-built_in">Comparable</span>  theElement,  BinaryNode lt,BinaryNode rt ) &#123;<br>        element = theElement<br>        left = lt;<br>        right = rt;<br>    &#125;<br>    <span class="hljs-built_in">Comparable</span> element;<br>    BinaryNode left;<br>    BinaryNode right;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="1-1-2-二叉搜索树需要实现的方法"><a href="#1-1-2-二叉搜索树需要实现的方法" class="headerlink" title="1.1.2. 二叉搜索树需要实现的方法"></a>1.1.2. 二叉搜索树需要实现的方法</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//二叉搜素树的实现</span><br>public <span class="hljs-keyword">class</span> BinarySearchTree &#123;<br>    public <span class="hljs-constructor">BinarySearchTree()</span>&#123; root = null; &#125;<br>    public void make<span class="hljs-constructor">Empty()</span>&#123; root = null; &#125;<br>    public boolean is<span class="hljs-constructor">Empty()</span>&#123; return root<span class="hljs-operator"> == </span>null;&#125;<br>    <br>    public Comparable find( Comparable x )<br>    &#123;return element<span class="hljs-constructor">At( <span class="hljs-params">find</span>( <span class="hljs-params">x</span>, <span class="hljs-params">root</span>)</span>);&#125;<br>    public Comparable find<span class="hljs-constructor">Min()</span><br>    &#123;return element<span class="hljs-constructor">At( <span class="hljs-params">findMin</span>( <span class="hljs-params">root</span> )</span> );&#125;<br>    public Comparable find<span class="hljs-constructor">Max()</span><br>    &#123;return element<span class="hljs-constructor">At( <span class="hljs-params">findMax</span>( <span class="hljs-params">root</span> )</span> );<br>    public void insert( Comparable x )<br>    &#123;root = insert(  x, root );&#125;<br>    public void remove( Comparable x ) &#123;root = remove( x, root ); &#125;<br>    public void print<span class="hljs-constructor">Tree()</span><span class="hljs-comment">//都是外部接口</span><br>    <br>    <span class="hljs-keyword">private</span> BinaryNode root;<br>    <span class="hljs-keyword">private</span> Comparable element<span class="hljs-constructor">At( BinaryNode <span class="hljs-params">t</span> )</span>&#123; return t<span class="hljs-operator"> == </span>null ? Null : t.element; &#125;<br>    <span class="hljs-keyword">private</span> BinaryNode find( Comparable x, BinaryNode t )<br>    <span class="hljs-keyword">private</span> BinaryNode find<span class="hljs-constructor">Min( BinaryNode <span class="hljs-params">t</span> )</span><br>    <span class="hljs-keyword">private</span> BinaryNode find<span class="hljs-constructor">Max( BinaryNode <span class="hljs-params">t</span> )</span><br>    <span class="hljs-keyword">private</span> BinaryNode insert( Comparable x, BinaryNode t )<br>    <span class="hljs-keyword">private</span> BinaryNode remove( Comparable x, BinaryNode t )<br>    <span class="hljs-keyword">private</span> BinaryNode remove<span class="hljs-constructor">Min( BinaryNode <span class="hljs-params">t</span> )</span><br>    <span class="hljs-keyword">private</span> void print<span class="hljs-constructor">Tree( BinaryNode <span class="hljs-params">t</span> )</span><br>&#125;<br><span class="hljs-comment">//查找某个元素的算法</span><br><span class="hljs-keyword">private</span> BinaryNode find( Comparable x, BinaryNode t ) &#123;<br>    <span class="hljs-keyword">if</span>( t<span class="hljs-operator"> == </span>null )<br>        return null;<br>    <span class="hljs-keyword">if</span>( x.compare<span class="hljs-constructor">To( <span class="hljs-params">t</span>.<span class="hljs-params">element</span> )</span> &lt; <span class="hljs-number">0</span> )<br>        return find( x, t.left );<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( x.compare<span class="hljs-constructor">To( <span class="hljs-params">t</span>.<span class="hljs-params">element</span> )</span> &gt; <span class="hljs-number">0</span> )<br>        return find( x, t.right );<br>    <span class="hljs-keyword">else</span><br>        return t;<span class="hljs-comment">//Match </span><br>&#125;<br><span class="hljs-comment">//查找值最小的结点</span><br><span class="hljs-comment">//使用递归查找结点</span><br><span class="hljs-keyword">private</span> BinaryNode find<span class="hljs-constructor">Min( BinaryNode <span class="hljs-params">t</span> )</span> &#123;  <br>    <span class="hljs-keyword">if</span>( t<span class="hljs-operator"> == </span>null )<br>        return null;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( t.left<span class="hljs-operator"> == </span>null )<br>        return t;<br>    return find<span class="hljs-constructor">Min( <span class="hljs-params">t</span>.<span class="hljs-params">left</span> )</span>;<br>&#125;<br><span class="hljs-comment">//迭代找最小结点</span><br><span class="hljs-keyword">private</span> BinaryNode find<span class="hljs-constructor">Min(BinaryNode <span class="hljs-params">t</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(t != null)&#123;<br>        <span class="hljs-keyword">while</span>(t.left != null)&#123;<br>            t = t.left;<br>        &#125;<br>    &#125;<br>    return t;<br>&#125;<br><span class="hljs-comment">//递归找到最大结点</span><br><span class="hljs-keyword">private</span> BinaryNode find<span class="hljs-constructor">Max( BinaryNode <span class="hljs-params">t</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(t<span class="hljs-operator"> == </span>null)&#123;<br>        return null;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t.right<span class="hljs-operator"> == </span>null)&#123;<br>        return t;<br>    &#125;<br>    return find<span class="hljs-constructor">Max(<span class="hljs-params">t</span>.<span class="hljs-params">right</span>)</span>;<br>&#125;<br><span class="hljs-comment">//迭代找到最大结点</span><br><span class="hljs-keyword">private</span> BinaryNode find<span class="hljs-constructor">Max( BinaryNode <span class="hljs-params">t</span> )</span> &#123; <br>    <span class="hljs-keyword">if</span>( t != null )<br>        <span class="hljs-keyword">while</span>( t.right != null )<br>            t = t.right;<br>    return t;<br>&#125;<br><span class="hljs-comment">//将数值插入固定位置的算法</span><br><span class="hljs-keyword">private</span> BinaryNode insert( Comparable x, BinaryNode t ) &#123;<br>    <span class="hljs-comment">//先查找一次，如果找到了就不用进行查找</span><br>    <span class="hljs-keyword">if</span>( t<span class="hljs-operator"> == </span>null )<br>        t = <span class="hljs-keyword">new</span> <span class="hljs-constructor">BinaryNode( <span class="hljs-params">x</span>, <span class="hljs-params">null</span>, <span class="hljs-params">null</span> )</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( x.compare<span class="hljs-constructor">To( <span class="hljs-params">t</span>.<span class="hljs-params">element</span> )</span> &lt; <span class="hljs-number">0</span> )<br>        t.left = insert( x, t.left );<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( x.compare<span class="hljs-constructor">To( <span class="hljs-params">t</span>.<span class="hljs-params">element</span> )</span> &gt; <span class="hljs-number">0</span> )<br>        t.right = insert( x, t.right );<br>    <span class="hljs-keyword">else</span> ;<span class="hljs-comment">//duplicate; do nothing</span><br>    return t;<br>&#125;<br><span class="hljs-comment">//compareTo()方法如果小于返回负数，大于返回正数</span><br></code></pre></td></tr></table></figure>

<h2 id="删除算法"><a href="#删除算法" class="headerlink" title="删除算法"></a>删除算法</h2><ol>
<li>如果结点本身不在树内，那么不需要删除</li>
<li>如果结点本身在树里面，删除需要分类<ol>
<li>无子树:删除叶节点</li>
<li>一颗子树:直接连接</li>
<li>两颗子树:可以选择左子树的最大结点作为新结点</li>
</ol>
</li>
</ol>
<figure class="highlight coq"><table><tr><td class="code"><pre><code class="hljs coq">private BinaryNode remove( Comparable x, BinaryNode t ) &#123;<br>    <span class="hljs-keyword">if</span>( t == null )<br>        <span class="hljs-keyword">return</span> t;<br>    <span class="hljs-keyword">if</span>( x.compareTo( t.element ) &lt; <span class="hljs-number">0</span> )<br>        t.<span class="hljs-built_in">left</span> = remove( x, t.<span class="hljs-built_in">left</span> );<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( x.compareTo( t.element ) &gt; <span class="hljs-number">0</span> )<br>        t.<span class="hljs-built_in">right</span> = remove( x, t.<span class="hljs-built_in">right</span> );<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( t.<span class="hljs-built_in">left</span> != null &amp;&amp; t.<span class="hljs-built_in">right</span> != null ) &#123;<br>        t.element = findMin( t.<span class="hljs-built_in">right</span> ).element;//把右树最小的复制给t<br>        t.<span class="hljs-built_in">right</span> = remove( t.element , t.<span class="hljs-built_in">right</span> );//递归的删除<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        t = ( t.<span class="hljs-built_in">left</span> != null ) ? t.<span class="hljs-built_in">left</span> : t.<span class="hljs-built_in">right</span>;//一颗子树的情况<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="高度"><a href="#高度" class="headerlink" title="高度"></a>高度</h2><ol>
<li>The height of a binary search tree has influence directly on the  time complexity of operations like searching, insertion and deletion.  二叉搜索树的高度会影响搜索，插入和删除算法的搜索度</li>
<li>Worst case: add an ordered elements{1,2,3…n} into an empty binary search tree. 最坏的情况就是把一个有序的数列添加进入到空的二叉搜索树中去。</li>
</ol>
<h2 id="二叉搜索树的算法复杂度"><a href="#二叉搜索树的算法复杂度" class="headerlink" title="二叉搜索树的算法复杂度"></a>二叉搜索树的算法复杂度</h2><ol>
<li>二叉搜索树以上的所有操作都和二叉搜索树的深度有关，所以在生成二叉树的时候我们需要保证二叉搜索树的平衡性，(如果一开始输入最小的，树严重失衡，如果一开始输入中等，树基本平衡)</li>
<li>Best Case:O(log2n)</li>
</ol>
<h2 id="1-2-索引二叉树"><a href="#1-2-索引二叉树" class="headerlink" title="1.2. 索引二叉树"></a>1.2. 索引二叉树</h2><ol>
<li>An indexed binary search tree is derived from an ordinary binary  search tree by adding the field  leftSize to each tree node.  索引二叉搜索树是通过将字段leftSize添加到每个树节点，从普通二叉搜索树派生而来的。</li>
<li>Value in Leftsize field&#x3D;number of the elements in the node’s left subtree +1(leftsize &#x3D; 左子树大小 + 1)</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/2.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/2.png"><span class="image-caption">img</span></a></p>
<ol>
<li>Eg.</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/3.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/3.png"><span class="image-caption">img</span></a></p>
<h1 id="2-AVL-Tree-自平衡的二叉搜索树"><a href="#2-AVL-Tree-自平衡的二叉搜索树" class="headerlink" title="2. AVL Tree(自平衡的二叉搜索树)"></a>2. AVL Tree(自平衡的二叉搜索树)</h1><ol>
<li>目的:the AVL tree was introduced to increase the efficiency of  searching a binary search tree, and to decrease the average search  length. AVL树是一个用来增加二叉搜索树的平衡性并且<strong>减小平均搜索高度</strong></li>
<li>AVL的高度是O(log2 n)的，所以对应的算法复杂度也是这样的。</li>
</ol>
<h2 id="2-1-什么是AVL树"><a href="#2-1-什么是AVL树" class="headerlink" title="2.1. 什么是AVL树"></a>2.1. 什么是AVL树</h2><ol>
<li>AVL树是一个二叉搜索树</li>
<li>AVL树的每一个节点满足|hL-hR|&lt;&#x3D;1 where hL and hR are the heights of TL(left subtree) and TR(right subtree),respectively.对于<strong>每一个结点，其左子树和右子树的高度之差不超过1</strong></li>
<li>注:树叶之间之差未必小于一，但是一个节点的左右子树的高度不能大于一</li>
</ol>
<h2 id="2-2-AVL树的基本概念"><a href="#2-2-AVL树的基本概念" class="headerlink" title="2.2. AVL树的基本概念"></a>2.2. AVL树的基本概念</h2><ol>
<li>AVL树高:the longest path from the root to each leaf node(从根节点到每一个叶节点之间的所有路径的最长的一条)</li>
<li>Balance factor bf(x) of a node x : height of right subtree of x – height of left subtree of x 节点x的<strong>平衡因子</strong> &#x3D; x的右树的高度-x的左树的高度</li>
</ol>
<h2 id="2-3-AVL树的结点的实现"><a href="#2-3-AVL树的结点的实现" class="headerlink" title="2.3. AVL树的结点的实现"></a>2.3. AVL树的结点的实现</h2><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/4.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/4.png"><span class="image-caption">img</span></a></p>
<h2 id="2-4-AVL树的实现"><a href="#2-4-AVL树的实现" class="headerlink" title="2.4. AVL树的实现"></a>2.4. AVL树的实现</h2><ol>
<li>这个例子里每个结点中存储着树高</li>
<li>树高之差就是平衡因子</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">class</span> <span class="hljs-built_in">AVLNode</span> &#123;<br>    <span class="hljs-built_in">AVLNode</span>(Comparable theElement) &#123;<br>        <span class="hljs-variable language_">this</span>( theElement, null, null);<br>    &#125;<br>    <span class="hljs-built_in">AVLNode</span>(Compalable theElement, <span class="hljs-built_in">AVLNode</span> lt, <span class="hljs-built_in">AVLNode</span> rt) &#123;<br>        element = theElement;<br>        left = lt;<br>        right = rt;<br>        height = <span class="hljs-number">0</span>;<br>    &#125;<br>    Comparable element;<br>    <span class="hljs-built_in">AVLNode</span> left;<br>    <span class="hljs-built_in">AVLNode</span> right;<br>    <span class="hljs-type">int</span> height;<br>&#125;<br>private <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> height( <span class="hljs-built_in">AVLNode</span> t ) &#123;   <br>    <span class="hljs-keyword">return</span> t =s= null ? –<span class="hljs-number">1</span> : t. height;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-5-AVL树的基本操作"><a href="#2-5-AVL树的基本操作" class="headerlink" title="2.5. AVL树的基本操作"></a>2.5. AVL树的基本操作</h2><h3 id="2-5-1-AVL树的查询"><a href="#2-5-1-AVL树的查询" class="headerlink" title="2.5.1. AVL树的查询"></a>2.5.1. AVL树的查询</h3><p>查询过程和正常的二叉搜索树是相同的，其算法复杂度和正常二叉搜索树的搜索算法的复杂度是相同的。</p>
<h3 id="2-5-2-AVL树的插入"><a href="#2-5-2-AVL树的插入" class="headerlink" title="2.5.2. AVL树的插入"></a>2.5.2. AVL树的插入</h3><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/5.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/5.png"><span class="image-caption">img</span></a></p>
<ol>
<li>简单来看，<strong>每一个子树都可以被看为如上的图</strong></li>
<li>算法流程:是递归<strong>从下向上</strong>进行旋转处理，先看子树。</li>
</ol>
<h2 id="插入C的右子树E-外侧结点"><a href="#插入C的右子树E-外侧结点" class="headerlink" title="插入C的右子树E(外侧结点)"></a>插入C的右子树E(外侧结点)</h2><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/6.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/6.png"><span class="image-caption">img</span></a></p>
<ol>
<li>只需要进行一次左单旋转即可</li>
<li>左单旋转过程如上</li>
</ol>
<h2 id="插入C的左子树D-内侧结点"><a href="#插入C的左子树D-内侧结点" class="headerlink" title="插入C的左子树D(内侧结点)"></a>插入C的左子树D(内侧结点)</h2><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/7.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/7.png"><span class="image-caption">img</span></a></p>
<ol>
<li>需要进行一次双旋转(先右后左)</li>
</ol>
<h2 id="插入其他地方，树不需要转"><a href="#插入其他地方，树不需要转" class="headerlink" title="插入其他地方，树不需要转"></a>插入其他地方，树不需要转</h2><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/8.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/8.png"><span class="image-caption">img</span></a></p>
<ol>
<li>一直到5的时候，树的平衡性才受到影响</li>
<li>插入后，树的平衡性没有被破坏显然不用旋转</li>
<li>调整只要在包含插入结点的最小不平衡子树中进行，即从到达插入结点的路径上，离插入结点最近的，并且平衡系数!&#x3D;0的<strong>结点为根的子树</strong>.</li>
</ol>
<h2 id="算法思想与总结（考试可能画图）"><a href="#算法思想与总结（考试可能画图）" class="headerlink" title="算法思想与总结（考试可能画图）"></a>算法思想与总结（考试可能画图）</h2><ol>
<li>算法思想:插入一个新结点后，需要从插入位置沿通向根的路径回溯，检查各结点左右子树的高度差，如果发现某点高度不平衡则停止回溯。<ul>
<li>先确定节点是在外侧还是内侧,决定是单旋还是双旋</li>
</ul>
</li>
<li>单旋转：<strong>外侧</strong>—从不平衡结点沿刚才回溯的路径取直接下两层如果三个结点处于一直线A，C，E</li>
<li>双旋转：<strong>内侧</strong>—从不平衡结点沿刚才回溯的路径取直接下两层如果三个结点处于一折线A，C，D</li>
<li>以上以右外侧，右内侧为例，左外侧，左内侧是对称的。与前面对称的情况：左外侧，左内侧 左外侧<ul>
<li>右下旋 <a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/9.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/9.png"><span class="image-caption">img</span></a></li>
<li>左下旋 <a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/26.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/26.png"><span class="image-caption">img</span></a></li>
<li>右内侧 <a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/27.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/27.png"><span class="image-caption">img</span></a></li>
<li>左内侧 <a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/10.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/10.png"><span class="image-caption">img</span></a></li>
</ul>
</li>
<li>插入:<ol>
<li>首先要找到正确的位置进行插入</li>
<li>找到有可能发生不平衡的最小不平衡子树</li>
<li>判别插入在不平衡子树的外侧还是内侧</li>
<li>根据3的判别结果,再进行单旋还是双旋</li>
</ol>
</li>
</ol>
<h2 id="例子-从空的AVL树建树的算法"><a href="#例子-从空的AVL树建树的算法" class="headerlink" title="例子(从空的AVL树建树的算法)"></a>例子(从空的AVL树建树的算法)</h2><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/11.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/11.png"><span class="image-caption">img</span></a></p>
<ol>
<li>右双旋转：先变成ACZ，再把AC旋转下去。</li>
<li>左子树的左子树是左外侧，左子树的右子树是左外侧，右子树的左子树是右内侧，右子树的右子树是右外侧<ul>
<li>判断内侧外侧只从被破坏根节点向下2层。<br> <a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/12.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/12.png"><span class="image-caption">img</span></a></li>
</ul>
</li>
</ol>
<h2 id="插入算法代码"><a href="#插入算法代码" class="headerlink" title="插入算法代码"></a>插入算法代码</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> AVLNode insert( Comparable x, AVLNode t ) &#123;<br>    <span class="hljs-keyword">if</span> (t<span class="hljs-operator"> == </span>null)<br>        t = <span class="hljs-keyword">new</span> <span class="hljs-constructor">AVLNode( <span class="hljs-params">x</span>, <span class="hljs-params">null</span>, <span class="hljs-params">null</span> )</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( x.compare<span class="hljs-constructor">To(<span class="hljs-params">t</span>.<span class="hljs-params">element</span>)</span> &lt; <span class="hljs-number">0</span> )&#123;<br>        t.left = insert(x, t.left);<span class="hljs-comment">//不仅x插入左子树，而其左子树已经调平衡了，也就会子树已经旋转过了</span><br>        <span class="hljs-keyword">if</span>(height(t.left) – height(t.right)<span class="hljs-operator"> == </span><span class="hljs-number">2</span> )<br>            <span class="hljs-keyword">if</span>(x.compare<span class="hljs-constructor">To(<span class="hljs-params">t</span>.<span class="hljs-params">left</span>.<span class="hljs-params">element</span>)</span>&lt;<span class="hljs-number">0</span>)<br>                <span class="hljs-comment">//根据大小进行调整</span><br>                t = rotateWithLeftChild (t);<span class="hljs-comment">//左子树的左子树，只要做一次左向单旋</span><br>            <span class="hljs-keyword">else</span> t = double<span class="hljs-constructor">WithLeftChild(<span class="hljs-params">t</span>)</span>;<span class="hljs-comment">//左子树的右子树，需要做一次左向双选</span><br>    <span class="hljs-comment">//下面是对称的插入在右子树上</span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x.compare<span class="hljs-constructor">To(<span class="hljs-params">t</span>.<span class="hljs-params">element</span>)</span>&gt;<span class="hljs-number">0</span>) &#123; <br>        t.right = insert(x, t.right );<br>        <span class="hljs-keyword">if</span>( height(t.right)–height(t.left)== <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">if</span>(x.compare<span class="hljs-constructor">To(<span class="hljs-params">t</span>.<span class="hljs-params">right</span>.<span class="hljs-params">element</span>)</span>&gt;<span class="hljs-number">0</span>)<br>                t = rotate<span class="hljs-constructor">WithRightChild(<span class="hljs-params">t</span>)</span>;<br>            <span class="hljs-keyword">else</span> t = double<span class="hljs-constructor">WithRightChild(<span class="hljs-params">t</span>)</span><br>    &#125;<span class="hljs-keyword">else</span>;<br>    t.height = max(height(t.left), height(t.right)) + <span class="hljs-number">1</span>;<br>    return t;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>右下旋</p>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/9.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/9.png"><span class="image-caption">img</span></a></p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><code class="hljs x86asm">private static AVLNode rotateWithLeftChild( AVLNode <span class="hljs-built_in">k2</span> ) &#123;<br>    AVLNode <span class="hljs-built_in">k1</span> = <span class="hljs-built_in">k2</span><span class="hljs-number">.</span>left<span class="hljs-comment">;//k1持有k2的左子树</span><br>    <span class="hljs-built_in">k2</span><span class="hljs-number">.</span>left = <span class="hljs-built_in">k1</span><span class="hljs-number">.</span>right<span class="hljs-comment">;//k1的右子树挂到k2的左子树上</span><br>    <span class="hljs-built_in">k1</span><span class="hljs-number">.</span>right = <span class="hljs-built_in">k2</span><span class="hljs-comment">;//把k2自己挂到k1的右子树上</span><br>    <span class="hljs-built_in">k2</span><span class="hljs-number">.</span>height = max(height(<span class="hljs-built_in">k2</span><span class="hljs-number">.</span>left), height(<span class="hljs-built_in">k2</span><span class="hljs-number">.</span>right)) + <span class="hljs-number">1</span> <span class="hljs-comment">;</span><br>    <span class="hljs-built_in">k1</span><span class="hljs-number">.</span>height = max(height(<span class="hljs-built_in">k1</span><span class="hljs-number">.</span>left), <span class="hljs-built_in">k2</span><span class="hljs-number">.</span>height) + <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>    return <span class="hljs-built_in">k1</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>左下旋</p>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/26.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/26.png"><span class="image-caption">img</span></a></p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><code class="hljs x86asm">private static AVLNode rotateWithRightChild(AVLNode <span class="hljs-built_in">k2</span>)&#123;<br>    AVLNode <span class="hljs-built_in">k1</span> = <span class="hljs-built_in">k2</span><span class="hljs-number">.</span>right<span class="hljs-comment">;//k1持有k2的右子树</span><br>    <span class="hljs-built_in">k2</span><span class="hljs-number">.</span>right = <span class="hljs-built_in">k1</span><span class="hljs-number">.</span>left<span class="hljs-comment">;//k2的右子树挂到k1的左子树上</span><br>    <span class="hljs-built_in">k1</span><span class="hljs-number">.</span>left = <span class="hljs-built_in">k2</span><span class="hljs-comment">;//把k2自己挂到k1的左子树上</span><br>    <span class="hljs-built_in">k2</span><span class="hljs-number">.</span>height = max(height(<span class="hljs-built_in">k2</span><span class="hljs-number">.</span>left),height(<span class="hljs-built_in">k2</span><span class="hljs-number">.</span>right)) + <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>    <span class="hljs-built_in">k1</span><span class="hljs-number">.</span>height = max(<span class="hljs-built_in">k2</span><span class="hljs-number">.</span>height,<span class="hljs-built_in">k1</span><span class="hljs-number">.</span>right) + <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>    return <span class="hljs-built_in">k1</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>右内侧</p>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/27.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/27.png"><span class="image-caption">img</span></a></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span>  static AVLNode double<span class="hljs-constructor">WithLeftChild( AVLNode <span class="hljs-params">k3</span> )</span> &#123;<br>    k3.left = rotate<span class="hljs-constructor">WithRightChild(<span class="hljs-params">k3</span>.<span class="hljs-params">left</span>)</span>;<br>    return rotate<span class="hljs-constructor">WithLeftChild( <span class="hljs-params">k3</span> )</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>左内侧</p>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/10.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/10.png"><span class="image-caption">img</span></a></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> static AVLNode double<span class="hljs-constructor">WithRightChild(AVLNode <span class="hljs-params">k3</span>)</span>&#123;<br>    k3.right = rotate<span class="hljs-constructor">WithLeftChild(<span class="hljs-params">k3</span>.<span class="hljs-params">right</span>)</span>;<br>    return rotate<span class="hljs-constructor">WithRightChild( <span class="hljs-params">k3</span> )</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-5-3-AVL树的删除"><a href="#2-5-3-AVL树的删除" class="headerlink" title="2.5.3. AVL树的删除"></a>2.5.3. AVL树的删除</h3><ol>
<li>方法和二叉搜索树的删除方法一样</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/13.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/13.png"><span class="image-caption">img</span></a></p>
<ol>
<li>需要找到被删除顶点的中序后继。</li>
<li>等待再看一下。</li>
</ol>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/14.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/14.png"><span class="image-caption">img</span></a><br> <a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/15.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/15.png"><span class="image-caption">img</span></a></p>
<h3 id="2-5-4-算法复杂度分析-不做要求"><a href="#2-5-4-算法复杂度分析-不做要求" class="headerlink" title="2.5.4. 算法复杂度分析(不做要求)"></a>2.5.4. 算法复杂度分析(不做要求)</h3><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/16.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/16.png"><span class="image-caption">img</span></a><br> <a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/17.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/17.png"><span class="image-caption">img</span></a><br> <a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/18.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/18.png"><span class="image-caption">img</span></a></p>
<h1 id="3-B-TREES"><a href="#3-B-TREES" class="headerlink" title="3. B-TREES"></a>3. B-TREES</h1><h2 id="3-1-m叉搜索树"><a href="#3-1-m叉搜索树" class="headerlink" title="3.1. m叉搜索树"></a>3.1. m叉搜索树</h2><h3 id="3-1-1-m叉搜索树的定义"><a href="#3-1-1-m叉搜索树的定义" class="headerlink" title="3.1.1. m叉搜索树的定义"></a>3.1.1. m叉搜索树的定义</h3><ol>
<li><p>Definition: An m-way search tree may be empty. If it is not empty,  it is a tree that satisfies the following properties:  m-way搜索树可能为空。如果是一个非空的树，则为满足以下属性的树：</p>
<ol>
<li>In the corresponding extended search tree(obtained by replacing zero pointer with external nodes), each internal node has up to <strong>m children</strong>  and between <strong>1 and m-1  elements</strong>.(在相应的扩展搜索树(用外部节点替换零指针获得)中，每个内部节点最多有m个子节点，在1和m-1元素之间。)</li>
<li>Every node with p elements has exactly p+1 children.(每个具有p元素的节点正好有p+1子节点。)</li>
<li>Consider any node with p elements:<a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/19.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/19.png"><span class="image-caption">img</span></a> k1 &lt; k2 &lt;……&lt; kp,  c0,c1,……,cp be the p+1 children of the node 假设任何节点都有p个元素，那么C0 - Cp是他们对应的p+1个子元素。</li>
</ol>
</li>
<li><p>对于</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/19.png"><span class="image-caption">img</span></p>
<p>中的节点:</p>
<ul>
<li>C0: The elements in the subtree with root c0 have  keys smaller than k1(在以C0为根的所有子树中的结点的值都小于k1)</li>
<li>Cp: Elements in the subtree with root cp have keys larger than kp(在以Cp为根的子树中的所有子树的值都大于Kp)</li>
<li>Ci: Elements in the subtree with root ci have keys larger than ki but smaller than ki+1, 1&lt;&#x3D;i&lt;&#x3D;p.</li>
</ul>
</li>
<li><p>m叉搜索树的例子:</p>
</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/21.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/21.png"><span class="image-caption">img</span></a></p>
<ol>
<li>m叉搜索树是可以存入磁盘的。</li>
</ol>
<h3 id="3-1-2-操作"><a href="#3-1-2-操作" class="headerlink" title="3.1.2. 操作"></a>3.1.2. 操作</h3><h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><ol>
<li>如果一层没有满，就在同一级进行插入。(针对的是m叉的情况)</li>
<li>如果这一层已经满了，那么在下一层进行插入。</li>
<li>例子</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/39.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/39.png"><span class="image-caption">img</span></a><br> <a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/40.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/40.png"><span class="image-caption">img</span></a><br> <a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/41.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/41.png"><span class="image-caption">img</span></a></p>
<ol>
<li>注:n叉搜索树，每一层一个结点最多有n-1个元素</li>
</ol>
<h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><ol>
<li>删除元素不会影响树的叉数，物理层次影响叉数。</li>
<li>类型一:同一层还有节点，直接删除没有影响<br> <a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/42.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/42.png"><span class="image-caption">img</span></a></li>
<li>类型二:本层删除后没有节点，所以需要把底下能合适的最大(最小)的进行提升<br> <a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/43.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/43.png"><span class="image-caption">img</span></a><br> <a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/44.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/44.png"><span class="image-caption">img</span></a><br> <a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/45.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/45.png"><span class="image-caption">img</span></a></li>
</ol>
<h2 id="查找m叉搜索树的行高"><a href="#查找m叉搜索树的行高" class="headerlink" title="查找m叉搜索树的行高"></a>查找m叉搜索树的行高</h2><ol>
<li>Height of an m-way search tree(m叉二叉树的行高)<ol>
<li>An m-way search tree of height h may have as few as h elements(one node per level), as many as mh-1 elements.(一个高为h的m路搜索树最少有h个结点(每一层只有一个结点)，最多有mh-1个结点)</li>
<li>The height of a m-way search tree with n elements is between logm(n+1) and n</li>
<li>n: 2005-1 &#x3D;32*1010-1</li>
</ol>
</li>
</ol>
<h2 id="3-2-平衡的m路搜索树——B树"><a href="#3-2-平衡的m路搜索树——B树" class="headerlink" title="3.2. 平衡的m路搜索树——B树"></a>3.2. 平衡的m路搜索树——B树</h2><ol>
<li>Definition : A Btree of order m is an m-way search tree. If the  Btree is not empty, the corresponding extended tree satisfies the  following properties:m阶的B树是一个m叉搜索树。如果B树不为空，则B树有相应的扩展属性:<ol>
<li>the root has at least <strong>two</strong> children(每个根结点至少有两个子女)</li>
<li>all internal nodes other than the root have at least m&#x2F;2(向上取整) children(所有内节点都至少有m&#x2F;2(向上取整)个子结点)</li>
<li>all external nodes are at the same level(所有的外节点必须都在同一层)</li>
</ol>
</li>
<li>Eg.</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/22.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/22.png"><span class="image-caption">img</span></a></p>
<ol>
<li>早一点的数据库用的是B树，现在大数据数据库是B+树。</li>
<li>Eg1. In a Btree of order 2, each internal node has at least 2  children, and all external nodes must be on the same level, so a Btree  of order 2 is full binary trees  (在二阶B树中，每一个内部节点都有至少2个子女，并且所有的外部节点都必须在同一级上，所以2阶B树是满阶二叉树)</li>
<li>Eg2. In a Btree of order 3(sometimes also called 2-3 tree), each  internal node has 2 or 3 children(在三阶B树中(通常被我们叫做2-3树)，每一个内部节点有2个或者3个子女)</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/23.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/23.png"><span class="image-caption">img</span></a></p>
<h3 id="3-2-1-B树性质"><a href="#3-2-1-B树性质" class="headerlink" title="3.2.1. B树性质"></a>3.2.1. B树性质</h3><ol>
<li>外节点个数是总共的k值加一</li>
<li>all external nodes are on the same level(所有的外部结点都有相同的层数)</li>
<li>number of external nodes &#x3D; number of keywords + 1(外部节点的个数等于关键字个数+1)<ul>
<li>证明:b1(第一层节点数，不分内外) &#x3D; k0 + 1,  b2 &#x3D; k1 + b1,b3 &#x3D; k2 + b2, …… , 外部结点&#x3D;kh-1+kh-2+…+k1+k0+1&#x3D;n+1</li>
<li>总的来说就是使用归纳的方法来做</li>
</ul>
</li>
</ol>
<h3 id="3-2-2-B树搜索算法"><a href="#3-2-2-B树搜索算法" class="headerlink" title="3.2.2. B树搜索算法"></a>3.2.2. B树搜索算法</h3><ol>
<li>A Btree is searched using the same algorithm as used for an m-way search tree. B树的搜索算法和m叉搜索树的搜索算法是一样的。</li>
<li>Algorithm analysis:(算法分析)<ul>
<li>the number of disk access is at most h(h is the height of the BTree).(对于高度为h的B树，访问磁盘的次数最多为h次)</li>
<li>proof: T is a BTree of order m with height h, number of elements in T is n, each time we read a node into memory. The n+1 external nodes are  on level h.(T是m阶高度为h的B树，在T中的结点个数为n，每一次我们把一个结点读入内存。那么n+1个外部结点在第h层)</li>
</ul>
</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/24.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/24.png"><span class="image-caption">img</span></a></p>
<ol>
<li>考虑最坏情况下的B树的搜索算法</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/25.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/25.png"><span class="image-caption">img</span></a></p>
<h3 id="3-2-3-B树插入算法"><a href="#3-2-3-B树插入算法" class="headerlink" title="3.2.3. B树插入算法"></a>3.2.3. B树插入算法</h3><ol>
<li>B树的插入问题经常发生在外部结点的上一层</li>
</ol>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><ol>
<li>做插入的时候优先插入叶节点:<ul>
<li>如果叶节点还没有满的时候，直接插入即可</li>
<li>如果叶节点已经满了的时候，会进行分类，将中间节点的一个值拉到上级结点(这个结点在中间)。</li>
</ul>
</li>
<li>Insert into a node with m children (also called a full node), like  insert 25 into the BTree in the last example, the full node is split  into two nodes.(插入到一个有m个子结点的节点中，比如25插入上面那个例子中，满了的节点会分裂成两个节点,就是把<strong>中间的提升，将剩下的裂开</strong>)</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/31.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/31.png"><span class="image-caption">img</span></a></p>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/32.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/32.png"><span class="image-caption">img</span></a></p>
<ol>
<li>A new pointer will be added to the parent of the full node.(一个新的指针会被添加指向满了的结点的父结点)</li>
<li>Because km&#x2F;2(向上取整) is inserted into parent node, it may cause new split. If the root is split,the height of the tree will increased by 1.(因为km&#x2F;2(向上取整))</li>
</ol>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><ol>
<li>If the insert operation causes s node to split, the number of disk  access is h (to read in the nodes on the search path) +2s (to write out  the two split parts of each   node that is split) +1 (to write the new  node).</li>
<li>如果插入操作会导致s个结点进行分裂，那么磁盘查找次数为 树高h(在搜索路径上读，查找)+2s(写入2s次的分裂)+1(有可能是创建新的结点，也可能是修改一个节点)</li>
</ol>
<h3 id="3-2-4-B树的删除算法"><a href="#3-2-4-B树的删除算法" class="headerlink" title="3.2.4. B树的删除算法"></a>3.2.4. B树的删除算法</h3><ol>
<li><p>首先判断删除的关键码是否都在B树中，不在的话直接退出。</p>
</li>
<li><p>case1:The element to be deleted is in a node whose children are  external nodes(i.e.the element is in a  leaf)(将要被删除的元素的关键码的子节点是外部结点[小正方形])</p>
<ul>
<li>如果有超过(m&#x2F;2)(向上取整)个关键码，直接删除</li>
<li>如果关键码个数不足(m&#x2F;2)(向上取整)个，那么向邻居<strong>借关键码</strong>（也要向上借），如果够借，那么进行调整。如果不够借，那么合并邻居与此节点(还要拉下来一个上级节点的关键码)，这样子也可能会导致上级节点的关键码不足，如果根节点合并，则其高度被减少1。</li>
</ul>
</li>
<li><p>case2: The element is to be deleted from a nonleaf. (要被删除的结点是一个非叶节点)</p>
<ul>
<li>删除这个节点</li>
<li>把这个节点替换成右子树中的最小关键码(或者左子树中的最大关键码)</li>
<li>因为相当于删除了右子树的最小关键码(或者左子树中的最大关键码)，所以重复删除叶结点关键码的操作。</li>
</ul>
</li>
<li><p>找邻居借关键码的例子:</p>
<p>向邻居借关键码，347 -&gt; 353,353 -&gt; 下面</p>
</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/29.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/29.png"><span class="image-caption">img</span></a></p>
<ol>
<li>删除后两部分合并的例子:</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/33.png"><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/33.png"><span class="image-caption">img</span></a></p>
<h2 id="3-3-B树的实现"><a href="#3-3-B树的实现" class="headerlink" title="3.3. B树的实现"></a>3.3. B树的实现</h2><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/30.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/30.png"><span class="image-caption">img</span></a></p>
<ol>
<li>S is the number of elements in the node(是节点的元素的个数)</li>
<li>ei are the elements in ascending order of key(将元素按照键值升序排列)</li>
<li>ci are children pointers(子树结点)</li>
</ol>
<h1 id="4-B-tree"><a href="#4-B-tree" class="headerlink" title="4. B+ tree"></a>4. B+ tree</h1><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/34.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/34.png"><span class="image-caption">img</span></a></p>
<ol>
<li>和B树不同的地方:<ol>
<li>关键码的分布，<strong>只分布在叶结点</strong>上</li>
<li>叶结点的定义,不一定符合m阶，它依赖于关键码字节数与指针字节数而为m1</li>
</ol>
</li>
</ol>
<h2 id="4-1-B-tree的定义"><a href="#4-1-B-tree的定义" class="headerlink" title="4.1. B+ tree的定义"></a>4.1. B+ tree的定义</h2><ol>
<li>树中每个非叶结点最多有m棵子树</li>
<li>根结点(非叶结点)至少有2棵子树</li>
<li>除根结点外，每个非叶结点至少有(m&#x2F;2)(向上取整)棵子树；有n棵子树的非叶结点有n-1个关键码</li>
<li>所有叶结点都处于同一层次上，包含了全部关键码及指向相应数据对象存放地址，关键码按关键码从小到大顺序链接</li>
<li>每个叶结点中  子树棵树n可以＞m，也可以＜m。 假设叶结点可容纳的最大关键码数为m1，则指向对象的指针数也有m1，这时子树棵数n应满足((m1&#x2F;2)(向上取整)，m1)</li>
<li>根结点本身又是叶结点，则结点格式同叶结点</li>
</ol>
<h2 id="4-2-B-tree的特点"><a href="#4-2-B-tree的特点" class="headerlink" title="4.2. B+ tree的特点"></a>4.2. B+ tree的特点</h2><ol>
<li>有两个头指针</li>
<li>一个指向B+树的根结点，可以进行自顶向下的随机搜索</li>
<li>一个指向关键码最小的叶结点，进行顺序搜索；</li>
<li>保证树过深，用来进行平衡</li>
</ol>
<h2 id="4-3-B-tree的运算"><a href="#4-3-B-tree的运算" class="headerlink" title="4.3. B+ tree的运算"></a>4.3. B+ tree的运算</h2><h2 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h2><p>基本上同B树，所不同的是<strong>一直查到叶结点</strong>上的这个关键码为止</p>
<p>不会中途停止</p>
<h2 id="插入算法"><a href="#插入算法" class="headerlink" title="插入算法"></a>插入算法</h2><ol>
<li>仅在叶结点上进行。每插入一关键码，判别子树棵树＞m1，如果大于，则将该结点分裂：((m1+1)&#x2F;2)(向上取整)，((m1+1)&#x2F;2)(向上取整)</li>
<li>问题变为传递到索引结点上可能的分裂，这时上限以m来确定(同B-树)</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/35.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/35.png"><span class="image-caption">img</span></a><br> <a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/36.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/36.png"><span class="image-caption">img</span></a></p>
<h2 id="删除算法-1"><a href="#删除算法-1" class="headerlink" title="删除算法"></a>删除算法</h2><ol>
<li>在叶结点上删除一个关键码后要保证结点中的子树棵数仍然不小 于(m1&#x2F;2)(向上取整).</li>
<li>删除操作与B树类似，但<strong>上层索引中的关键码可保留，作为引导搜索的”分界关键码”的作用.</strong></li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/37.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/37.png"><span class="image-caption">img</span></a><br> <a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/38.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt6/38.png"><span class="image-caption">img</span></a></p>
<h1 id="5-题目"><a href="#5-题目" class="headerlink" title="5. 题目"></a>5. 题目</h1><ol>
<li>第9题:<ul>
<li>邻居的60及它左侧的55被一同借过去</li>
<li>20和30成为一个节点，同级的有55，上层50</li>
<li>直接删除40,60((50((20,30),55)),80(70,95))</li>
</ul>
</li>
</ol>
<h1 id="6-其他参考以及扩展学习"><a href="#6-其他参考以及扩展学习" class="headerlink" title="6. 其他参考以及扩展学习"></a>6. 其他参考以及扩展学习</h1><ol>
<li><a href="https://mp.weixin.qq.com/s/9dRBJRCudGv11F7rSaqJEQ">掌握此文，面试再也不怕红黑树！</a></li>
</ol>
<p>​        </p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-图-学习笔记</title>
    <url>/2023/01/10/algorithm-Lecture%208%20%E5%9B%BE/</url>
    <content><![CDATA[<p>部分图算法学习</p>
<span id="more"></span>



<h2 id="Graphs"><a href="#Graphs" class="headerlink" title="Graphs"></a>Graphs</h2><h1 id="1-图的定义"><a href="#1-图的定义" class="headerlink" title="1. 图的定义"></a>1. 图的定义</h1><ol>
<li>Graph &#x3D; (V, E)<ol>
<li>V: nonempty finite <strong>vertice</strong> set(顶点集)  一个非空确定顶点个数的集合</li>
<li>E: <strong>edge</strong> set(边集)</li>
</ol>
</li>
</ol>
<h2 id="1-1-有向图"><a href="#1-1-有向图" class="headerlink" title="1.1. 有向图"></a>1.1. 有向图</h2><ol>
<li>If the tuple denoting an edge is ordered, then &lt;v1,v2&gt; and &lt;v2,v1&gt; are different edges. (如果表示的边的<strong>元组是有序</strong>的，也就是&lt;v1,v2&gt;和&lt;v2,v1&gt;是不同的)</li>
<li>v1: 有向图边的始点</li>
<li>v2: 有向图边的终点</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/1.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/1.png"><span class="image-caption">img</span></a></p>
<ol>
<li>In a directed graph with n nodes, the number of edges &lt;&#x3D;n*(n-1).  If “&#x3D;” is satisfied, then it is called a complete directed  graph.(一个有n个节点的有向图，其边的个数&lt;&#x3D; n*(n-1)，如果相等，则为是一个完全有向图)</li>
<li>完全图(有向完全图):指有向图中每两个顶点都相互指向。</li>
</ol>
<h2 id="1-2-无向图"><a href="#1-2-无向图" class="headerlink" title="1.2. 无向图"></a>1.2. 无向图</h2><ol>
<li>If the tuple denoting an edge is unordered, then (v1,v2) and (v2,v1) are the same edge.(如果表示边的<strong>元组是无序</strong>的，则(v1，v2)和(v2，v1)是相同的边。)</li>
<li>In an undirected graph with n nodes,  the number of edges &lt;&#x3D;  n*(n-1)&#x2F;2. If “&#x3D;” is satisfied, then it is called a complete undirect  graph.(在一个有n个顶点的无向图中，边的个数 &lt;&#x3D; n(n-1)&#x2F;2，如果刚好相等，则被称为完全无向图)</li>
<li>完全图(无向完全图):就是指每两个顶点之间都有一条边。</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/2.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/2.png"><span class="image-caption">img</span></a></p>
<h2 id="1-3-其他图"><a href="#1-3-其他图" class="headerlink" title="1.3. 其他图"></a>1.3. 其他图</h2><ol>
<li>以下两种图在我们的数据结构中不进行讨论</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/3.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/3.png"><span class="image-caption">img</span></a></p>
<ol>
<li>不考虑 自环(ring) 和 多重边 的多重图。</li>
<li>完全图分为有向和无向</li>
</ol>
<h2 id="1-4-顶点的度数"><a href="#1-4-顶点的度数" class="headerlink" title="1.4. 顶点的度数"></a>1.4. 顶点的度数</h2><ol>
<li>对于无向图只有度数，而对于有向图不仅仅有入度，还有出度。</li>
<li>degree dv of vertex v, TD(v): is the number of edges incident on vertex v. In a directed graph :(顶点v的度数为dv，TD(V)是顶点v的度数，在有向图中)<ol>
<li><strong>in-degree</strong> of vertex v is the number of edges incident to v, ID(v).(顶点v的入度是指向顶点v的边的个数)</li>
<li>out-degree of vertex v is the number of edges incident from the v, OD(v). (顶点v的出度从v出发的边的个数)</li>
</ol>
</li>
<li>性质:(度数)TD(v)&#x3D;ID(v)+OD(v)（total degree）</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/4.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/4.png"><span class="image-caption">img</span></a></p>
<h2 id="1-5-图的性质"><a href="#1-5-图的性质" class="headerlink" title="1.5. 图的性质"></a>1.5. 图的性质</h2><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/9.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/9.png"><span class="image-caption">img</span></a></p>
<ol>
<li>所有的度数加起来是边的个数的两倍。</li>
</ol>
<h2 id="1-6-子图"><a href="#1-6-子图" class="headerlink" title="1.6. 子图"></a>1.6. 子图</h2><ol>
<li>Graph G&#x3D;(V,E),G’&#x3D;(V‘,E‘), if V’包含于V, E’包含于E, and the vertices  incident on the edges in E’ are in V’, then G’ is the subgraph of G. For example: 如果图G和图G’，如果V’包含于V，E’包含于E,并且E’中顶点的边也在G’中，那么G’是G的子图</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/5.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/5.png"><span class="image-caption">img</span></a></p>
<h2 id="1-7-路径-path"><a href="#1-7-路径-path" class="headerlink" title="1.7. 路径(path)"></a>1.7. 路径(path)</h2><ol>
<li>A sequence of vertices P&#x3D;i1,i2,……ik is an i1 to ik path in the graph of graph G&#x3D;(V,E) iff the edge(ij,ij+1)is in E for every j, 1 &lt;&#x3D; j &lt; k.</li>
</ol>
<p>​	(在图 G&#x3D;(V，E)中，如果每j的边(ij，ij+1)在E中，1&lt;&#x3D; j&lt; k，则顶点序列P&#x3D;i1，i2，…,ik是i1到ik的路径。)</p>
<h2 id="1-8-简单路径和环-Simple-path-and-cycle"><a href="#1-8-简单路径和环-Simple-path-and-cycle" class="headerlink" title="1.8. 简单路径和环(Simple path and cycle)"></a>1.8. 简单路径和环(Simple path and cycle)</h2><ol>
<li>A Simple path is a path in which all vertices except possibly the first and last , are different.(<strong>简单路径</strong> : 路径除了第一个和最后一个顶点中<strong>没有出现相同</strong>的顶点)</li>
<li>A Simple cycle is a simple path with the same start and end vertex.(简单回路:起点和终点相同的时候的简单路径)</li>
</ol>
<h2 id="1-9-连通图和连通分量-Connected-graph-amp-Connected-component"><a href="#1-9-连通图和连通分量-Connected-graph-amp-Connected-component" class="headerlink" title="1.9. 连通图和连通分量(Connected graph &amp; Connected component)"></a>1.9. 连通图和连通分量(Connected graph &amp; Connected component)</h2><ol>
<li>In a undirected graph, if there is a path from vertex v1 to v2, then v1 and v2 are connected.(在无向图中，如果v1到v2之间有一条路径，那么v1和v2是连通的)</li>
<li>In a undirected graph ,if two arbitrary vertices are connected, then the graph is a connected graph(在无向图中，如果任意两个顶点是连通的，则该图是连通图)</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/6.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/6.png"><span class="image-caption">img</span></a></p>
<ol>
<li>极大连通子图<strong>Maximum connected</strong>  <strong>subgraph</strong>就是结点个数最多的连通的子图。</li>
</ol>
<h2 id="1-10-强联通图和强联通分量-Strong-connected-graph-and-strongly-connected-component"><a href="#1-10-强联通图和强联通分量-Strong-connected-graph-and-strongly-connected-component" class="headerlink" title="1.10. 强联通图和强联通分量(Strong connected graph and strongly connected component)"></a>1.10. 强联通图和强联通分量(Strong connected graph and strongly connected component)</h2><ol>
<li><p>A digraph is strongly connected iff it contains a <strong>directed path</strong> from i to j and from j to i for every pair of distinct vertices i and  j.</p>
<ol>
<li>(有向图是强连通的，当它包含从 i 到 j 和从 j 到 i 的有向路径时，对于每对不同的顶点 i 和 j)。</li>
<li>简单来说就是<strong>既要过的去，也要回得来</strong></li>
</ol>
</li>
<li><p>The maximum strong connected subgraph (极大强连通子图) of a non-strongly  connected graph is called strongly connected conponent  (强连通分量).</p>
<ol>
<li>(一个非强连通图的最大强连通子图(South-South-PosialSuth-Posiple  Fug)称为强连通分量).</li>
</ol>
</li>
</ol>
<h2 id="1-11-加权图-Network"><a href="#1-11-加权图-Network" class="headerlink" title="1.11. 加权图(Network)"></a>1.11. 加权图(Network)</h2><ol>
<li>When weights and costs are assigned to edges, the resulting data  object is called weighted graph and weighted  digraph.(当权值和代价分配给边时，得到的数据对象称为加权图和加权有向图。)</li>
<li>The term network refers to weighted  connected graph and weighted connected digraph. (网络是用来代指加权连通图和加权连通有向图)</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/7.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/7.png"><span class="image-caption">img</span></a></p>
<h2 id="1-12-生成树-Spanning-tree"><a href="#1-12-生成树-Spanning-tree" class="headerlink" title="1.12. 生成树(Spanning tree)"></a>1.12. 生成树(Spanning tree)</h2><ol>
<li><p>A spanning tree of a connected graph is its minimum connected subgraph(最小连通子图).  An n-vertex spanning tree has n-1 edges. (</p>
<p>连通图的生成树是其<strong>最小连通子图</strong>。n顶点生成树有n-1条边。</p>
<p>)</p>
<ul>
<li>保持联通的最小边数的图</li>
</ul>
</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/8.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/8.png"><span class="image-caption">img</span></a></p>
<h1 id="2-ADT-Graph-and-Digraph-无向图和无向图的抽象逻辑"><a href="#2-ADT-Graph-and-Digraph-无向图和无向图的抽象逻辑" class="headerlink" title="2. ADT Graph and Digraph 无向图和无向图的抽象逻辑"></a>2. ADT Graph and Digraph 无向图和无向图的抽象逻辑</h1><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">AbstractDataType Graph &#123;<br>    instances 实例<br>        a set V <span class="hljs-keyword">of</span> vertices <span class="hljs-keyword">and</span> a set E <span class="hljs-keyword">of</span> edges 顶点集合V 和 边集E<br>    operations 操作<br>        <span class="hljs-constructor">Create(<span class="hljs-params">n</span>)</span>:create an undirected graph <span class="hljs-keyword">with</span> n vertices <span class="hljs-keyword">and</span> no edges 创建一个n个顶点没有边的无向图<br>        <span class="hljs-constructor">Exist(<span class="hljs-params">i</span>,<span class="hljs-params">j</span>)</span>: return <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> edge(i,j)exists; <span class="hljs-literal">false</span> otherwise 当且仅当存在边i、j的时候返回<span class="hljs-literal">true</span><br>        <span class="hljs-constructor">Edges()</span>:return the number <span class="hljs-keyword">of</span> edges <span class="hljs-keyword">in</span> the graph 返回图的边的个数<br>        <span class="hljs-constructor">Vertices()</span>:return the number <span class="hljs-keyword">of</span> vertices <span class="hljs-keyword">in</span> the graph 返回图的顶点个数<br>        <span class="hljs-constructor">Add(<span class="hljs-params">i</span>,<span class="hljs-params">j</span>)</span>: add the edge(i,j) <span class="hljs-keyword">to</span> the graph 将i、j边添加到图中<br>        <span class="hljs-constructor">Delete(<span class="hljs-params">i</span>,<span class="hljs-params">j</span>)</span>:delete the edge (i,j) 删除边i、j <br>        <span class="hljs-constructor">Degree(<span class="hljs-params">i</span>)</span>: return the degree <span class="hljs-keyword">of</span> vertex i 返回顶点i的度数<br>        <span class="hljs-constructor">InDegree(<span class="hljs-params">i</span>)</span>: synonym <span class="hljs-keyword">for</span> degree 和度数相同<br>        <span class="hljs-constructor">OutDegree(<span class="hljs-params">i</span>)</span>: synonym <span class="hljs-keyword">for</span> degree 和度数相同&#125;<br></code></pre></td></tr></table></figure>

<h1 id="3-图的表示与实现-Representation-of-graphs-and-digraphs"><a href="#3-图的表示与实现-Representation-of-graphs-and-digraphs" class="headerlink" title="3. 图的表示与实现(Representation of graphs and digraphs)"></a>3. 图的表示与实现(Representation of graphs and digraphs)</h1><ol>
<li>有向图(graphs)</li>
<li>无向图(digraphs)</li>
</ol>
<h2 id="3-1-邻接矩阵-Adjacency-Matrix"><a href="#3-1-邻接矩阵-Adjacency-Matrix" class="headerlink" title="3.1. 邻接矩阵(Adjacency Matrix)"></a>3.1. 邻接矩阵(Adjacency Matrix)</h2><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/10.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/10.png"><span class="image-caption">img</span></a></p>
<ol>
<li>无向图的邻接矩阵</li>
<li><strong>无向图的每个顶点的度数等于矩阵中每一行的和</strong>。</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/11.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/11.png"><span class="image-caption">img</span></a></p>
<ol>
<li>有向图的邻接矩阵<ul>
<li><strong>出度对行求和</strong></li>
<li><strong>入度对列求和</strong></li>
</ul>
</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/13.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/13.png"><span class="image-caption">img</span></a></p>
<ol>
<li>加权图(网络)的邻接矩阵<ul>
<li>注意使用的无穷标识没有通路</li>
</ul>
</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/14.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/14.png"><span class="image-caption">img</span></a><br> <a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/15.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/15.png"><span class="image-caption">img</span></a></p>
<ol>
<li>当节点数很大，边很少的时候不适用于邻接矩阵。</li>
</ol>
<h3 id="3-1-1-邻接矩阵性质"><a href="#3-1-1-邻接矩阵性质" class="headerlink" title="3.1.1. 邻接矩阵性质"></a>3.1.1. 邻接矩阵性质</h3><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/12.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/12.png"><span class="image-caption">img</span></a></p>
<ol>
<li>无向图的邻接矩阵是对称的。</li>
</ol>
<h2 id="3-2-其他需要的结构"><a href="#3-2-其他需要的结构" class="headerlink" title="3.2. 其他需要的结构"></a>3.2. 其他需要的结构</h2><ol>
<li>一个记录各顶点信息的表</li>
<li>一个当前的边数</li>
</ol>
<h2 id="3-3-邻接矩阵实现的代码"><a href="#3-3-邻接矩阵实现的代码" class="headerlink" title="3.3. 邻接矩阵实现的代码"></a>3.3. 邻接矩阵实现的代码</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">const <span class="hljs-built_in">int</span> MaxNumEdges = <span class="hljs-number">50</span><span class="hljs-comment">// 最大边数</span><br>const <span class="hljs-built_in">int</span> MaxNumVertices = <span class="hljs-number">10</span><span class="hljs-comment">//最大顶点数 </span><br>template&lt;<span class="hljs-keyword">class</span> NameType, <span class="hljs-keyword">class</span> DistType&gt; <span class="hljs-keyword">class</span> Graph&#123;<br>    <span class="hljs-keyword">private</span>:<br>        SeqList&lt;NameType&gt; <span class="hljs-constructor">VerticesList(MaxNumVertices)</span> <span class="hljs-comment">//顶点表</span><br>        DistType Edge <span class="hljs-literal">[M<span class="hljs-identifier">axNumVertices</span>]</span> <span class="hljs-literal">[M<span class="hljs-identifier">axNumVertices</span>]</span>  <span class="hljs-comment">//邻接矩阵，一定是方阵</span><br>        <span class="hljs-built_in">int</span> CurrentEdges;<span class="hljs-comment">//当前边数</span><br>        <span class="hljs-built_in">int</span> FindVertex (Seqlist &lt;NameType&gt; &amp;L; const  NameType &amp;Vertex)<br>            &#123;return L.<span class="hljs-constructor">Find(Vertex)</span>;&#125;<br>        <span class="hljs-built_in">int</span> GetVertexPos (const NameTyoe &amp;Vertex)<br>            &#123;return <span class="hljs-constructor">FindVertex(VerticesList)</span>;&#125;<span class="hljs-comment">// 给出了顶点Vertex在图中的位置</span><br>    public:<br>        Graph (const <span class="hljs-built_in">int</span> sz=MaxNumEdges); <br>        <span class="hljs-built_in">int</span> <span class="hljs-constructor">GraphEmpty()</span> const&#123;return VerticesList.<span class="hljs-constructor">IsEmpty()</span>;&#125;<br>        <span class="hljs-built_in">int</span> <span class="hljs-constructor">GraphFull()</span> const&#123;return VerticesList.<span class="hljs-constructor">IsFull()</span><span class="hljs-operator"> || </span>CurrentEdges= =MaxNumEdges;&#125;<br><br>        <span class="hljs-built_in">int</span> <span class="hljs-constructor">NumberofVertices()</span>&#123;return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">VerticesList</span>.</span></span>last;&#125;<br>        <span class="hljs-built_in">int</span> <span class="hljs-constructor">NumberofEdges()</span> &#123;return CurrentEdges;&#125;<br>        NameType <span class="hljs-constructor">Getvalue(<span class="hljs-params">const</span> <span class="hljs-params">int</span> <span class="hljs-params">i</span>)</span> &#123;return  i&gt;=<span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>i&lt;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">VerticesList</span>.</span></span>last ? <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">VerticesList</span>.</span></span>data<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> :  NULL;&#125; <br>        DistType Getweight (const <span class="hljs-built_in">int</span> v1,const <span class="hljs-built_in">int</span> v2);<br>        <br>        <span class="hljs-built_in">int</span> <span class="hljs-constructor">GetFirstNeighbor(<span class="hljs-params">const</span> <span class="hljs-params">int</span> <span class="hljs-params">v</span>)</span>; <br>        <span class="hljs-built_in">int</span> <span class="hljs-constructor">GetNextNeighbor(<span class="hljs-params">const</span> <span class="hljs-params">int</span> <span class="hljs-params">v1</span>,<span class="hljs-params">const</span> <span class="hljs-params">int</span> <span class="hljs-params">v2</span>)</span>;<br>        <br>        void <span class="hljs-constructor">InsertVertex(<span class="hljs-params">const</span> NameType &amp; Vertex)</span>;<br>        void <span class="hljs-constructor">InsertEdge(<span class="hljs-params">const</span> <span class="hljs-params">int</span> <span class="hljs-params">v1</span>,<span class="hljs-params">const</span> <span class="hljs-params">int</span> <span class="hljs-params">v2</span>, DistType <span class="hljs-params">weight</span>)</span>;<br>        void remove<span class="hljs-constructor">Vertex(<span class="hljs-params">const</span> <span class="hljs-params">int</span> <span class="hljs-params">v</span>)</span>;<br>        void remove<span class="hljs-constructor">Edge(<span class="hljs-params">cosnt</span> <span class="hljs-params">int</span> <span class="hljs-params">v1</span>,<span class="hljs-params">const</span> <span class="hljs-params">int</span> <span class="hljs-params">v2</span>)</span>;<br>&#125; <br></code></pre></td></tr></table></figure>

<h3 id="3-3-1-需要实现的方法"><a href="#3-3-1-需要实现的方法" class="headerlink" title="3.3.1. 需要实现的方法"></a>3.3.1. 需要实现的方法</h3><ol>
<li>构造方法</li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">NameType, <span class="hljs-symbol">class</span></span> <span class="hljs-symbol">DistType</span>&gt; <span class="hljs-symbol">Graph</span>&lt;<span class="hljs-symbol">NameType, <span class="hljs-symbol">DistType</span></span>&gt;::<span class="hljs-symbol">Graph</span>(<span class="hljs-symbol">int</span> <span class="hljs-symbol">sz</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;sz;i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>; j&lt;sz; j++)<br>            Edge [i][j]=<span class="hljs-number">0</span>;<br>    currentEdge=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//进行图结构的初始化</span><br>    <span class="hljs-comment">//边数组的默认初始化值均为0</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>求顶点V的第一个邻接顶点的位置</li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">NameType, <span class="hljs-symbol">class</span></span> <span class="hljs-symbol">DistType</span>&gt; <span class="hljs-symbol">int</span> <span class="hljs-symbol">Graph</span>&lt;<span class="hljs-symbol">NameType, <span class="hljs-symbol">DistType</span></span>&gt;::<span class="hljs-symbol">GetFirstNeighbor</span>(<span class="hljs-symbol">int</span> <span class="hljs-symbol">v</span>) &#123;<br>    <span class="hljs-keyword">if</span> (v!=<span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> col=<span class="hljs-number">0</span>; col&lt;CurrentVertices; col++)<br>            <span class="hljs-keyword">if</span> (Edge[v][col]&gt;<span class="hljs-number">0</span> &amp;&amp; Edge[v][col]&lt;max)<br>                <span class="hljs-keyword">return</span> col;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-4-邻接表实现"><a href="#3-4-邻接表实现" class="headerlink" title="3.4. 邻接表实现"></a>3.4. 邻接表实现</h2><ol>
<li>reduce the storage requirement if the number of edges in the graph is small.当无向图中的边的个数比较少的时候，降低存储需要的空间的量</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/16.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/16.png"><span class="image-caption">img</span></a></p>
<ol>
<li>Eg.无向图的例子<ul>
<li>cost是指权重</li>
</ul>
</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/17.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/17.png"><span class="image-caption">img</span></a></p>
<h3 id="3-4-1-邻接表的声明"><a href="#3-4-1-邻接表的声明" class="headerlink" title="3.4.1. 邻接表的声明"></a>3.4.1. 邻接表的声明</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//邻接表的声明</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Defaultsize = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NameType</span>，<span class="hljs-keyword">class</span> <span class="hljs-title class_">DistType</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span>;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">DistType</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>       <span class="hljs-comment">//边的定义 &#123;</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &lt;NameType,DistType&gt;;<span class="hljs-comment">//友元函数</span><br>    <span class="hljs-type">int</span> dest;<span class="hljs-comment">//边的另一顶点在顶点表中的位置 </span><br>    DistType cost;<span class="hljs-comment">//边上的权</span><br>    Edge&lt;DistType&gt; *link;<span class="hljs-comment">//下一条边的链指针</span><br>    <span class="hljs-built_in">Edge</span>() &#123;&#125;<br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> D,DistType C):<span class="hljs-built_in">dest</span>(D),<span class="hljs-built_in">cost</span>(C),<span class="hljs-built_in">link</span>(<span class="hljs-literal">NULL</span>)&#123;&#125;<br>    <span class="hljs-type">int</span> operate != (<span class="hljs-type">const</span> Edge&lt;DistType&gt; &amp;E) <span class="hljs-type">const</span> <br>    &#123;<span class="hljs-keyword">return</span> dest != E.dest; &#125;<br>&#125;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NameType</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistType</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vertex</span> &#123;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Edge</span>&lt;DistType&gt;;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span>&lt;NameType, DistType&gt;; <br>    NameType data;<span class="hljs-comment">//顶点名字</span><br>    Edge&lt;DistType&gt; *adj;<span class="hljs-comment">//出边表头指针</span><br>&#125; <br></code></pre></td></tr></table></figure>

<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/18.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/18.png"><span class="image-caption">img</span></a></p>
<h3 id="3-4-2-图的类定义"><a href="#3-4-2-图的类定义" class="headerlink" title="3.4.2. 图的类定义"></a>3.4.2. 图的类定义</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//图的类定义</span><br>template&lt;<span class="hljs-keyword">class</span> NameType，<span class="hljs-keyword">class</span> DistType&gt; <span class="hljs-keyword">class</span> Graph &#123;<br>    <span class="hljs-keyword">private</span>:<br>        Vertex&lt;NameType, DistType&gt; *NodeTable; <span class="hljs-comment">//顶点表</span><br>        <span class="hljs-built_in">int</span> NumVertices;<span class="hljs-comment">//当前顶点数</span><br>        <span class="hljs-built_in">int</span> MaxNumVertices;<span class="hljs-comment">//最大顶点个数</span><br>        <span class="hljs-built_in">int</span> NumEdges;<span class="hljs-comment">//当前边数</span><br>        <span class="hljs-built_in">int</span> <span class="hljs-constructor">GetVertexpos(<span class="hljs-params">const</span> Type &amp;Vertex)</span>;<br>    public:<br>        <span class="hljs-constructor">Graph(<span class="hljs-params">int</span> <span class="hljs-params">sz</span>)</span>;<br>        ~<span class="hljs-constructor">Graph()</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-constructor">GraphEmpty()</span> const &#123;return NumVertices= =<span class="hljs-number">0</span>;&#125;<br>        <span class="hljs-built_in">int</span> <span class="hljs-constructor">GraphFull()</span> const &#123;return NumVertices= =MaxNumVertices;&#125;<br>        <span class="hljs-built_in">int</span> <span class="hljs-constructor">NumberOfVertices()</span> &#123;return NumVertices;&#125;<br>        <span class="hljs-built_in">int</span> <span class="hljs-constructor">NumberOfEdges()</span> &#123;return NumEdges;&#125;<br>        NameType <span class="hljs-constructor">GetValue(<span class="hljs-params">const</span> <span class="hljs-params">int</span> <span class="hljs-params">i</span>)</span> &#123;return i&gt;=<span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>i&lt;NumVertices ? NodeTable<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.data: NULL;&#125;<br>        void <span class="hljs-constructor">InsertVertex(<span class="hljs-params">const</span> NameType &amp;Vertex)</span>;<br>        void <span class="hljs-constructor">RemoveVertex(<span class="hljs-params">int</span> <span class="hljs-params">v</span>)</span>;<br>        void <span class="hljs-constructor">InsertEdge(<span class="hljs-params">int</span> <span class="hljs-params">v1</span>,<span class="hljs-params">int</span> <span class="hljs-params">v2</span>,DistType <span class="hljs-params">weight</span>)</span>;<br>        void <span class="hljs-constructor">RemoveEdge(<span class="hljs-params">int</span> <span class="hljs-params">v1</span>,<span class="hljs-params">int</span> <span class="hljs-params">v2</span>)</span>; <br>        DistType <span class="hljs-constructor">Getweight(<span class="hljs-params">int</span> <span class="hljs-params">v1</span>,<span class="hljs-params">int</span> <span class="hljs-params">v2</span>)</span>; <br>        <span class="hljs-built_in">int</span> <span class="hljs-constructor">GetFristNeighbor(<span class="hljs-params">int</span> <span class="hljs-params">v</span>)</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-constructor">GetNextNeighbor(<span class="hljs-params">int</span> <span class="hljs-params">v1</span>,<span class="hljs-params">int</span> <span class="hljs-params">v2</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-4-3-部分实现的方法"><a href="#3-4-3-部分实现的方法" class="headerlink" title="3.4.3. 部分实现的方法"></a>3.4.3. 部分实现的方法</h3><ol>
<li>构造方法</li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">NameType,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">DistType</span>&gt; <span class="hljs-symbol">Graph</span>&lt;<span class="hljs-symbol">NameType,<span class="hljs-symbol">DistType</span></span>&gt;::<span class="hljs-symbol">Graph</span>(<span class="hljs-symbol">int</span> <span class="hljs-symbol">sz</span>=<span class="hljs-symbol">Defaultsize</span>):<br><span class="hljs-symbol">NumVertices</span>(<span class="hljs-symbol">0</span>),<span class="hljs-symbol">MaxNumVertices</span>(<span class="hljs-symbol">sz</span>),<span class="hljs-symbol">NumEdge</span>(<span class="hljs-symbol">0</span>) <br>&#123;<br>    <span class="hljs-built_in">int</span> NumVertices, NumEdges, k, j; <br>    NameType name,tail,head;<br>    DistType weight; <br>    NodeTable=newVertex&lt;NameType&gt;[MaxNumVertices]<br>    <br>    cin &gt;&gt; NumVertices;<span class="hljs-comment">//输入顶点数</span><br>    <span class="hljs-keyword">for</span>( <span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;NumVertices; i++ ) &#123;  <br>        cin &gt;&gt; name;<br>        InsertVertex(name);<br>    &#125;<br>    cin &gt;&gt; NumEdges;<span class="hljs-comment">//输入边数</span><br>    <span class="hljs-keyword">for</span>( i=<span class="hljs-number">0</span>; i&lt;NumEdges; i++)&#123; <br>        cin &gt;&gt; tail &gt;&gt; head &gt;&gt; weight;<br>        k=GetVertexpos(tail);<br>        j=GetVertexpos(head);<br>        InsertEdge(k,j,weight);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>根据数据值找到下标</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">int Graph&lt;NameType,DistType&gt;::GetVertexpos(<span class="hljs-keyword">const</span> NameType &amp;Vertex) &#123;<br>    <span class="hljs-keyword">for</span>( int i=<span class="hljs-number">0</span>; i&lt;NumVertices; i++)<br>        <span class="hljs-keyword">if</span> (NodeTable[i].<span class="hljs-keyword">data</span> == Vertex)<br>            <span class="hljs-keyword">return</span> i;<br>    <span class="hljs-keyword">return</span> –<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>给出顶点V的第一个邻接顶点的位置</li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">NameType,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">DistType</span>&gt; <span class="hljs-symbol">int</span> <span class="hljs-symbol">Graph</span>&lt;<span class="hljs-symbol">NameType,<span class="hljs-symbol">DistType</span></span>&gt;::<span class="hljs-symbol">GetFirstNeighbor</span>(<span class="hljs-symbol">int</span> <span class="hljs-symbol">v</span>) &#123;<br>    <span class="hljs-keyword">if</span> (v!=<span class="hljs-number">-1</span>) &#123;<br>        Edge&lt;DistType&gt;* p=NodeTable[v].adj; <br>        <span class="hljs-keyword">if</span> (p!=NULL) <span class="hljs-keyword">return</span> p-&gt;dest;<br>    &#125;<br>    <span class="hljs-keyword">return</span> –<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>找到下一个邻居</li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">NameType,<span class="hljs-symbol">class</span></span> <span class="hljs-symbol">DistType</span>&gt; <span class="hljs-symbol">int</span> <span class="hljs-symbol">Graph</span>&lt;<span class="hljs-symbol">NameType,<span class="hljs-symbol">DistType</span></span>&gt;::<span class="hljs-symbol">GetNextNeighbor</span> (<span class="hljs-symbol">int</span> <span class="hljs-symbol">v1,<span class="hljs-symbol">int</span></span> <span class="hljs-symbol">v2</span>) &#123;<br>    <span class="hljs-keyword">if</span> (v1!=<span class="hljs-number">-1</span>) &#123;<br>        Edge&lt;DistType&gt; *p=NodeTable[v1].adj; <br>        <span class="hljs-keyword">while</span> (p!=NULL) &#123;<br>            <span class="hljs-keyword">if</span>(p-&gt;dest==v2 &amp;&amp; p-&gt;link!=NULL)<br>                <span class="hljs-keyword">return</span> p-&gt;link-&gt;dest;<br>            <span class="hljs-keyword">else</span> p=p-&gt;link;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> –<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-5-邻接多重表"><a href="#3-5-邻接多重表" class="headerlink" title="3.5. 邻接多重表"></a>3.5. 邻接多重表</h2><ol>
<li>在无向图中, 如果边数为m, 则在邻接表表示中需2m个单位来存储. 为了克服这一缺点, 采用邻接多重表, 每条边用一个结点表示.<ul>
<li>其中的两个结点号就是边的两个点。</li>
<li><strong>data部分只记录first-out</strong></li>
<li>path1指向的就是同样始点(vertex1)，顺序终点的结果。</li>
<li>path2执行的是以vertex2为始点顺序向下的。</li>
</ul>
</li>
<li>Eg.使用正常的邻接表，则右边应该有10个点，但是多种表就是只有5个表<ul>
<li>默认情况下边的<strong>始点的编号要小</strong>于终点的编号大小。</li>
</ul>
</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/19.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/19.png"><span class="image-caption">img</span></a></p>
<ol>
<li>对有向图而言，需用邻接表和逆邻接表，如果把这两个表结合起来用有向图的邻接多重表(也称为十字链表)来表示一个有向图.</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/20.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/20.png"><span class="image-caption">img</span></a></p>
<ol>
<li>邻接表和邻接多重表之间的区别在于有几个顶点，有几个边。</li>
<li><strong>data部分只记录first-in和first-ou</strong>t，也就是第一条出边和第一条入边。</li>
</ol>
<h1 id="4-图的遍历和连通性"><a href="#4-图的遍历和连通性" class="headerlink" title="4. 图的遍历和连通性"></a>4. 图的遍历和连通性</h1><ol>
<li>图的遍历 (Graph Traversal): 从图中某一顶点出发访问图中其余顶点,且使每个顶点<strong>仅</strong>被访问一次.</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/21.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/21.png"><span class="image-caption">img</span></a></p>
<ol>
<li>树的遍历，左子女右兄弟。</li>
</ol>
<h2 id="4-1-DFS-depth-first-search-深度优先搜索"><a href="#4-1-DFS-depth-first-search-深度优先搜索" class="headerlink" title="4.1. DFS(depth-first-search,深度优先搜索)"></a>4.1. DFS(depth-first-search,深度优先搜索)</h2><h3 id="4-1-1-算法思想"><a href="#4-1-1-算法思想" class="headerlink" title="4.1.1. 算法思想"></a>4.1.1. 算法思想</h3><ol>
<li>从图中某个顶点V0出发,访问它,然后选择一个<br> V0邻接到的未被访问的一个邻接点V1出发深度优先遍<br> 历图,当<strong>遇到一个所有邻接于它的结点都被访问过了的</strong><br> <strong>结点U时,回退到前一次刚被访问过的拥有未被访问的</strong><br> <strong>邻接点W</strong>,再从W出发深度遍历,……直到连通图中的所<br> 有顶点都被访问过为止.</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/22.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/22.png"><span class="image-caption">img</span></a></p>
<ol>
<li>递归方法实现 算法中用一个辅助数组visited[]:<ol>
<li>0:未访问</li>
<li>1:访问过了</li>
<li>我们假设图为连通图</li>
</ol>
</li>
</ol>
<h3 id="4-1-2-算法实现"><a href="#4-1-2-算法实现" class="headerlink" title="4.1.2. 算法实现"></a>4.1.2. 算法实现</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//利用的是邻接矩阵来表示的图</span><br><span class="hljs-comment">//主过程:</span><br>template&lt;NameType,DistType&gt; <br>void Graph&lt;NameType,DistType&gt;::<span class="hljs-constructor">DFS( )</span> &#123;<br>    <span class="hljs-built_in">int</span> *visited=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[N<span class="hljs-identifier">umVertices</span>]</span>;<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;NumVertices; i++)<br>        visited<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>=<span class="hljs-number">0</span>;<br>        <span class="hljs-constructor">DFS(0,<span class="hljs-params">visited</span>)</span>;<span class="hljs-comment">//从顶点0开始深度优先搜索</span><br>        delete<span class="hljs-literal">[]</span> visited;<span class="hljs-comment">//释放visited的空间</span><br>    &#125;<br><span class="hljs-comment">//子过程</span><br>template&lt;NameType,DistType&gt; void Graph&lt;NameType,DistType&gt;::<span class="hljs-constructor">DFS(<span class="hljs-params">int</span> <span class="hljs-params">v</span>, <span class="hljs-params">visited</span>[])</span> &#123;<br>    cout&lt;&lt;<span class="hljs-constructor">GetValue(<span class="hljs-params">v</span>)</span>&lt;&lt;<span class="hljs-string">&quot;&quot;</span>;<br>    visited<span class="hljs-literal">[<span class="hljs-identifier">v</span>]</span>=<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">int</span> w = <span class="hljs-constructor">GetFirstNeighbor(<span class="hljs-params">v</span>)</span>;<br>    <span class="hljs-keyword">while</span> (w!=-<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span>(!visited<span class="hljs-literal">[<span class="hljs-identifier">w</span>]</span>)<br>            <span class="hljs-constructor">DFS(<span class="hljs-params">w</span>,<span class="hljs-params">visited</span>)</span>;<span class="hljs-comment">//最坏情况，就是每一次w都没有被访问过</span><br>        w = <span class="hljs-constructor">GetNextNeighbor(<span class="hljs-params">v</span>,<span class="hljs-params">w</span>)</span>;<br>    &#125;<br>    <span class="hljs-comment">//无论如何，最坏情况下访问次数，也就只能是图中所有边的个数。</span><br>    <span class="hljs-comment">//也就是对邻接矩阵所有边会被扫一遍</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-1-3-算法分析"><a href="#4-1-3-算法分析" class="headerlink" title="4.1.3. 算法分析"></a>4.1.3. 算法分析</h3><ol>
<li>用邻接表表示 O(n+e)</li>
<li>用邻接矩阵表示 O(n^2)</li>
</ol>
<h2 id="4-2-广度优先搜索-Breadth-search"><a href="#4-2-广度优先搜索-Breadth-search" class="headerlink" title="4.2. 广度优先搜索(Breadth search)"></a>4.2. 广度优先搜索(Breadth search)</h2><h3 id="4-2-1-思想"><a href="#4-2-1-思想" class="headerlink" title="4.2.1. 思想"></a>4.2.1. 思想</h3><ol>
<li>从图中某顶点V0出发，在访问了V0之后依次访<br> 问v0的各个未曾访问过的邻接点，然后分别从这些邻接<br> 点出发广度优先遍历图，直至图中所有顶点都被访问<br> 到为止.</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/23.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/23.png"><span class="image-caption">img</span></a></p>
<ol>
<li>算法同样需要一个辅助数组visited[] 表示顶点是否被访问过. 还需要一个队列,记正在访问的这一层和上一层的顶点. 算法显然是非递归的.</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">template&lt;NameType,DistType&gt; void Graph&lt;NameType,DistType&gt;::<span class="hljs-constructor">BFS(<span class="hljs-params">int</span> <span class="hljs-params">v</span>)</span> &#123;<br>    <span class="hljs-comment">//这个算法使用了队列</span><br>    <span class="hljs-built_in">int</span>* visited=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[N<span class="hljs-identifier">umVertices</span>]</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;NumVertices; i++)<br>        visited<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>=<span class="hljs-number">0</span>;<br>    cout &lt;&lt; <span class="hljs-constructor">GetValue(<span class="hljs-params">v</span>)</span> &lt;&lt; <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-comment">//访问结点</span><br>    visited<span class="hljs-literal">[<span class="hljs-identifier">v</span>]</span>=<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//使用队列来存储同一行的顶点</span><br>    queue&lt;<span class="hljs-built_in">int</span>&gt; q;<br>    q.<span class="hljs-constructor">EnQueue(<span class="hljs-params">v</span>)</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-constructor">IsEmpty()</span>) &#123;<br>        v= q.<span class="hljs-constructor">DeQueue()</span>;<br>        <span class="hljs-built_in">int</span> w= <span class="hljs-constructor">GetFirstNeighbor(<span class="hljs-params">v</span>)</span>;<br>        <span class="hljs-keyword">while</span> (w!=-<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span>(!visited<span class="hljs-literal">[<span class="hljs-identifier">w</span>]</span>) &#123;<br>                cout&lt;&lt;<span class="hljs-constructor">GetValue(<span class="hljs-params">w</span>)</span>&lt;&lt;<span class="hljs-string">&quot;&quot;</span>; <br>                visited<span class="hljs-literal">[<span class="hljs-identifier">w</span>]</span>=<span class="hljs-number">1</span>;<br>                q.<span class="hljs-constructor">EnQueue(<span class="hljs-params">w</span>)</span>;<br>            &#125;<br>            w= <span class="hljs-constructor">GetNextNeighbor(<span class="hljs-params">v</span>,<span class="hljs-params">w</span>)</span>;<br>            <span class="hljs-comment">//访问完成一层的结点，非递归地</span><br>        &#125;<br>    &#125;<br>    delete<span class="hljs-literal">[]</span> visited;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-2-2-算法分析"><a href="#4-2-2-算法分析" class="headerlink" title="4.2.2. 算法分析"></a>4.2.2. 算法分析</h3><ol>
<li>每个顶点进队列一次且只进一次，∴算法中循环语句至多执行n次。</li>
<li>从具体图的存储结构来看<ol>
<li>如果用邻接表：O(n+e)</li>
<li>如果用邻接矩阵: 对每个被访问过的顶点，循环检测矩阵中n个元素，∴时间代价为 O(n2)</li>
</ol>
</li>
</ol>
<h2 id="4-3-连通分量"><a href="#4-3-连通分量" class="headerlink" title="4.3. 连通分量"></a>4.3. 连通分量</h2><ol>
<li>以上讨论的是对一个无向的连通图或一个强连通图的有向图进行遍历，得到一棵深度优先或广度优先生成树.但当无向图(以无向图为例)为非连通图时，从图的某一<br> 顶点出发进行遍历(深度，广度)只能访问到该顶点所在的最大连通子图(即连通分量)的所有顶点.</li>
<li>下面是利用深度优先搜索求非连通图的连通分量算法 实际上只要加一个循环语句就行了.</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">Template&lt;NameType,DistType&gt; void Graph&lt;NameType,DistType&gt; :: components<span class="hljs-literal">()</span> &#123;  <br>    <span class="hljs-built_in">int</span>* visited = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[N<span class="hljs-identifier">umVertices</span>]</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;NumVertices;i++)<br>        visited<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;NumVertices; i++)<br>        <span class="hljs-comment">//只需要对于每一个顶点进行操作即可</span><br>        <span class="hljs-keyword">if</span> (!visited<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>) &#123;<br>            <span class="hljs-constructor">DFS(<span class="hljs-params">i</span>,<span class="hljs-params">visited</span>)</span>;<br>            output<span class="hljs-constructor">NewComponent()</span>;<br>        &#125;<br>        delete<span class="hljs-literal">[]</span> visited;<br>&#125;     <br></code></pre></td></tr></table></figure>

<h1 id="5-最小生成树"><a href="#5-最小生成树" class="headerlink" title="5. 最小生成树"></a>5. 最小生成树</h1><h2 id="5-1-生成树"><a href="#5-1-生成树" class="headerlink" title="5.1. 生成树"></a>5.1. 生成树</h2><h3 id="5-1-1-生成树的定义"><a href="#5-1-1-生成树的定义" class="headerlink" title="5.1.1. 生成树的定义"></a>5.1.1. 生成树的定义</h3><ol>
<li>设G &#x3D;(V，E)是一个连通的无向图(或是强连通有向图) 从图G中的任一顶点出发作遍历图的操作，把遍历走过的边的集合记为TE(G)，显然 G‘&#x3D;(V，TE)是G之子图， G‘被称为G的生成树(spanning tree)，也称为一个连通图.</li>
<li>n个结点的生成树有n-1条边。</li>
<li>生成树的代价(cost)：TE(G)上诸边的代价之和</li>
<li>生成树不唯一</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/24.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/24.png"><span class="image-caption">img</span></a></p>
<h3 id="5-1-2-最小代价生成树"><a href="#5-1-2-最小代价生成树" class="headerlink" title="5.1.2. 最小代价生成树"></a>5.1.2. 最小代价生成树</h3><ol>
<li>各边权的<strong>总和</strong>为最小的生成树</li>
</ol>
<h2 id="5-2-贪心-Grandy-求解最小代价生成树"><a href="#5-2-贪心-Grandy-求解最小代价生成树" class="headerlink" title="5.2. 贪心(Grandy)求解最小代价生成树"></a>5.2. 贪心(Grandy)求解最小代价生成树</h2><ol>
<li>6个城市已固定，现从一个城市发出信息到每一个城市如何选择或铺设通信线路，使花费(造价)最低。</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/25.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/25.png"><span class="image-caption">img</span></a></p>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/26.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/26.png"><span class="image-caption">img</span></a></p>
<ol>
<li>两个算法：Prim, Kruskal.</li>
<li>算法思想:贪心算法(逐步求解)</li>
</ol>
<h3 id="5-2-1-贪心策略的具体内容"><a href="#5-2-1-贪心策略的具体内容" class="headerlink" title="5.2.1. 贪心策略的具体内容"></a>5.2.1. 贪心策略的具体内容</h3><ol>
<li>Grandy策略：设：连通网络N&#x3D;{V,E}, V中有n个顶点。<ol>
<li>先构造 n 个顶点，0 条边的森林 F &#x3D;{T0,T1,……,Tn-1}</li>
<li>每次向 F 中加入一条边。该边是一端在 F 的某棵树Ti上而另一端不在Ti上的所有边中具有最小权值的边。 这样使F中两棵树合并为一棵，树的棵数 - 1</li>
<li>重复上述操作n-1次</li>
</ol>
</li>
<li>去掉所有边，每次加入的边是当前最小的边，并且保证这个边不是回边。</li>
</ol>
<h3 id="5-2-2-最小生成树的类声明"><a href="#5-2-2-最小生成树的类声明" class="headerlink" title="5.2.2. 最小生成树的类声明"></a>5.2.2. 最小生成树的类声明</h3><figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> MAXINT = 机器可表示的，问题中不可能出现的大数<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinSpanTree</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MSTEdgeNode</span> &#123;<br>    friend <span class="hljs-keyword">class</span> <span class="hljs-title class_">MinSpanTree</span>;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-built_in">int</span> tail ,head;<br>        <span class="hljs-built_in">int</span> cost;<br>&#125;;<br></code></pre></td></tr></table></figure>

<ol>
<li>边结构:tail + head + cost</li>
</ol>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinSpanTree</span> &#123;<br>    <span class="hljs-keyword">public</span> : MinSpanTree(<span class="hljs-built_in">int</span> SZ = NumVertices<span class="hljs-number">-1</span>):<br>        MaxSize(SZ), n(<span class="hljs-number">0</span>)&#123;edgevalue = <span class="hljs-keyword">new</span> MSTEdgeNode[MaxSize];&#125; <br>    <span class="hljs-keyword">protected</span>:<br>        MSTEdgeNode* edgevalue;<span class="hljs-comment">//边值数组</span><br>        <span class="hljs-built_in">int</span> MaxSize, n;<span class="hljs-comment">//数组的最大元素个数和 //当前个数</span><br>&#125;；<br></code></pre></td></tr></table></figure>

<h2 id="5-3-Kruskal算法-对边进行排序，然后生成"><a href="#5-3-Kruskal算法-对边进行排序，然后生成" class="headerlink" title="5.3. Kruskal算法(对边进行排序，然后生成)"></a>5.3. Kruskal算法(对边进行排序，然后生成)</h2><ol>
<li>把无向图的所有边排序</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/27.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/27.png"><span class="image-caption">img</span></a></p>
<ol>
<li>一开始的最小生成树为</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/28.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/28.png"><span class="image-caption">img</span></a></p>
<ol>
<li>在E中选一条代价最小的边(u,v)加入T，一定要满足(u,v) 不和TE中已有的边构成回路</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/29.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/29.png"><span class="image-caption">img</span></a></p>
<ol>
<li>一直到TE中加满n-1条边为止。</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/30.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/30.png"><span class="image-caption">img</span></a></p>
<h3 id="5-3-1-代码实现"><a href="#5-3-1-代码实现" class="headerlink" title="5.3.1. 代码实现"></a>5.3.1. 代码实现</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">void Graph&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">float</span>&gt;::<span class="hljs-constructor">Kruskal(MinSpanTree&amp;T)</span> &#123;<br>    <span class="hljs-comment">//结果赋值给T</span><br>    MSTEdgeNode e;<br>    MinHeap&lt;MSTEdgeNode&gt;<span class="hljs-constructor">H(<span class="hljs-params">currentEdges</span>)</span>;<br>    <span class="hljs-built_in">int</span> NumVertices=VerticesList.Last , u , v ;<br>    Ufsets <span class="hljs-constructor">F(NumVertices)</span>;<span class="hljs-comment">//建立n个单元素的连通分量</span><br>    <span class="hljs-keyword">for</span>(u=<span class="hljs-number">0</span>;u&lt;NumVertices;u++)<br>        <span class="hljs-keyword">for</span> (v=u+<span class="hljs-number">1</span>;v&lt;NumVertices;v++)<br>            <span class="hljs-keyword">if</span>(Edge<span class="hljs-literal">[<span class="hljs-identifier">u</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">v</span>]</span>!=MAXINT) &#123;<br>                e.tail=u;<br>                e.head=v;<br>                e.cost=Edge<span class="hljs-literal">[<span class="hljs-identifier">u</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">v</span>]</span>;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">H</span>.</span></span>insert(e);<br>                <span class="hljs-comment">//完成堆的初始化，将每一条边插入到优先级队列中去</span><br>            &#125;<br>    <span class="hljs-built_in">int</span> count=<span class="hljs-number">1</span>;<span class="hljs-comment">//生成树边计数</span><br>    <span class="hljs-keyword">while</span>(count&lt;NumVertices) &#123;<br>        H.<span class="hljs-constructor">RemoveMin(<span class="hljs-params">e</span>)</span>;<br>        u=F.<span class="hljs-constructor">Find(<span class="hljs-params">e</span>.<span class="hljs-params">tail</span>)</span>;<span class="hljs-comment">//找到并查集的树根</span><br>        v=F.<span class="hljs-constructor">Find(<span class="hljs-params">e</span>.<span class="hljs-params">head</span>)</span>;<span class="hljs-comment">//找到并查集的树根</span><br>        <span class="hljs-keyword">if</span>(u!=v)&#123;<br>            <span class="hljs-comment">//并查集做回边检测，在同一个并查集中就是一个回边，不然就不是</span><br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">F</span>.</span></span>union(u,v);<br>            T.<span class="hljs-constructor">Insert(<span class="hljs-params">e</span>)</span>;<br>            count++;<span class="hljs-comment">//计数已经查找出来的个数</span><br>        &#125;<br>        <span class="hljs-comment">//最坏的情况时所有的边都被访问一次，比如目标边是最后一条边。</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 以下为java代码</span><br>public void kruskal<span class="hljs-literal">()</span> &#123;    <span class="hljs-built_in">int</span> edgesAccepted;    DisjSet s;    priorityQueue h;    Vertex u, v;    SetType uset, vset;    Edge e;    h = read<span class="hljs-constructor">GraphIntoHeapArray( )</span>;    h.build<span class="hljs-constructor">Heap()</span> ;    s = <span class="hljs-keyword">new</span> <span class="hljs-constructor">DisjSet( NUM_VERTICES )</span>;    edgesAccepted = <span class="hljs-number">0</span> ;    <span class="hljs-keyword">while</span>( edgesAccepted &lt; NUM_VERTICES – <span class="hljs-number">1</span> )&#123;        e = h.delete<span class="hljs-constructor">Min()</span> ;<span class="hljs-comment">//Edge e = (u, v)        uset = s. find(u);        vset = s.find(v);        if( uset != vset ) &#123;            edgesAccepted++;            s.union( uset, vset );        &#125;    &#125;&#125;</span><br></code></pre></td></tr></table></figure>

<h3 id="5-3-2-算法分析"><a href="#5-3-2-算法分析" class="headerlink" title="5.3.2. 算法分析"></a>5.3.2. 算法分析</h3><ol>
<li><p>建立e条边的最小堆</p>
<ol>
<li>检测邻接矩阵O(n2)</li>
<li>每插入一条边，执行一次 fiterup() 算法：log2e 所以，总的建堆时间为O(elog2e)</li>
</ol>
</li>
<li><p>构造最小生成树时</p>
<ol>
<li><p>e次出堆操作：每一次出堆，执行一次filterdown(), 总时间为O(elog2e)</p>
<ul>
<li>没有考虑悬挂问题</li>
</ul>
</li>
<li><p>2e次find操作：O(elog2n)，树高是log2n</p>
<ul>
<li>从头开始生成，两个高为1的树，做union，才有高度为2的树</li>
<li>两个高为2的树，做union，才有高度为3的树</li>
<li>树的高度最坏情况下是log2n，当切仅当第一个二叉树</li>
</ul>
</li>
<li><p>n-1次union操作：O(n)</p>
</li>
<li><p>所以，总的计算时间为O(elog2e+elog2n+n2+n)</p>
</li>
</ol>
</li>
</ol>
<h2 id="5-4-物理实现"><a href="#5-4-物理实现" class="headerlink" title="5.4. 物理实现"></a>5.4. 物理实现</h2><ol>
<li>图用<strong>邻接矩阵</strong>表示，edge(边的信息)</li>
<li>图的顶点信息在顶点表 Verticelist中</li>
<li>边的条数为CurrentEdges</li>
<li>取最小的边以及判别是否构成回路，</li>
<li>取最小的边利用:最小堆(MinHeap)</li>
</ol>
<h2 id="5-5-Prim算法-结合顶点，考虑所有可达的边的权重大小"><a href="#5-5-Prim算法-结合顶点，考虑所有可达的边的权重大小" class="headerlink" title="5.5. Prim算法(结合顶点，考虑所有可达的边的权重大小)"></a>5.5. Prim算法(结合顶点，考虑所有可达的边的权重大小)</h2><ol>
<li>设：原图的顶点集合V(有n个)生成树的顶点集合U(最后也有n个)，一开始为空TE集合为{}</li>
<li>步骤：<ol>
<li>U&#x3D;{1}任何起始顶点，TE&#x3D;{}</li>
<li>每次生成(选择)一条边。这条边是所有边(u,v) 中代价(权)最小的边， u∈U,v∈V-U TE&#x3D;TE+[(u,v)]; U&#x3D;U+[v]</li>
<li>当U≠V，返回上面一个步骤</li>
</ol>
</li>
</ol>
<h3 id="5-5-1-例子"><a href="#5-5-1-例子" class="headerlink" title="5.5.1. 例子"></a>5.5.1. 例子</h3><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/31.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/31.png"><span class="image-caption">img</span></a><br> <a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/32.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/32.png"><span class="image-caption">img</span></a></p>
<ol>
<li>一开始只考虑从1号顶点到其他顶点之间的边。<ul>
<li>泛泛而言，考虑u和v之间的边</li>
</ul>
</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/33.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/33.png"><span class="image-caption">img</span></a><br> <a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/34.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/34.png"><span class="image-caption">img</span></a></p>
<h3 id="5-5-2-最小生成树不唯一"><a href="#5-5-2-最小生成树不唯一" class="headerlink" title="5.5.2. 最小生成树不唯一"></a>5.5.2. 最小生成树不唯一</h3><ol>
<li>对于一般的图来讲，最小生成树不唯一。</li>
<li>所以相应的Prime算法和Kruskal算法也会出现多解得 情况。</li>
</ol>
<h3 id="5-5-3-算法分析"><a href="#5-5-3-算法分析" class="headerlink" title="5.5.3. 算法分析"></a>5.5.3. 算法分析</h3><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/35.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/35.png"><span class="image-caption">img</span></a></p>
<ol>
<li>第一次的时候u只有1个元素，而第二次则有2个，以此类推。</li>
<li>使用邻接矩阵实现的图，可以把时间复杂度降低到O(n2)</li>
</ol>
<h2 id="5-6-Prim算法优化"><a href="#5-6-Prim算法优化" class="headerlink" title="5.6. Prim算法优化"></a>5.6. Prim算法优化</h2><ol>
<li>使用两个数组Lowcost[ ]、nearvex[ ]</li>
<li>Lowcost[]:存放生成树顶点集合内顶点到生成树外各顶点的边上的当前最小权值</li>
<li>nearvex[]:记录生成树顶点集合外各顶点，距离集合内那个顶点最近。</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/36.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/36.png"><span class="image-caption">img</span></a></p>
<ol>
<li>拿u为1364为例，将2拉入u之后，如果1364到5的最小值小于2到5之间的距离，则抛弃25边，否则更新数组。<br> <a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/37.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/37.png"><span class="image-caption">img</span></a></li>
<li>对于nearvex:记录的结点，lowcost对应记录的是相应边的权重(按照上面的序号)<ul>
<li>更新最小边:发生在加入新的结点的时候，需要在nearvex中更新对应位置的最小边。</li>
</ul>
</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/36.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/36.png"><span class="image-caption">img</span></a></p>
<h3 id="5-6-1-算法实现"><a href="#5-6-1-算法实现" class="headerlink" title="5.6.1. 算法实现"></a>5.6.1. 算法实现</h3><ol>
<li>在Lowcost[ ]中选择nearvex[i]不等于-1,且lowcost[i]  最小的边用v标记它。，则选中的权值最小的边为(nearvex[v],v), 相应的权值为lowcost[v]。  例如在上面图中第一次选中的v&#x3D;5;则边(0，5)，是选中的权值最小的边，相应的权值为lowcost[5]&#x3D;10。 反复做以下工作</li>
<li>将nearvex[v] 改为-1，表示它已加入生成树顶点集合。将边(nearvex[v],v,lowcost[v])加入生成树的边集合。</li>
<li>修改。取lowcost[i]&#x3D;min{lowcost[i],Edge[v][i]},即用生成树顶点集合外各顶 点i到刚加入该集合的新顶点 v的距离(Edge[v][i])与原来它所到生成树顶点 集合中顶点的最短距离lowcost[i]做比较，取距离近的，作为这些集合外顶  点到生成树顶点集合内顶点的最短距离。</li>
<li>如果生成树顶点集合外的顶点i到刚加入该集合新顶点v的距离比原来它 到生成树顶点集合中顶点的最短距离还要近，则修改nearvex[i]: nearvex[i]&#x3D;v 表示生成树外顶点i到生成树的内顶点v 当前距离最短。</li>
</ol>
<h3 id="5-6-2-示例"><a href="#5-6-2-示例" class="headerlink" title="5.6.2. 示例"></a>5.6.2. 示例</h3><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/38.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/38.png"><span class="image-caption">img</span></a></p>
<ol>
<li>4-&gt;5 25&lt;正无穷，更新<ul>
<li>nearvex更新顶点，lowcost更新权值</li>
</ul>
</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/39.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/39.png"><span class="image-caption">img</span></a></p>
<ol>
<li>考虑1-&gt;4、2-&gt;4等等</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/40.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/40.png"><span class="image-caption">img</span></a></p>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/41.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/41.png"><span class="image-caption">img</span></a></p>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/42.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/42.png"><span class="image-caption">img</span></a></p>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/43.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/43.png"><span class="image-caption">img</span></a></p>
<h3 id="5-6-3-Prim算法实现"><a href="#5-6-3-Prim算法实现" class="headerlink" title="5.6.3. Prim算法实现"></a>5.6.3. Prim算法实现</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">void graph&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">float</span>&gt;::<span class="hljs-constructor">Prim(MinSpanTree&amp;T)</span>&#123;<br>    <span class="hljs-built_in">int</span> NumVertices=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">VerticesList</span>.</span></span>last; <br>    <span class="hljs-built_in">float</span>*lowcost=<span class="hljs-keyword">new</span> <span class="hljs-built_in">float</span><span class="hljs-literal">[N<span class="hljs-identifier">umVertices</span>]</span>; <br>    <span class="hljs-built_in">int</span><span class="hljs-operator"> * </span>nearvex=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[N<span class="hljs-identifier">umVertices</span>]</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt; NumVertices;i++) &#123;<br>        lowcost<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = Edge<span class="hljs-literal">[<span class="hljs-number">0</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<span class="hljs-comment">//0到其他所有边的权值</span><br>        nearvex<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>=<span class="hljs-number">0</span>;<br>    &#125;<br>    nearvex<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>=-<span class="hljs-number">1</span>;<br>    MSTEdgeNode e;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>; i&lt; NumVertices; i++) &#123;<br>        <span class="hljs-built_in">float</span> min=MAXINT;<br>        <span class="hljs-built_in">int</span> v=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> ( <span class="hljs-built_in">int</span> j=<span class="hljs-number">1</span>; j&lt; NumVertices; j++)<br>            <span class="hljs-keyword">if</span>(nearvex<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>!=-<span class="hljs-number">1</span>&amp;&amp;lowcost<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>&lt;min) &#123;<br>                v=j;<br>                min=lowcost<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>;<br>            &#125; <span class="hljs-comment">//for j,  选择最小的边</span><br><br>        <span class="hljs-keyword">if</span>(v) &#123;<br>            e.tail=nearvex<span class="hljs-literal">[<span class="hljs-identifier">v</span>]</span>;<br>            e.head=v;<br>            e.cost=lowcost<span class="hljs-literal">[<span class="hljs-identifier">v</span>]</span>;<br>            T.<span class="hljs-constructor">Insert(<span class="hljs-params">e</span>)</span>;<br>            <span class="hljs-comment">//添加边进入最小生成树中去</span><br>            nearvex<span class="hljs-literal">[<span class="hljs-identifier">v</span>]</span>=-<span class="hljs-number">1</span>;<br>            <br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">1</span>; j&lt; NumVertices; j++)<br>                <span class="hljs-keyword">if</span>( nearvex<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>!=-<span class="hljs-number">1</span><span class="hljs-operator"> &amp;&amp; </span>Edge<span class="hljs-literal">[<span class="hljs-identifier">v</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>&lt;lowcost<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> ) &#123;<br>                    lowcost<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>=Edge<span class="hljs-literal">[<span class="hljs-identifier">v</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>;<br>                    nearvex<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>=v;<br>                &#125;<br>        &#125; <span class="hljs-comment">//if</span><br>    &#125; <span class="hljs-comment">//for i</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5-6-4-估计算法复杂度"><a href="#5-6-4-估计算法复杂度" class="headerlink" title="5.6.4. 估计算法复杂度"></a>5.6.4. 估计算法复杂度</h3><ol>
<li>第一个for循环的复杂度是O(n)的</li>
<li>第二个嵌套的for循环的复杂度是O(n2)的</li>
</ol>
<h1 id="6-最短路径"><a href="#6-最短路径" class="headerlink" title="6. 最短路径"></a>6. 最短路径</h1><ol>
<li>设G&#x3D;(V,E)是一个带权图(有向，无向)，如果从顶点v到顶点w的一条路径为(v,v1,v2,…,w)，其路径长度不大于从v到w的所有其它路径的长度，则该路径为从 v 到 w 的最短路径。</li>
<li>背景:在交通网络中，求各城镇间的最短路径。</li>
<li>三种算法:<ol>
<li>边上权值为非负情况的从一个结点到其它各结点的最短路径 (单源最短路径)(Dijkstra算法)</li>
<li>边上权值为任意值的单源最短路径</li>
<li>边上权值为非负情况的所有顶点之间的最短路径</li>
</ol>
</li>
</ol>
<h2 id="6-1-含非负权值的单源最短路径-Dijkstra"><a href="#6-1-含非负权值的单源最短路径-Dijkstra" class="headerlink" title="6.1. 含非负权值的单源最短路径(Dijkstra)"></a>6.1. 含非负权值的单源最短路径(Dijkstra)</h2><ol>
<li>问题</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/44.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/44.png"><span class="image-caption">img</span></a></p>
<h3 id="6-1-1-贪心思想"><a href="#6-1-1-贪心思想" class="headerlink" title="6.1.1. 贪心思想"></a>6.1.1. 贪心思想</h3><ol>
<li>起点V0，首先直接连接，不管是否直接连接。</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/61.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/61.png"><span class="image-caption">img</span></a></p>
<ol>
<li>排好序后，V0-V1 10已经是最小的了，不可能再找到更短的路径</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/62.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/62.png"><span class="image-caption"> </span></a></p>
<ol>
<li>接下来，尝试V0-v2通过V1绕会不会比原来的更短(考虑V1-V2直连)，V0-V4从V1绕会不会比原来更短(考虑V2-V3直连)，如果短则更新，此时V0-V3是三者中最小值，所以选择V0-V3。</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/63.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/63.png"><span class="image-caption">img</span></a></p>
<ol>
<li>尝试绕行V3，计算直连，更新掉，然后重复</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/64.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/64.png"><span class="image-caption">img</span></a></p>
<ol>
<li>红色是已经选择好的，绿色是绕行选择。</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/65.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/65.png"><span class="image-caption">img</span></a></p>
<ol>
<li>进一步思考，就是只进行一步，不进行多不步。</li>
<li>总体来讲:不可能走更长的路径，然后回来</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/45.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/45.png"><span class="image-caption">img</span></a><br> <a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/46.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/46.png"><span class="image-caption">img</span></a></p>
<ol>
<li>数值更新，路径数组对应位置更新</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/47.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/47.png"><span class="image-caption">img</span></a></p>
<h3 id="6-1-2-代码实现"><a href="#6-1-2-代码实现" class="headerlink" title="6.1.2. 代码实现"></a>6.1.2. 代码实现</h3><figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> NumVertices = <span class="hljs-number">6</span>;<span class="hljs-comment">//大于所有边的权重的值</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">graph</span> &#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> Edge[NumVertices][NumVertices]; <br>        <span class="hljs-type">int</span> <span class="hljs-built_in">dist</span>[NumVertices];<br>        <span class="hljs-type">int</span> path[NumVertices];<br>        <span class="hljs-type">int</span> S[NumVertices];<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">shortestpath</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>);<br>&#125;;<br><span class="hljs-keyword">void</span> Graph::<span class="hljs-title function_">shortestpath</span>(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> v) &#123;  <br>    <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) &#123;<br>        <span class="hljs-comment">//v为当前节点，dist数组是表示距离的数组</span><br>        <span class="hljs-comment">//遍历n次</span><br>        <span class="hljs-built_in">dist</span>[i] = Edge[v][i];<br>        s[i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>( i!=v &amp;&amp; <span class="hljs-built_in">dist</span>[i]&lt; MAXNUM )<br>            path[i]= v;<span class="hljs-comment">//如果可达，则用path数组记录下路径</span><br>        <span class="hljs-keyword">else</span><br>            path[i]=<span class="hljs-number">-1</span>;<span class="hljs-comment">//如果不可达，则用path数组记录下不可达(-1)</span><br>        &#125;<br>        s[v]=<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">dist</span>[v]=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//表示访问过当前节点，并且距离为0</span><br>        <span class="hljs-keyword">for</span>( i=<span class="hljs-number">0</span>; i&lt;n<span class="hljs-number">-1</span>; i++) &#123;<br>            <span class="hljs-type">float</span> <span class="hljs-built_in">min</span>=MAXNUM;<br>            <span class="hljs-type">int</span> u = v;<br>            <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;  j &lt; n;  j++)<br>                <span class="hljs-keyword">if</span>( !s[j] &amp;&amp; <span class="hljs-built_in">dist</span>[j]&lt;<span class="hljs-built_in">min</span> ) &#123;<br>                    <span class="hljs-comment">//如果结点j还没有访问过，并且dist[j]小于最小值</span><br>                    u = j;<br>                    <span class="hljs-built_in">min</span> = <span class="hljs-built_in">dist</span>[j];<br>                &#125;<br>            s[u]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> w=<span class="hljs-number">0</span>; w&lt;n; w++)<br>                <span class="hljs-keyword">if</span>( !s[w] &amp;&amp; Edge[u][w] &lt; MAXNUM &amp;&amp; <span class="hljs-built_in">dist</span>[u]+Edge[u][w] &lt; <span class="hljs-built_in">dist</span>[w]) &#123;<br>                    <span class="hljs-comment">//dist[u]就是起点到u的距离，下面是关键条件</span><br>                    <span class="hljs-built_in">dist</span>[w]=<span class="hljs-built_in">dist</span>[u]+Edge[u][w];<br>                    path[w]=u;<br>                &#125;<br>        &#125;<span class="hljs-comment">//for</span><br>&#125;   <br></code></pre></td></tr></table></figure>

<h3 id="6-1-3-算法复杂度分析"><a href="#6-1-3-算法复杂度分析" class="headerlink" title="6.1.3. 算法复杂度分析"></a>6.1.3. 算法复杂度分析</h3><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/48.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/48.png"><span class="image-caption">img</span></a></p>
<h2 id="6-2-贝尔曼——福特改进算法"><a href="#6-2-贝尔曼——福特改进算法" class="headerlink" title="6.2. 贝尔曼——福特改进算法"></a>6.2. 贝尔曼——福特改进算法</h2><ol>
<li><p>边上权值为任意值的单源最短路径(贝尔曼—福特) dijkstra算法在边上权值为任意值的图上是不能正常工作的。</p>
</li>
<li><p>dist</p>
<p>1</p>
<p>[u],dist</p>
<p>2</p>
<p>[u],…dist</p>
<p>n-1</p>
<p>[u]</p>
<ul>
<li>dist1[u]:是从源点v到终点u的只经过一条边的 的最短路径长度</li>
<li>dist1[u]&#x3D;Edge[v][u]</li>
<li>dist2[u]:是从源点v最多经过两条边到达终点u 的最短路径长度；</li>
</ul>
</li>
<li><p>不允许出现负值回路出现</p>
</li>
<li><p>递推公式:</p>
<ol>
<li>dist1[u]&#x3D;Edge[v][u];</li>
<li>distk[u]&#x3D;min{distk-1 [u],min{distk-1[j]+Edge[j][u]}} j&#x3D;0,1,2,…,n-1</li>
</ol>
</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/49.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/49.png"><span class="image-caption">img</span></a></p>
<ol>
<li>更新的时候都是根据前面结果，遍历计算存储</li>
<li>所有第k步，只受第k-1步的影响</li>
</ol>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">void  Graph::BellmanFord(int n, int v) &#123;<br>    //动态规划<br>    for(int i=0;i&lt;n;i++) &#123;<br>        //初始化dist距离数组<br>        dist<span class="hljs-comment">[i]</span>=Edge<span class="hljs-comment">[v]</span><span class="hljs-comment">[i]</span>;<br>        if(i!=v &amp;&amp; dist<span class="hljs-comment">[i]</span>&lt;MAXNUM) path<span class="hljs-comment">[i]</span>=v;<br>        //初始化路径数组 <br>        else path<span class="hljs-comment">[i]</span>=-1; &#125;<br>    <br>    for (int k = 2;k &lt; n;k++)<br>        for(int u = 0;u &lt; n;u++)<br>            if(u!=v)<br>                for(i=0;i &lt; n;i++)<br>                    //一直算到n-1步<br>                    if (Edge<span class="hljs-comment">[i]</span><span class="hljs-comment">[u]</span>&lt;&gt;0 &amp;&amp; Edge<span class="hljs-comment">[i]</span><span class="hljs-comment">[u]</span>&lt;MAXNUM &amp;&amp; dist<span class="hljs-comment">[u]</span>&gt; dist<span class="hljs-comment">[i]</span>+Edge<span class="hljs-comment">[i]</span><span class="hljs-comment">[u]</span>)&#123;<br>                        dist<span class="hljs-comment">[u]</span>=dist<span class="hljs-comment">[i]</span>+Edge<span class="hljs-comment">[i]</span><span class="hljs-comment">[u]</span>;<br>                        path<span class="hljs-comment">[u]</span>=i;<br>                    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>时间复杂度:O(n3)</li>
</ol>
<h2 id="6-3-floyed算法"><a href="#6-3-floyed算法" class="headerlink" title="6.3. floyed算法"></a>6.3. floyed算法</h2><ol>
<li>前提:各边权值均大于0的带权有向图。<ul>
<li>每个顶点到自己的代价为0</li>
</ul>
</li>
<li>方法：<ol>
<li>把有向图的每一个顶点作为源点，重复执行Dijkstra算法n次，执行时间为O(n3)</li>
<li>Floyed方法，算法形式更简单些，但是时间仍然是O(n3)</li>
</ol>
</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/50.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/50.png"><span class="image-caption">img</span></a><br> <a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/51.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/51.png"><span class="image-caption">img</span></a><br> <a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/52.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/52.png"><span class="image-caption">img</span></a></p>
<ol>
<li>简单来说就是:每次都会选择一个中介点，然后遍历整个数组，更新相应的需要更新的数组。</li>
</ol>
<h3 id="6-3-1-floyed算法实现"><a href="#6-3-1-floyed算法实现" class="headerlink" title="6.3.1. floyed算法实现"></a>6.3.1. floyed算法实现</h3><figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">void Graph::Alllength(int n) &#123;<br>    for(int i=0; i&lt;n; i++)<br>        for(int j=0; j&lt;n; j++) &#123;<br>            a<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=Edge<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>;<br>            if(i!=j&amp;&amp;a<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>&lt;MAXNUM) path<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = i;<br>            else path<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=0;<br>            &#125;<br>    for(int k=0; k&lt;n; k++)<br>        for(int i=0; i&lt;n; i++)<br>            for(int j=0; j&lt;n; j++)<br>                if( a<span class="hljs-comment">[i]</span><span class="hljs-comment">[k]</span>+a<span class="hljs-comment">[k]</span><span class="hljs-comment">[j]</span>&lt;a<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> ) &#123;<br>                    a<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=a<span class="hljs-comment">[i]</span><span class="hljs-comment">[k]</span>+a<span class="hljs-comment">[k]</span><span class="hljs-comment">[j]</span>;<br>                    path<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=path<span class="hljs-comment">[k]</span><span class="hljs-comment">[j]</span>;<br>                &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>算法复杂度:O(n3)</li>
<li>参考:<a href="https://blog.csdn.net/qq_35644234/article/details/60875818">Floyed算法</a></li>
</ol>
<h2 id="6-4-Floyed算法参考"><a href="#6-4-Floyed算法参考" class="headerlink" title="6.4. Floyed算法参考"></a>6.4. Floyed算法参考</h2><ol>
<li><a href="https://blog.csdn.net/qq_35644234/article/details/60875818">最短路径问题</a></li>
</ol>
<h1 id="7-活动网络-图的应用"><a href="#7-活动网络-图的应用" class="headerlink" title="7. 活动网络(图的应用)"></a>7. 活动网络(图的应用)</h1><ol>
<li>用顶点表示活动的网络(AOV网络)</li>
<li>用边表示活动的网络(AOE网络)</li>
<li>用顶点表示活动的网络</li>
</ol>
<h2 id="7-1-AOV网络"><a href="#7-1-AOV网络" class="headerlink" title="7.1. AOV网络"></a>7.1. AOV网络</h2><p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/53.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/53.png"><span class="image-caption">img</span></a></p>
<h3 id="7-1-1-AOV网络结构"><a href="#7-1-1-AOV网络结构" class="headerlink" title="7.1.1. AOV网络结构"></a>7.1.1. AOV网络结构</h3><ol>
<li>图中顶点表示课程(活动)，有向边(弧)表示先决条件。 若课程i是课程j的预修课程，则图中有弧&lt;i,j&gt;</li>
<li>AOV网(Activity On Vertex network)<ul>
<li>用顶点表示活动，用弧表示活动间的优先关系的有向图称为AOV网。</li>
</ul>
</li>
<li>直接前驱，直接后继<ul>
<li>&lt;i,j&gt;是网中一条弧，则i是j的直接前驱，j是i的直接后继。</li>
</ul>
</li>
<li>前驱，后继<ul>
<li>从顶点i-&gt;顶点j有一条有向路径，则称i是j的前驱，j是i的后继。</li>
</ul>
</li>
<li><strong>AOV网中，不应该出现有向环</strong></li>
</ol>
<h3 id="7-1-2-AOV图的拓扑排序"><a href="#7-1-2-AOV图的拓扑排序" class="headerlink" title="7.1.2. AOV图的拓扑排序"></a>7.1.2. AOV图的拓扑排序</h3><ol>
<li>有向图G&#x3D;(V,E),V里结点的线性序列(vi1,vi2,…,vin), 如果满足: 在G中从结点 vi 到 vj 有一条路径，则序列中结点 Vi 必先于结点 vj ，称这样的线性序列为<strong>一拓扑序列</strong>。</li>
<li>不是任何有向图的结点都可以排成拓扑序列，有环图是显然没有拓扑排序的。</li>
</ol>
<h3 id="7-1-3-拓扑算法思想"><a href="#7-1-3-拓扑算法思想" class="headerlink" title="7.1.3. 拓扑算法思想"></a>7.1.3. 拓扑算法思想</h3><ol>
<li>从图中选择一个入度为0的结点输出之。(如果一个图中，同时存在多个入度为0的结点，则随便输出任意一个结点)</li>
<li>从图中删掉此结点及其所有的出边。</li>
<li>反复执行以上步骤<ol>
<li>直到所有结点都输出了，则算法结束</li>
<li><strong>如果图中还有结点，但入度不为0</strong>，则说明有环路</li>
</ol>
</li>
</ol>
<h3 id="7-1-4-拓扑算法实现"><a href="#7-1-4-拓扑算法实现" class="headerlink" title="7.1.4. 拓扑算法实现"></a>7.1.4. 拓扑算法实现</h3><ol>
<li>具体实现算法：AOV网用邻接表来实现数组count存放各顶点的<strong>入度</strong></li>
<li>并且为了避免每次从头到尾查找入度为0的顶点，建立入度为0的顶点栈，栈顶指针为top，初始化时为-1.</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/66.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/66.png"><span class="image-caption">img</span></a></p>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/54.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/54.png"><span class="image-caption">img</span></a></p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">//AOV网的声明</span><br><span class="hljs-keyword">class</span> Graph &#123;<br>    friend <span class="hljs-keyword">class</span> &lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">float</span>&gt; vertex;<br>    friend <span class="hljs-keyword">class</span> &lt;<span class="hljs-keyword">float</span>&gt; Edge;<br>    <span class="hljs-keyword">private</span>:<br>        vertex &lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">float</span>&gt;* nodeTable ; <br>        <span class="hljs-keyword">int</span>* <span class="hljs-keyword">count</span> ;<br>        <span class="hljs-keyword">int</span> n ;<br>    <span class="hljs-keyword">public</span>:<br>        Graph ( const <span class="hljs-keyword">int</span> vertices=<span class="hljs-number">0</span>): n (vertices) &#123;<br>            NodeTable=<span class="hljs-keyword">new</span> vertex &lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">float</span>&gt; [n];<br>            <span class="hljs-keyword">count</span>=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        &#125;<br>        <span class="hljs-keyword">void</span> topologicalorder() ;<br>&#125;;<br><span class="hljs-comment">//拓扑排序</span><br><span class="hljs-keyword">void</span> Graph :: Topologicalsort () &#123;<br>    <span class="hljs-keyword">int</span> top=-<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//初始化无入度顶点</span><br>    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n ;i++ )<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">count</span>[i]==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">count</span>[i]= top ;<br>            top = i;<br>        &#125;<br>    <span class="hljs-comment">//进行正式排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span> ; i&lt;n ; i++)<br>        <span class="hljs-keyword">if</span> (top == -<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">//如果top变为-1，那么显然存在回路</span><br>            cout &lt;&lt;<span class="hljs-string">&quot;Network has a cycle&quot;</span>&lt;&lt; endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">int</span> j = top;<br>            top = <span class="hljs-keyword">count</span>[top];<br>            cout&lt;&lt;j&lt;&lt;endl;<br>            Edge&lt;<span class="hljs-keyword">float</span>&gt;* l = NodeTable[j].adj;<br>            <span class="hljs-keyword">while</span>(l) &#123;<br>                <span class="hljs-keyword">int</span> k = l.dest;<br>                <span class="hljs-keyword">if</span> ( --connt[k] == <span class="hljs-number">0</span>)<br>                    <span class="hljs-comment">//如果完成所有节点的删除</span><br>                    <span class="hljs-keyword">count</span>[k] = top;<br>                    top = k;<br>      			l = l-&gt;link;<br>        	&#125;<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>

<ol>
<li>java实现</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">topsort</span>() throws CycleFound</span> &#123;<br>    Queue q;<span class="hljs-comment">//队列或者栈都可以</span><br>    <span class="hljs-built_in">int</span> counter = <span class="hljs-number">0</span>;<br>    Vertex v, w;<br>    q = <span class="hljs-keyword">new</span> Queue();<br>    <span class="hljs-function"><span class="hljs-keyword">for</span> each vertex v</span><br><span class="hljs-function">        <span class="hljs-title">if</span>(<span class="hljs-params"> v.indegree == <span class="hljs-number">0</span> </span>)</span><br><span class="hljs-function">            q.<span class="hljs-title">enqueue</span>(<span class="hljs-params">v</span>)</span>;<br>    <span class="hljs-keyword">while</span>(!q.isEmpty()) &#123;<br>        v = q.dequeue();<br>        v.topNum = ++counter;<span class="hljs-comment">//Assign next number </span><br>        <span class="hljs-function"><span class="hljs-keyword">for</span> each w adjacent to v</span><br><span class="hljs-function">            <span class="hljs-title">if</span>(<span class="hljs-params"> --w.indegree == <span class="hljs-number">0</span> </span>) </span><br><span class="hljs-function">                q.enqueue</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>( counter != NUM_VERTICES )<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CycleFound();<br>&#125; <br></code></pre></td></tr></table></figure>

<h3 id="7-1-5-算法复杂度分析"><a href="#7-1-5-算法复杂度分析" class="headerlink" title="7.1.5. 算法复杂度分析"></a>7.1.5. 算法复杂度分析</h3><ol>
<li>算法分析：n个顶点，e条边</li>
<li>建立链式栈O(n)，每个结点输出一次，每条边被检查一次O(n＋e)，所以为:O(n＋n＋e)</li>
</ol>
<h2 id="7-2-AOE网络"><a href="#7-2-AOE网络" class="headerlink" title="7.2. AOE网络"></a>7.2. AOE网络</h2><ol>
<li><p>用边表示活动的网络(AOE网络,  Activity On Edge Network)又称为<strong>事件顶点网络</strong></p>
</li>
<li><p>顶点：</p>
<ul>
<li>表示事件(event) 事件——状态。表示它的入边代表的活动已完成，它的出边 代表的活动可以开始，如下图v0表示整个工程开始，v4表示a4，a5活动已完成a7，a8活动可开始。</li>
</ul>
</li>
<li><p>有向边：</p>
<ul>
<li>表示活动。 边上的权——表示完成一项活动需要的时间</li>
</ul>
</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/55.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/55.png"><span class="image-caption">img</span></a><br> <a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/56.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/56.png"><span class="image-caption">img</span></a></p>
<h3 id="7-2-1-关键路径"><a href="#7-2-1-关键路径" class="headerlink" title="7.2.1. 关键路径"></a>7.2.1. 关键路径</h3><ol>
<li>目的: 利用事件顶点网络，研究完成整个工程需要多少时间 加快那些活动的速度后，可使整个工程提前完成。</li>
<li>关键路径：具有从开始顶点(源点)-&gt;完成顶点(汇点)的 最长的路径</li>
</ol>
<h3 id="7-2-2-一些定义"><a href="#7-2-2-一些定义" class="headerlink" title="7.2.2. 一些定义"></a>7.2.2. 一些定义</h3><ol>
<li>对于事件:<ol>
<li>Ve[i]－表示事件Vi的可能最早发生时间:定义为从源点V0-&gt;Vi的最长路径长度, 如Ve[4]&#x3D;7天</li>
<li>Vl[i]－表示事件Vi的允许的最晚发生时间:是在保证汇点 Vn-1 在Ve[n-1]时刻(18)完成的前提下，事件Vi允许发生的最晚时间＝ Ve[n-1]－ Vi-&gt;Vn－1的最长路径长度。<strong>是从最后汇点时间长度-两者之间最长路径</strong></li>
</ol>
</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/57.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/57.png"><span class="image-caption">img</span></a></p>
<ol>
<li>解释:<ol>
<li>计算到最后汇点的总共最短时间:找到从源点到汇点的最大路径</li>
<li>最早12，因为之前不能做。</li>
<li>最晚12，是因为如果这时候不开始，最后完成不了。</li>
</ol>
</li>
<li>对于活动:<ol>
<li>e[k]－表示活动ak&#x3D;&lt;Vi,Vj&gt;的可能的最早开始时间。 即等于事件Vi的可能最早发生时间。 e[k]&#x3D;Ve[i]</li>
<li>l[k]－表示活动ak&#x3D; &lt;Vi,Vj&gt; 的允许的最迟开始时间 l[k]＝Vl[j]-dur(&lt;i,j&gt;);</li>
<li>l[k]-e[k]－表示活动ak的最早可能开始时间和最迟允许开始时间的时间余量。也称为松弛时间。 (slack  time)</li>
<li>l[k]&#x3D;&#x3D;e[k]－表示活动ak是没有时间余量的<strong>关键活动</strong></li>
</ol>
</li>
<li>一开始的例子中<ol>
<li>a8的最早可能开始时间e[8]&#x3D;Ve[4]&#x3D;7</li>
<li>最迟允许开始时间l[8]&#x3D;Vl[7]-dur(&lt;4,7&gt;) &#x3D;14-7&#x3D;7,所以a8是关键路径上的关键活动</li>
<li>a9的最早可能开始时间e[9]&#x3D;Ve[5]&#x3D;7</li>
<li>最迟允许开始时间l[9]&#x3D;Vl[7]-dur(&lt;5,7&gt;) &#x3D;14-4&#x3D;10</li>
</ol>
</li>
<li>所以l[9]-e[9]&#x3D;3, 该活动的时间余量为3，即推迟3天或延迟3天完成都不 影响整个工程的完成，它不是关键活动</li>
</ol>
<h3 id="7-2-3-寻找关键路径的算法"><a href="#7-2-3-寻找关键路径的算法" class="headerlink" title="7.2.3. 寻找关键路径的算法"></a>7.2.3. 寻找关键路径的算法</h3><ol>
<li>求各事件的可能最早发生时间 从Ve[0]&#x3D;0开始，向前推进求其它事件的Ve Ve[i]&#x3D;max{Ve[j]+dur(&lt; Vj,Vi &gt;)},  &lt;Vj,Vi&gt;属于S2, i&#x3D;1,2,…n－1 j S2是所有指向顶点Vi的有向边&lt; Vj,Vi  &gt;的集合</li>
<li>求各事件的允许最晚发生时间 从Vl[n-1]&#x3D;Ve[n-1]开始，反向递推 Vl[i]&#x3D;min{Vl[j]-dur  (&lt;Vi,Vj&gt;)},  &lt;Vi,Vj&gt;属于S1,  i&#x3D;n-2,n-3,…0 j  S1是所有从顶点Vi出发的有向边&lt; Vi,Vj &gt;的集合</li>
<li>以上的计算必须在拓扑有序及逆拓扑有序的前提下进行，求Ve[i]必须使Vi的所有前驱结点的Ve都求得求Vl[i]必须使Vi的所有后继结点最晚发生时间都求得。</li>
<li>求每条边(活动)ak&#x3D; &lt;Vi,Vj&gt; 的e[k], l[k] e[k]&#x3D;Ve[i];l[k]&#x3D;Vl[j]-dur(&lt;Vi,Vj&gt; ),k&#x3D;1,2,…e</li>
<li><strong>如果e[k]&#x3D;&#x3D;l[k]，则ak是关键活动</strong></li>
<li>AOE网用邻接表来表示，并且假设顶点序列已按拓扑有序与逆拓扑有序排好。如上例:<ul>
<li>先正向推，然后反向推回来。(分别计算最早时间和最晚时间)</li>
</ul>
</li>
</ol>
<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/58.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/58.png"><span class="image-caption">img</span></a><br> <a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/59.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/59.png"><span class="image-caption">img</span></a></p>
<h3 id="7-2-4-算法实现"><a href="#7-2-4-算法实现" class="headerlink" title="7.2.4. 算法实现"></a>7.2.4. 算法实现</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">void</span> Graph ::CriticalPath () &#123;<br>    <span class="hljs-type">int</span> i , j ;<br>    <span class="hljs-type">int</span> p, k ;<br>    <span class="hljs-type">float</span> e, l ;<br>    <span class="hljs-type">float</span> * Ve=<span class="hljs-built_in">new</span> <span class="hljs-type">float</span>[n];<br>    <span class="hljs-type">float</span> * Vl=<span class="hljs-built_in">new</span> <span class="hljs-type">float</span>[n];<br>    //初始化Ve数组<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;n ; i++)<br>        Ve[i]=<span class="hljs-number">0</span>;<br>    //开始正向拓扑计算<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;n ; i++) &#123;<br>        Edge &lt;<span class="hljs-type">float</span>&gt; * p=NodeTable[i].adj; <br>        <span class="hljs-keyword">while</span> (p!=<span class="hljs-keyword">NULL</span>) &#123;<br>            k = p.dest;<br>            <span class="hljs-keyword">if</span> (Ve[i]+p. <span class="hljs-keyword">cost</span> &gt; Ve[k])<br>                Ve[k]=Ve[i]+p.<span class="hljs-keyword">cost</span> ;<br>                p=p.link;<br>        &#125;<br>    &#125; <br>    //反向Ve数组，初始化Vl数组<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;n ; i++)<br>        Vl[i]=Ve[n<span class="hljs-number">-1</span>];<br>    //反向计算事件最迟开始时间<br>    <span class="hljs-keyword">for</span> (i=n<span class="hljs-number">-2</span>; i ; i<span class="hljs-comment">--) &#123;</span><br>        p=NodeTable[i].adj;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-keyword">NULL</span>) &#123;<br>            k=p. dest;<br>            <span class="hljs-keyword">if</span> (Vl[k]-p.<span class="hljs-keyword">cost</span>&lt;Vl[i])<br>                Vl[i]=Vl[k]-p.<span class="hljs-keyword">cost</span> ; <br>                p=p. link;<br>        &#125;<br>    &#125; <br>    //用来比较最早开始时间和最晚开始时间，确定是否是关键路径<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;n ;i++) &#123;<br>        p=NodeTable[i].adj;<br>        <span class="hljs-keyword">while</span> (p!=<span class="hljs-keyword">NULL</span>) &#123;<br>            k= p. dest;<br>            e=Ve[i];<br>            l=Vl[k]-p. <span class="hljs-keyword">cost</span>;<br>        <span class="hljs-keyword">if</span>(l==e)<br>            cout&lt;&lt;&quot;&lt;&quot;&lt;&lt;i&lt;&lt;&quot;,&quot;&lt;&lt;k&lt;&lt;&quot;&gt;&quot;&lt;&lt;&quot;is critical Activity&quot;&lt;&lt;endl;<br>            p=p.link;<br>        &#125;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<p><a href="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/60.png"><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-Data-Structure/img/cpt10/60.png"><span class="image-caption">img</span></a></p>
<h1 id="8-2009年统考题-综合应用题"><a href="#8-2009年统考题-综合应用题" class="headerlink" title="8. 2009年统考题(综合应用题)"></a>8. 2009年统考题(综合应用题)</h1><p>带权图 ( 权值非负, 表示边连接的两顶点间的距离) 的最短路径 问题是找出从初始顶点到目标顶点之间的一条最短路径. 假设从初始 顶点到目标顶点之间存在路径, 现有一种解决该问题的方法:</p>
<ol>
<li>设最短路径初始时仅包含初始顶点, 令当前顶点u为初始顶点;</li>
<li>选择离u 最近且尚未在最短路径中的一个顶点v,  加入到最短路径中, 修改当前顶点 u &#x3D; v ;</li>
<li>重复步骤2), 直到u是目标顶点时为止. 请问上述方法能否求得最短路径? 若该方法可行, 请证明之; 否则, 请举例说明.</li>
<li>不可行，可能取到的是局部最优解</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>C++高级程序设计-学习笔记-OOP</title>
    <url>/2023/03/09/c++-OOP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>C++高级程序设计-学习笔记-OOP</p>
<span id="more"></span>



<p>现在应该已经都忘了….对我个人而言，正确的方式应该是边做真实项目边学。科研和工程都是这样</p>
<h1 id="Lecture1-面向对象OOP入门"><a href="#Lecture1-面向对象OOP入门" class="headerlink" title="Lecture1 面向对象OOP入门"></a>Lecture1 面向对象OOP入门</h1><ul>
<li>为什么学了javaOO还要学c++OO?</li>
</ul>
<p>高级程序设计</p>
<ul>
<li>最大的差别：封装。</li>
</ul>
<p>函数放到了class结构体中,形成抽象数据类型ADT,分为属性和行为。 </p>
<p>数据被保护在内部，尽可能地保留细节，只保留外部接口。</p>
<p>减少数据间的耦合</p>
<ul>
<li>默认带有this参数，指向classw</li>
</ul>
<h2 id="0-Concepts"><a href="#0-Concepts" class="headerlink" title="0.Concepts"></a>0.Concepts</h2><p>Program &#x3D; Object1 + … + ObjectN</p>
<p>Object &#x3D; Data + Operation</p>
<p>Message : function call</p>
<ul>
<li><p>面向对象 Object-Oriented</p>
</li>
<li><p>基于对象 Object-Based (Ada)</p>
<ul>
<li>没有继承 without Inheritance</li>
</ul>
</li>
<li><p>好处：</p>
</li>
</ul>
<p>对于外部：</p>
<p>对于内部：</p>
<h2 id="1-类的构成"><a href="#1-类的构成" class="headerlink" title="1.类的构成"></a>1.类的构成</h2><p>函数声明和定义分开</p>
<p>(A.h声明和A.cpp定义分开）</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tdate</span>(a.<span class="hljs-property">h</span>)&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-keyword">void</span> <span class="hljs-title function_">Setdate</span>()<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> <span class="hljs-built_in">year</span>,<span class="hljs-built_in">month</span>;<br>&#125;;<br><br><span class="hljs-keyword">void</span> Tdate::<span class="hljs-title function_">SetDate</span>(<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> d)&#123;<br><span class="hljs-built_in">year</span> = y;<br><span class="hljs-built_in">month</span> = m;<br><span class="hljs-built_in">day</span> = d;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>inline : 函数声明和定义合起来,内联函数</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tdate</span>(a.<span class="hljs-property">h</span>)&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-keyword">void</span> <span class="hljs-title function_">Setdate</span>()&#123;<br>        <span class="hljs-built_in">year</span> = y;<br>        <span class="hljs-built_in">month</span> = m;<br>        <span class="hljs-built_in">day</span> = d;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> <span class="hljs-built_in">year</span>,<span class="hljs-built_in">month</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>毕竟在内存里，private其实仍可以调用</li>
</ul>
<h3 id="对象的三种存储位置"><a href="#对象的三种存储位置" class="headerlink" title="对象的三种存储位置"></a>对象的三种存储位置</h3><p>一个<strong>由C&#x2F;C++编译的程序占用的内存</strong>分为以下几个部分 </p>
<ul>
<li><strong>栈区（stack）</strong>— 由<strong>编译器自动分配释放</strong>，存放<strong>函数的参数值，局部变量</strong>的值等。其<strong>操作方式类似于数据结构中的栈</strong>。 </li>
<li><strong>堆区（heap）</strong> — 一般<strong>由程序员分配释放，若程序员不释放，程序结束时可能由OS回收</strong> 。注意<strong>它与数据结构中的堆是两回事，分配方式倒是类似于链表</strong>。 </li>
<li><strong>全局区（静态区）（static）</strong>—，<strong>全局变量和静态变量的存储是放在一块的</strong>，<strong>初始化的全局变量和静态变量在一块区域</strong>， <strong>未初始化的全局变量、未初始化的静态变量在相邻的另一块区域</strong>。 - <strong>程序结束后有系统释放</strong> </li>
<li><strong>文字常量区</strong> —常量字符串就是放在这里的。<strong>程序结束后由系统释放</strong> </li>
<li><strong>程序代码区</strong>—<strong>存放函数体的二进制代码</strong>。</li>
</ul>
<ol>
<li><p>全局静态</p>
<p>class外声明</p>
</li>
<li><p>栈区</p>
<p>class内直接声明Tdate t,不需要new(?)</p>
</li>
<li><p>堆区</p>
<p>指针指向的new(?)</p>
<p>Tdate *p &#x3D; new Tdate;</p>
<p>p-&gt;Setdate();</p>
<p>频繁调用场合并不适合new，就像new申请和释放内存一样。</p>
</li>
</ol>
<h2 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2.构造函数"></a>2.构造函数</h2><p>对象的初始化，无返回类型，自动调用不可直接调用。可重载</p>
<ul>
<li>编译系统自动提供默认构造函数，无参数</li>
</ul>
<p>对象数组的构造：</p>
<p>A   a[4]; 	&#x2F;&#x2F;调用a[0]、a[1]、a[2]、a[3]的A()<br>A   b[5]&#x3D;{ A(), A(1), A(“abcd”), 2, “xyz“ };</p>
<h3 id="成员初始化表"><a href="#成员初始化表" class="headerlink" title="成员初始化表"></a>成员初始化表</h3><ul>
<li>构造函数的补充</li>
<li><strong>先于构造函数</strong></li>
<li>按类数据成员申明次序</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>	&#123;      <span class="hljs-type">int</span> x;<br>	       <span class="hljs-type">const</span> <span class="hljs-type">int</span> y;<br>	       <span class="hljs-type">int</span>&amp; z;<br>	   <span class="hljs-keyword">public</span>:<br>	       <span class="hljs-built_in">A</span>(): <span class="hljs-built_in">y</span>(<span class="hljs-number">1</span>),<span class="hljs-built_in">z</span>(x), <span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>) <br>	       &#123;  x = <span class="hljs-number">100</span>; &#125;<br>	&#125;;可运行<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CString</span> <br>	&#123;     <span class="hljs-type">char</span>   *p; <br>    	  <span class="hljs-type">int</span>   size;<br><span class="hljs-keyword">public</span>:<br>   		  <span class="hljs-built_in">CString</span>(<span class="hljs-type">int</span> x):<span class="hljs-built_in">size</span>(x),<span class="hljs-built_in">p</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[size])<br>   		  &#123;&#125; <br>	&#125;;报错<br></code></pre></td></tr></table></figure>

<ul>
<li>应优先使用初始化表代替赋值动作</li>
<li>const 成员&#x2F;reference 成员&#x2F;对象成员</li>
</ul>
<p>好处：减轻Compiler负担,效率高（二次-&gt;一次）</p>
<p>坏处：数据成员太多时,不采用本条准则。降低可维护性</p>
<h3 id="析构函数（待深入）"><a href="#析构函数（待深入）" class="headerlink" title="析构函数（待深入）"></a>析构函数（待深入）</h3><p>定义：~NewObject()</p>
<p>对象消亡时,系统自动调用</p>
<ul>
<li>一般为public</li>
<li>也可定义为private，此时不会自动调用，强制自主控制对象存储分配</li>
</ul>
<h3 id="拷贝构造函数（待深入）"><a href="#拷贝构造函数（待深入）" class="headerlink" title="拷贝构造函数（待深入）"></a>拷贝构造函数（待深入）</h3><ul>
<li><p>浅拷贝：将 a 和 obj1 所在内存中的数据按照二进制位（Bit）复制到 b 和 obj2 所在的内存，这种默认的拷贝行为就是浅拷贝</p>
</li>
<li><p>深拷贝：将对象所持有的其它资源一并拷贝的行为叫做深拷贝，我们必须显式地定义拷贝构造函数才能达到深拷贝的目的。</p>
</li>
<li><p>定义：B(const B&amp; b)(B引用类型的b)</p>
</li>
<li><p>创建对象时，用一同类的对象对其初始化</p>
</li>
<li><p>自动调用</p>
</li>
</ul>
<p>默认拷贝构造函数：</p>
<p>​	默认调用成员对象的拷贝构造函数，逐个成员拷贝(member-wise initialization)</p>
<p>自定义拷贝构造函数：</p>
<p>​	默认调用成员对象的默认构造函数（不拷贝了，让程序员指导）</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/image-20221103120849361.png"><span class="image-caption">image-20221103120849361</span></p>
<p> 此例子中，调用了自定义拷贝构造函数</p>
<p>若删去红色，则为蓝色结果。</p>
<h3 id="移动构造函数（待深入）"><a href="#移动构造函数（待深入）" class="headerlink" title="移动构造函数（待深入）"></a>移动构造函数（待深入）</h3><p>定义：A(A&amp; &amp;)</p>
<p>目的：移动对象，减轻拷贝成本，加快效率</p>
<p>拷贝构造函数是先将传入的参数对象进行一次深拷贝，再传给新对象。这就会有一次<strong>拷贝对象的开销</strong>，并且进行了深拷贝，就需要给对象分配地址空间。而移动构造函数就是为了解决这个拷贝开销而产生的。移动构造函数首先将传递参数的内存地址空间接管，然后将内部所有指针设置为nullptr，并且在原地址上进行新对象的构造，最后调用原对象的的析构函数，这样做既不会产生额外的拷贝开销，也不会给新对象分配内存空间。</p>
<ul>
<li>左值、右值：无明确定义。一般指运算符左右的变量和值</li>
<li>引用即变量的别名</li>
</ul>
<p><strong>不自定义</strong>拷贝构造函数和析构函数时，编译器<strong>不会</strong>自动合成移动构造函数。</p>
<p>（要么三个默认，要么全自定义）</p>
<h2 id="2-5-左值引用和右值引用"><a href="#2-5-左值引用和右值引用" class="headerlink" title="2.5 左值引用和右值引用"></a>2.5 左值引用和右值引用</h2><p><strong>左值定义：</strong> </p>
<p>int a &#x3D; 10;</p>
<p>int &amp;var &#x3D; a;</p>
<p>var &#x3D; 20;</p>
<p><strong>右值定义</strong>：</p>
<p>int &amp;&amp;var &#x3D; 10;</p>
<p>C++对于左值和右值没有标准定义，但是有一个被广泛认同的说法：</p>
<ul>
<li>可以取地址的，有名字的，非临时的就是左值；</li>
<li>不能取地址的，没有名字的，临时的就是右值；</li>
</ul>
<p>与指针的区别：</p>
<p>左值引用直接用“.”解引用</p>
<p>指针需要用“-&gt;”</p>
<p>从指令层面来说，没有指针和引用之分，他们都是在地址层面的操作。<br>也就是说，<strong>在我们定义一个引用的时候，底层实际上就是定义了一个指针，只不过在使用的时候会自动加上解引用。</strong></p>
<p>有这么一种说法：引用是一种更安全的指针。<br>而为什么引用比指针安全，这就要提到他们的第一个区别：引用是必须初始化的，而指针可以不初始化。 当我们使用引用的时候，我们可以保证它一定会引用一块内存，而指针会出现空指针和野指针的问题。</p>
<h2 id="3-动态内存"><a href="#3-动态内存" class="headerlink" title="3.动态内存"></a>3.动态内存</h2><h3 id="动态对象"><a href="#动态对象" class="headerlink" title="动态对象"></a>动态对象</h3><p>1.new、delete取代malloc和free的原因：对象的初始化和析构</p>
<p>new&#x2F;delete 可看作操作符</p>
<p>在heap中创建</p>
<ul>
<li>p &#x3D; new A做的事：<ul>
<li>在heap中申请内存</li>
<li>调用A构造函数</li>
<li>返回对象地址，赋值给p</li>
</ul>
</li>
<li>delete p做的事：<ul>
<li>调用p<strong>指向对象</strong>的析构函数</li>
<li>释放内存</li>
</ul>
</li>
<li>delete详解：<ul>
<li>delete后面接着指针，delete后建议顺手指向NULL（避免二次释放）</li>
<li>delete void * 时，不会调用析构（c++重类型的特点）</li>
</ul>
</li>
</ul>
<p>2.堆上对象都是无名对象。必须有指针指向才能访问它们</p>
<h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><p>A *p;</p>
<p>p &#x3D; new A[100];</p>
<p>delete []p;</p>
<p>注意：1.new不能显式初始化，必须有默认构造函数</p>
<p>​			2.delete中的[] 不能省略，否则只释放单个数组</p>
<h3 id="多维数组创建"><a href="#多维数组创建" class="headerlink" title="多维数组创建"></a>多维数组创建</h3><ul>
<li>现多用一维数组模拟。[i * rows + j]</li>
</ul>
<p>define row</p>
<p>define colomn</p>
<p>for循环new创建，</p>
<h2 id="4-Const成员"><a href="#4-Const成员" class="headerlink" title="4.Const成员"></a>4.Const成员</h2><ul>
<li><p>不可改变。如const对象不可改变成员变量</p>
</li>
<li><p>初始化只能放在构造函数的成员初始化表中进行</p>
</li>
<li><p>和static不同</p>
<ul>
<li>const 定义的常量在超出其作用域之后其空间会被释放，而 static 定义的静态常量在函数执行后不会释放其存储空间。</li>
<li>static 表示的是静态的。<strong>类的</strong>静态成员函数、静态成员变量是和类相关的，而不是和类的具体对象相关的。而const 数据成员 只在某个<strong>对象生存期内</strong>是常量，而对于整个类而言却是可变的。</li>
<li>要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现，或者static const。</li>
</ul>
</li>
<li><p>和define不同之处：编译阶段使用。而define只是宏替代字符</p>
</li>
</ul>
<h4 id="Const成员函数（const类下）（待深入）"><a href="#Const成员函数（const类下）（待深入）" class="headerlink" title="Const成员函数（const类下）（待深入）"></a>Const成员函数（const类下）（待深入）</h4><p>class A……</p>
<p><strong>const</strong> A a(0,0);</p>
<p><strong>const成员函数定义</strong>：在函数声明后加const</p>
<p>void A::f() 不能通过编译<br>{  x &#x3D; 1; y &#x3D; 1; }</p>
<p>void A::show() const 能编译<br>{  cout &lt;&lt; x &lt;&lt; y ; }</p>
<p>目的：避免改变const成员变量，方便编译器检查报错。</p>
<p>const类内任何变量不可修改，但指向的内存地址可以修改</p>
<ul>
<li>也可声明为mutable关键字，可修改const成员变量</li>
</ul>
<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>解决问题：同一个类的不同对象如何共享变量</p>
<ul>
<li><p>类对象内部所共享</p>
</li>
<li><p>唯一拷贝</p>
</li>
<li><p>遵循类访问控制</p>
</li>
<li><p>静态成员函数：</p>
<ul>
<li><strong>只能存取静态成员变量，调用静态成员函数</strong></li>
</ul>
</li>
<li><p>静态成员的使用</p>
<ul>
<li>通过对象使用<br>A a;  a.f();</li>
<li>通过类使用<br>A :: f();</li>
</ul>
</li>
<li><p>Resource Control原则：谁创建，谁归还</p>
</li>
</ul>
<p>const static：既全局又不可改，故直接在声明时初始化（不在初始化表）</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>解决问题：类外部不能访问该类的private成员，而通过该类的public方法会降低对private成员的访问效率，缺乏灵活性。</p>
<ul>
<li>分类<ul>
<li>友元函数<ul>
<li>友元函数是指某些虽然不是类成员函数却能够访问类的所有成员的函数。</li>
</ul>
</li>
<li>友元类<ul>
<li>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。</li>
</ul>
</li>
<li>友元类成员函数<ul>
<li>使类B中的成员函数成为类A的友元函数，这样类B的该成员函数就可以访问类A的所有成员了。</li>
</ul>
</li>
</ul>
</li>
<li>作用<ul>
<li>提高程序设计灵活性</li>
<li>数据保护和<strong>对数据的存取效率</strong>之间的一个折中方案</li>
</ul>
</li>
<li>友元不具有传递性</li>
</ul>
<p><strong>实例</strong></p>
<ul>
<li><pre><code>void func() ;
class B;//这种情况下B不是必须的
class C&#123;
    void f();
&#125;;   
class A&#123;
    friend void func();//友元函数
    friend class B;    //友元类:B中的每一个函数都可以访问A的成员函数
    friend void C::f();//友元类成员函数
&#125;;
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><br>  * 友元类成员函数C一定要前声明，否则编译器无法判断内存（B不用前声明)<br><br>## <span class="hljs-number">5.</span>原则<br><br>* 迪米特法则<br><br>努力让接口**完满**且**最小化**<br><br>减少对象间依赖，只和最近的朋友交流<br><br><br><br># Lecture <span class="hljs-number">2</span> 面向对象-继承<br><br>* 本质目的：对数据类型的区分<br>* 继承机制<br>  * 基于目标代码的复用<br>* 对事物进行分类<br>  * 派生类是基类的具体化<br>  * 把事物（概念）以层次结构表示<br>* 增量开发<br><br>## <span class="hljs-number">1.</span>单继承<br><br>* 定义：单括号<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Undergraduate_Student</span> : <span class="hljs-keyword">public</span> Student<br><br>&#123;&#125;<br><br>* 可以访问父类的成员<br><br>* 继承方式<br>  * <span class="hljs-keyword">public</span><br>  * <span class="hljs-keyword">private</span><br>    * **私有**成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。<br>    * 重载<span class="hljs-keyword">virtual</span>或使用基类中的<span class="hljs-keyword">protected</span>成员<br>    * 在设计层面无意义，只用于实现层面<br>  * <span class="hljs-keyword">protected</span><br>    * **保护**成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。<br><br>c++是静态编译的<br><br>* 子类可以使用父类成员，从而修改父类成员权限，但只能从公开（<span class="hljs-keyword">public</span>/<span class="hljs-keyword">private</span>）修改为私有，不能从<span class="hljs-keyword">private</span>修改为其他。<br><br>  * <span class="hljs-keyword">public</span>:<br><br>    ​	<span class="hljs-keyword">using</span> son :: parent x<br><br>* 同名成员可以有多个版本，取决于当前的空间（由定义或::决定）<br><br>### 重写和隐藏<br><br>* ```<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>      <span class="hljs-type">int</span> id;<span class="hljs-comment">//id在Undergraduated_Student中仍然是私有的</span><br>      <span class="hljs-keyword">public</span>:<br>          <span class="hljs-type">char</span> nickname[<span class="hljs-number">16</span>];<br>          <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_ID</span> <span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;id = x;&#125; <br>          <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetNickName</span> <span class="hljs-params">(<span class="hljs-type">char</span> *s)</span> </span>&#123;<span class="hljs-built_in">strcpy</span> (nickname,s);&#125;<br>          <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showInfo</span> <span class="hljs-params">()</span> </span>&#123;cout &lt;&lt; nickname &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; id &lt;&lt; endl ;&#125;<br>          <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showInfo</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;cout &lt;&lt; x &lt;&lt; endl;&#125;<br>  &#125;;<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Undergraduated_Student</span>: <span class="hljs-keyword">public</span> Student &#123;<br>      <span class="hljs-type">int</span> dept_no;<span class="hljs-comment">//学院编号</span><br>      <span class="hljs-keyword">public</span>:<br>          <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setDeptNo</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;dept_no = x;&#125;<br>          <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showInfo</span><span class="hljs-params">()</span></span>&#123;cout &lt;&lt; dept_no &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; nickname &lt;&lt; endl;&#125;<br>          <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_ID</span> <span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;……&#125;<br>          <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showInfo</span><span class="hljs-params">()</span></span>&#123;<br>              cout &lt;&lt; dept_no &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; nickname &lt;&lt; endl;<br>          &#125;<br>      <span class="hljs-keyword">private</span>:<br>          Student::nickname;<span class="hljs-comment">//这样在才能修改可见性</span><br>          <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetNickName</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//新定义了一个private方法，父类对应方法被隐藏</span><br>  &#125;;<br>  Undergraduated_Student us;<br>  us.<span class="hljs-built_in">showInfo</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//可以吗？不可以,因为是新的名空间，重定义后面的名空间访问不到</span><br></code></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>派生类中的showInfo():Overwirtten **重写(绝对不是覆盖)**，隐藏基类的showInfo()函数</p>
</li>
<li><p>如果基类中有一个void ShowInfo(int x)那么是不是从基类可以进行调用呢？</p>
<ol>
<li>不可以(所有被重写函数都被隐藏)</li>
<li>因为重定义<strong>将名空间进行了覆盖</strong></li>
</ol>
</li>
<li><p>父类中的所有的函数都不可见:但是我们可以通过指定名空间来完成访问:<code>using Student::showInfo</code>,所有的版本都可以见，这时候是重写。</p>
</li>
<li><p>匹配不上是不会去别的名空间进行匹配(也就是不会去student那里去匹配)</p>
</li>
</ul>
<h3 id="友元和protected"><a href="#友元和protected" class="headerlink" title="友元和protected"></a>友元和protected</h3><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221115153645995.png"><span class="image-caption">image-20221115153645995</span></p>
<p>友元只能访问当前子类，不能通过派生类访问基类</p>
<ul>
<li>否则protect与public无区别</li>
</ul>
<h3 id="执行次序"><a href="#执行次序" class="headerlink" title="执行次序"></a>执行次序</h3><ul>
<li>派生类对象的初始化<ul>
<li><strong>由基类和派生类共同完成</strong></li>
</ul>
</li>
<li>构造函数的执行次序<ul>
<li>基类的构造函数<br>派生类对象成员类的构造函数<br>派生类的构造函数</li>
</ul>
</li>
<li>析构函数的执行次序<ul>
<li>与构造函数相反</li>
</ul>
</li>
</ul>
<h3 id="默认和自定义构造函数："><a href="#默认和自定义构造函数：" class="headerlink" title="默认和自定义构造函数："></a>默认和自定义构造函数：</h3><ul>
<li>基类构造函数的调用<ul>
<li><strong>缺省执行基类默认构造函数</strong></li>
<li>如果要执行基类的非默认构造函数，则必须在派生类构造函数的成员初始化表中指出<ul>
<li>B(int i, int j): A(i)</li>
</ul>
</li>
</ul>
</li>
<li>拷贝构造函数同理，需在派生类构造函数的成员初始化表中指出基类所选构造函数</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221115154419191.png"><span class="image-caption">image-20221115154419191</span></p>
<h2 id="2-虚函数"><a href="#2-虚函数" class="headerlink" title="2.虚函数"></a>2.虚函数</h2><h3 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h3><figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta">A a;<br>B b;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A<br>a = b 合法，因为b是a的子类<br>对象的身份发生变化<br>属于派生类的属性已不存在<br><br>B* pb;  A* pa = pb; 	   	<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A <br>B  b; 	   A &amp;a=b; 	<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A <br>对象身份没有发生变化<br>基类的引用或指针可以引用或指向派生类对象，不严谨的说，可以说让父类指向子类<br><br><span class="hljs-comment">//测试切片调用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-built_in">int</span> x,y;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-keyword">void</span> f();<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A&#123;<br>    <span class="hljs-built_in">int</span> z;<br>    <span class="hljs-keyword">public</span>:<br>	    <span class="hljs-keyword">void</span> f();<br>	    <span class="hljs-keyword">void</span> g();<br>&#125;;<br><span class="hljs-comment">//把派生类对象赋值给基类对象</span><br>A a;<br>B b;<br>a = b;     <span class="hljs-comment">//OK, </span><br>b = a;     <span class="hljs-comment">//Error</span><br>a.f();     <span class="hljs-comment">//A::f()</span><br><br><span class="hljs-comment">//基类的引用或指针可以引用或指向派生类对象</span><br>A &amp;r_a = b;     <span class="hljs-comment">//OK</span><br>A *p_a = &amp;b;    <span class="hljs-comment">//OK</span><br><br>B &amp;r_b = a;     <span class="hljs-comment">//Error</span><br>B *p_b = &amp;a；   <span class="hljs-comment">//Error</span><br><span class="hljs-comment">//以下两个部分基本是一致的</span><br>func1(A&amp; a)&#123;a.f();&#125;<br>func2(A *pa)&#123;pa-&gt;f();&#125;<br>func1(b);<span class="hljs-comment">//A::f</span><br>func2(&amp;b); <span class="hljs-comment">// B::f??</span><br><span class="hljs-comment">//  func1(b):为什么是A的呢？</span><br>    对于B，A的版本的对应函数被隐藏<br>    静态绑定只看形参类型<br></code></pre></td></tr></table></figure>

<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221122103525109.png"><span class="image-caption">image-20221122103525109</span></p>
<p>子不可变父（丢失信息），父可变子</p>
<p>以上均为<strong>前期绑定</strong></p>
<ul>
<li>静态绑定根据<strong>形参</strong>（前缀）决定</li>
</ul>
<h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><ul>
<li>前期绑定（Early Binding）<ul>
<li>编译时刻确定类型（看前缀）<br>依据对象的静态类型<br>效率高、灵活性差</li>
</ul>
</li>
<li>动态绑定<ul>
<li>运行时刻<br>依据对象的实际类型（动态）<br>灵活性高、效率低</li>
</ul>
</li>
</ul>
<p><strong>默认前期绑定，后期绑定需显式指出：virtual</strong></p>
<ul>
<li><strong>基类中被定义为虚成员</strong>函数，则派生类中对其重定义的成员函数均为虚函数</li>
<li>限制<ul>
<li>类的成员函数才可以是虚函数<br>静态成员函数不能是虚函数<br>内联成员函数不能是虚函数<br>构造函数不能是虚函数<br>析构函数可以（往往）是虚函数</li>
</ul>
</li>
</ul>
<h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221122112207356.png"><span class="image-caption">image-20221122112207356</span>虚函数表的原理：指针偏移</p>
<p>c++类定义<a href="https://so.csdn.net/so/search?q=%E8%99%9A%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">虚函数</a>后，会生成一个void**类型的指针（_vfptr），指向虚函数表的第一个虚函数。同一个类的不同实例共用同一份虚函数表, 它们都通过一个所谓的虚函数表指针vfptr指向该虚函数表。定义类对象时, 编译器自动将类对象的vfptr指向这个虚函数表。</p>
<p>**((char *）p-4）(p)：调用A::f(this)</p>
<ul>
<li><p>注意每一个函数在调用的时候都会传入一个const的this指针</p>
</li>
<li><p>空间上和时间上都付出了代价</p>
<ul>
<li><p>空间:存储虚函数表指针和虚函数表</p>
</li>
<li><p>时间:需要通过虚函数表查找对应函数地址，多调用</p>
</li>
</ul>
</li>
</ul>
<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>f（） &#x3D; 0，不给出函数实现</p>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><ol>
<li>至少包含一个纯虚函数</li>
<li><strong>不能用于创建对象</strong>:抽象类类似一个接口，提供一个框架</li>
<li>为派生类提供框架，派生类提供抽象基类的所有成员函数的实现</li>
</ol>
<h3 id="多个函数"><a href="#多个函数" class="headerlink" title="多个函数"></a>多个函数</h3><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221122113450228.png"><span class="image-caption">image-20221122113450228</span></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>	    A() &#123; f();&#125;<br>	    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span>()</span>;<br>	    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g</span>()</span>;<br>		<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">h</span>()</span>&#123;<br>            f();<br>            g();<br>        &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>: <span class="hljs-title">public</span> <span class="hljs-title">A</span><br>&#123;   <span class="hljs-keyword">public</span>:<br>	    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span>()</span>;<br>	    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g</span>()</span>;<br>&#125;;	<br><span class="hljs-comment">//直到构造函数返回之后，对象方可正常使用</span><br><span class="hljs-comment">//函数调用顺序，重要考试题，依据虚函数表</span><br>B b;      <span class="hljs-comment">// A::A()，A::f, B::B()</span><br><span class="hljs-comment">//为什么调用A的f而不是B的？因为名空间以及B没有构造。 </span><br>A *p= &amp;b;<br>p-&gt;f();   <span class="hljs-comment">//B::f,根据构造函数名确定</span><br>p-&gt;g();   <span class="hljs-comment">//A::g，g是静态绑定，根据引用对象名确定</span><br>p-&gt;h();   <span class="hljs-comment">//A::h, B::f, A::g</span><br></code></pre></td></tr></table></figure>

<ul>
<li>只有寻找虚函数一步是动态，其他都是静态编译</li>
</ul>
<p>虚函数调用非虚就是非虚，所有版本默认调用this，静态编译.</p>
<p>非虚函数调用虚就是虚,根据对象实际类型动态确定</p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><ul>
<li>为了提高程序的可读性，建议后代中虚函数都加上virtual关键字。</li>
<li>保留字override：当使用 override时，编译器会生成错误，而<strong>不会在不提示的情况下创建新的成员函数。</strong>防止漏写virtual</li>
<li>final : 不可以再次重写</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>纯虚函数<ul>
<li>只有接口会被继承</li>
<li>必须提供实现代码</li>
</ul>
</li>
<li>一般虚函数<ul>
<li>接口和缺省实现代码都会被继承</li>
<li>必须继承函数接口</li>
<li>可以继承缺省实现</li>
</ul>
</li>
<li>非虚继承<ul>
<li>原则：绝对不要重新定义继承而来的缺省参数值</li>
</ul>
</li>
</ul>
<h1 id="Lecture-3-多态"><a href="#Lecture-3-多态" class="headerlink" title="Lecture 3 多态"></a>Lecture 3 多态</h1><ul>
<li>概念：同一论域中一个元素有多种解释</li>
<li>形式<ul>
<li>函数重载：静态多态，不同于虚函数的动态多态<ul>
<li>操作符重载</li>
</ul>
</li>
<li>类属多态：template</li>
</ul>
</li>
</ul>
<h2 id="1-函数重载"><a href="#1-函数重载" class="headerlink" title="1.函数重载"></a>1.函数重载</h2><ul>
<li><p>名称同，参数不同</p>
<ul>
<li><p>参数顺序，类型匹配</p>
<ul>
<li><p>最佳匹配</p>
<p>（这个匹配每一个参数不必其他的匹配更差</p>
<p>这个匹配有一个参数更精确匹配）</p>
</li>
<li><p>允许窄转换（大-&gt;小，double-&gt;float)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>静态绑定</p>
</li>
</ul>
<h2 id="2-操作符重载"><a href="#2-操作符重载" class="headerlink" title="2.操作符重载"></a>2.操作符重载</h2><ul>
<li><p>动机：</p>
<ul>
<li>自定义数据类型</li>
<li>提高可读性</li>
<li>提高可扩充性</li>
</ul>
</li>
<li><p>操作符重载就是<strong>函数重载</strong>！！！</p>
</li>
<li><p>+重载实例：</p>
<ul>
<li><p>方式1，操作符重载</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Complex <span class="hljs-keyword">operator</span> + (Complex&amp; x) &#123;  <br>            Complex temp;<br>            temp.real = real + x.real;<br>            temp.imag = imag + x.imag;<br>            <span class="hljs-keyword">return</span> temp;<br>        &#125;<br>c = a.<span class="hljs-keyword">operator</span> + (b);<br></code></pre></td></tr></table></figure>
</li>
<li><p>方式2，全局函数重载</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">Complex operato r+ (Complex&amp; c1 , Complex&amp; c2 ) &#123;<br><span class="hljs-comment">//全局函数重载至少包含一个用户自定义类型</span><br>    Complex temp;<br>    temp.<span class="hljs-built_in">real</span> = c1.<span class="hljs-built_in">real</span> + c2.<span class="hljs-built_in">real</span>;<br>    temp.<span class="hljs-built_in">imag</span> = c1.<span class="hljs-built_in">imag</span> + c2.<span class="hljs-built_in">imag</span>;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<span class="hljs-comment">//一般返回临时变量</span><br><br>Complex a(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),b(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>),c;<br>c = a + b;<span class="hljs-comment">//自动进行翻译</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>++ 自增重载实例</p>
<ul>
<li><pre><code>enum Day &#123; SUN, MON, TUE, WED, THU, FRI, SAT&#125;;
Day&amp; operator++(Day&amp; d)
&#123;  return d= (d==SAT)? SUN: Day(d+1); &#125;
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><br>* <br><br>* ```<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>      int value;<br>      <span class="hljs-keyword">public</span>:<br>          Counter() &#123; value = <span class="hljs-number">0</span>; &#125;<br>          Counter&amp; <span class="hljs-keyword">operator</span> ++()<span class="hljs-comment">//++a 左值</span><br>          &#123;<br>              value ++;<br>              <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>          &#125;<br>          Counter <span class="hljs-keyword">operator</span> ++(int)<span class="hljs-comment">//a++ 右值，无&amp;有哑元int</span><br>          &#123;<br>              Counter temp = *<span class="hljs-keyword">this</span>;<br>              value++;<br>              <span class="hljs-keyword">return</span> temp;<br>          &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>&lt;&lt; 重载：实用</p>
</li>
</ul>
<h2 id="3-可以重载的操作符"><a href="#3-可以重载的操作符" class="headerlink" title="3. 可以重载的操作符"></a>3. 可以重载的操作符</h2><ul>
<li><p>不可以重载的操作符:</p>
<ul>
<li><p><code>.</code>(成员访问操作符)、<code>.*</code>(成员指针访问运算符，如下)、<code>::</code>(域操作符)、<code>?:</code>(条件操作符)、<code>sizeof</code>:也不重载</p>
</li>
<li><p>原因：前两个为了防止类访问出现混乱，<code>::</code>后面不是变量，<code>?:</code>影响理解</p>
</li>
<li><pre><code>class A
&#123;   int x;
    public:
        A(int i):x(i)&#123;&#125; 
        void f() &#123;&#125;
        void g() &#123;&#125;
&#125;;
void (A::*p_f)();//A类成员的函数指针

p_f= &amp;A::f;
(a.*p_f)();
int a = 0;b = 0;
b?(a = 1):(b = 1);//a == b == 1
operator ?: (p,a = 1,b = 1)//均执行了
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-section">## 4.基本原则</span><br><br><span class="hljs-bullet">*</span> 方式：<br><span class="hljs-bullet">  1.</span> 类成员函数（类内）<br><span class="hljs-bullet">  2.</span> <span class="hljs-strong">**带有类参数**</span>的全局函数<br><span class="hljs-bullet">*</span> 遵循原有语法<br><span class="hljs-bullet">  1.</span> 单目/双目（参数个数不同）:一一对应<br><span class="hljs-bullet">  2.</span> 优先级<br><span class="hljs-bullet">  3.</span> 结合性<br><br><span class="hljs-section">## 5.双目操作符的重载</span><br><br><span class="hljs-section">### 1. 类成员函数(双目操作符)</span><br><br><span class="hljs-bullet">1.</span> 方式1<br><br><span class="hljs-bullet">   1.</span> 格式:<span class="hljs-code">`&lt;ret type&gt;operator #(&lt;arg&gt;)`</span><br><br>   this: 隐含，必然是第一个参数<br><br><span class="hljs-bullet">   2.</span> 使用:<br><br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p><class name> a,b;<br>a # b;&#x2F;&#x2F;a -&gt; this<br>a.operator#(b)</class></p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><code class="hljs autohotkey"><br>### <span class="hljs-number">2</span>. 全局函数<br><br><span class="hljs-number">1</span>. 友元:`friend &lt;ret type&gt; operator #(&lt;arg1&gt;,&lt;arg2&gt;)`<br><br><span class="hljs-title">   格式:</span>`&lt;ret type&gt; operator #(&lt;arg1&gt;,&lt;arg2&gt;)`<br><br><span class="hljs-title">   ​		注意:</span>`=`、`()`、`[]`、`-&gt;`不可以作为全局函数重载<br><br>   ​	<span class="hljs-number">1</span>. 如果将这四种符号进行友元全局重载，则会出现一些冲突<br><br><span class="hljs-number">2</span>. 全局函数作为补充:<br><br>   <span class="hljs-number">1</span>. 单目运算符最好重载为类的成员函数<br>   <span class="hljs-number">2</span>. 双目运算符最好重载为类的友元函数<br>      <span class="hljs-number">1</span>. 例子：<span class="hljs-number">10</span> + object 如何重载可用<br><br></code></pre></td></tr></table></figure>
<p>class CL {<br>    int count;<br>    CL(int i){…}&#x2F;&#x2F;10可以直接隐式类型转换<br>    public:<br>        friend CL operator +(int i, CL&amp; a);<br>        friend CL operator +(CL&amp; a, int i);<br>};&#x2F;&#x2F;支持隐式类型转换就行<br>&#x2F;&#x2F;如果最左边不是类对象，则必须作为友元函数</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c"><br><span class="hljs-number">3</span>. 永远不要重载 <span class="hljs-meta">&amp;&amp; 与 || </span><br><br>   <span class="hljs-number">1</span>. 原因：短路时极易出错，类似`?:`<br><br>   <span class="hljs-number">2</span>. ```<br>      if ((p != <span class="hljs-number">0</span>) <span class="hljs-meta">&amp;&amp; (strlen(p) &gt;10)) <span class="hljs-comment">//利用了null短路，故不出错</span></span><br>      if (expressin1 <span class="hljs-meta">&amp;&amp; expression2) <span class="hljs-comment">// 函数调用不会提前结束，故会出错</span></span><br>      if (expression1.operator <span class="hljs-meta">&amp;&amp; (expression2))</span><br>      if (operator <span class="hljs-meta">&amp;&amp; (expression1, expression2))</span><br></code></pre></td></tr></table></figure>

<h2 id="6-单目操作符重载"><a href="#6-单目操作符重载" class="headerlink" title="6.单目操作符重载"></a>6.单目操作符重载</h2><h2 id="7-其他操作符"><a href="#7-其他操作符" class="headerlink" title="7.其他操作符"></a>7.其他操作符</h2><h3 id="1-x3D-号"><a href="#1-x3D-号" class="headerlink" title="1.&#x3D;号"></a>1.&#x3D;号</h3><h3 id="2-号"><a href="#2-号" class="headerlink" title="2.[]号"></a>2.[]号</h3><h3 id="3-号"><a href="#3-号" class="headerlink" title="3.()号"></a>3.()号</h3><h3 id="4-gt-号"><a href="#4-gt-号" class="headerlink" title="4.-&gt;号"></a>4.-&gt;号</h3><ol>
<li>-&gt;为二元运算符，重载的时候<strong>按照一元操作符重载</strong>描述。</li>
</ol>
<figure class="highlight xl"><table><tr><td class="code"><pre><code class="hljs xl">A a;<br><span class="hljs-function"><span class="hljs-title">a</span>-&gt;</span>f();<br><span class="hljs-function"><span class="hljs-title">a</span>.operator-&gt;</span>(f)<br><span class="hljs-function"><span class="hljs-title">a</span>.operator-&gt;</span>()-&gt;<span class="hljs-function"><span class="hljs-title">f</span>() //重载时按一元操作符重载描述,这时，a.operator-&gt;</span>()返回一个指针(或者是已经重定义过-&gt;的对象)<br></code></pre></td></tr></table></figure>

<ol>
<li>例子:画图板程序</li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">CPen</span> &#123;<br>    <span class="hljs-built_in">int</span> m_color;<br>    <span class="hljs-built_in">int</span> m_width;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">void</span> setColor(<span class="hljs-built_in">int</span> c)&#123; m_color = c;&#125;<br>        <span class="hljs-built_in">int</span> getWidth()&#123; <span class="hljs-keyword">return</span> m_width; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">CPanel</span> &#123;<br>    CPen m_pen;<br>    <span class="hljs-built_in">int</span> m_bkColor;<br>    <span class="hljs-keyword">public</span>:<br>        CPen* getPen()&#123;<span class="hljs-keyword">return</span> &amp;m_pen;&#125;<br>        <span class="hljs-built_in">void</span> setBkColor(<span class="hljs-built_in">int</span> c)&#123; m_bkColor =c;&#125;<br>&#125;;<br>CPanel c;<br>c.getPen()-&gt;setColor(<span class="hljs-number">16</span>);<br><span class="hljs-comment">//简单修改，可以返回一个对象内部对象的指针</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">CPen</span> &#123;<br>    <span class="hljs-built_in">int</span> m_color;<br>    <span class="hljs-built_in">int</span> m_width;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">void</span> setColor(<span class="hljs-built_in">int</span> c)&#123; m_color = c;&#125;<br>        <span class="hljs-built_in">int</span> getWidth()&#123;<span class="hljs-keyword">return</span> m_width; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">CPanel</span> &#123;<br>    CPen m_pen;<br>    <span class="hljs-built_in">int</span> m_bkColor;<br>    <span class="hljs-keyword">public</span>:<br>        CPen* getPen()&#123;<span class="hljs-keyword">return</span> &amp;m_pen;&#125;<br>        <span class="hljs-built_in">void</span> setBkColor(<span class="hljs-built_in">int</span> c) &#123; m_bkColor =c;&#125;<br>&#125;;<br>CPanel c;<br>c-&gt;setColor(<span class="hljs-number">16</span>);<br><span class="hljs-comment">//等价于</span><br><span class="hljs-comment">//c.operator-&gt;()-&gt;setColor(16);</span><br><span class="hljs-comment">//c.m_pen.setColor(16)</span><br>c-&gt;getWidth();<br><span class="hljs-comment">//等价于</span><br><span class="hljs-comment">//c.operator-&gt;()-&gt;getWidth();</span><br><span class="hljs-comment">//c.m_pen.getWidth()</span><br>CPanel *p=&amp;c;<br>p-&gt;setBkColor(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>Prevent memory Leak:需要符合compiler控制的生命周期。智能指针自动释放内存</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-type">char</span>)</span></span>;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    A *p = <span class="hljs-keyword">new</span> A;<br>    p-&gt;<span class="hljs-built_in">f</span>();<span class="hljs-comment">//如果出错可能会导致问题</span><br>    p-&gt;<span class="hljs-built_in">g</span>(<span class="hljs-number">1.1</span>);<span class="hljs-comment">//返回值</span><br>    p-&gt;<span class="hljs-built_in">h</span>(<span class="hljs-string">&#x27;A&#x27;</span>);<br>    <span class="hljs-keyword">delete</span> p;<br>&#125;<br><span class="hljs-comment">//更好的管理A对象，不用在任何退出的地方写delete p</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">AWrapper <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A)</span></span>;<br>    p-&gt;<span class="hljs-built_in">f</span>();<span class="hljs-comment">//如果出错可能会导致问题</span><br>    p-&gt;<span class="hljs-built_in">g</span>(<span class="hljs-number">1.1</span>);<span class="hljs-comment">//返回值</span><br>    p-&gt;<span class="hljs-built_in">h</span>(<span class="hljs-string">&#x27;A&#x27;</span>);<br>    <span class="hljs-keyword">delete</span> p;<br>&#125;<br><span class="hljs-comment">//须符合compiler控制的生命周期</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AWrapper</span>&#123;<span class="hljs-comment">//不包含逻辑</span><br>    A* p;<span class="hljs-comment">// ? T p; 支持多个类型</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">AWrapper</span>(A *p) &#123; <span class="hljs-keyword">this</span>-&gt;p = p;&#125;<br>        ~<span class="hljs-built_in">AWrapper</span>() &#123; <span class="hljs-keyword">delete</span> p;&#125;<br>        A*<span class="hljs-keyword">operator</span>-&gt;() &#123; <span class="hljs-keyword">return</span> p;&#125;<br>&#125;;<span class="hljs-comment">//RAII 资源获取及初始化</span><br><span class="hljs-comment">//函数返回，销毁局部指针的时候会直接删除</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>k8s概念整合</title>
    <url>/2023/07/10/k8s%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>Kubernetes的概念和基本原理繁杂。本文对部分个人的疑难混乱概念做了整理</p>
<span id="more"></span>

<p>学习路线：<a href="https://www.infoq.cn/article/9dtx*1i1z8hsxkdrpmhk">Kubernetes 学习路径</a></p>
<ul>
<li><strong>初步了解</strong>，在这个阶段需要对 Kubernetes 有个大体了解，知道一些 Kubernetes 中的一些基本概念和基本的使用方法。</li>
<li><strong>整体学习</strong>，在这个阶段需要对 Kubernetes 有整体全面的了解，知道 Kubernetes 所有核心组件的工作原理。</li>
<li><strong>加深学习</strong>，在这个阶段需要对 Kubernetes 的拓展生态进行了解，包括与 Kubernetes 相关的一些开源组件、持续关注 Kubernetes 社区与 CNCF 社区等。</li>
</ul>
<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h1><h2 id="pods"><a href="#pods" class="headerlink" title="pods"></a><strong>pods</strong></h2><ul>
<li>即容器组，是 Kubernetes 集群中最小的操作单元，如创建、调度、管理、销毁等<br>一个 Pod 包含一个或多个紧密相关的容器，并共享命名空间、网络和存储卷等</li>
<li>隔离container</li>
<li>每个 Pod 都有一个独立IP</li>
<li><img src="https://pic3.zhimg.com/80/v2-d2880255d25a566195e734fb28d8726a_1440w.webp"><span class="image-caption">img</span></li>
</ul>
<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>Node即节点，对应一个物理节点（物理机或者虚拟机），运行和管理Pod的生命周期，以及其他属于节点上的资源对象。</p>
<h2 id="Volume-数据卷"><a href="#Volume-数据卷" class="headerlink" title="Volume 数据卷"></a><strong>Volume 数据卷</strong></h2><p>K8S 支持很多类型的 volume 数据卷挂载，具体请参见**<a href="https://link.zhihu.com/?target=https://kubernetes.io/zh/docs/concepts/storage/volumes/">K8S 卷</a><strong>。前文就“如何理解 volume”提到：“</strong>需要手动 mount 的磁盘<strong>”，此外，有一点可以帮助理解：</strong>数据卷 volume 是 Pod 内部的磁盘资源**。</p>
<p><strong>volume 是 K8S 的对象，对应一个实体的数据卷；而 volumeMounts 只是 container 的挂载点，对应 container 的其中一个参数</strong>。但是，<strong>volumeMounts 依赖于 volume</strong>，只有当 Pod 内有 volume 资源的时候，该 Pod 内部的 container 才可能有 volumeMounts。</p>
<h2 id="Container-容器"><a href="#Container-容器" class="headerlink" title="Container 容器"></a><strong>Container 容器</strong></h2><p>本文中提到的镜像 Image、容器 Container，都指代了 Pod 下的一个<code>container</code>。关于 K8S 中的容器，在 2.1Pod 章节都已经交代了，这里无非再啰嗦一句：<strong>一个 Pod 内可以有多个容器 container</strong>。</p>
<p>在 Pod 中，容器也有分类，对这个感兴趣的同学欢迎自行阅读更多资料：</p>
<ul>
<li><strong>标准容器 Application Container</strong>。</li>
<li><strong>初始化容器 Init Container</strong>。</li>
<li><strong>边车容器 Sidecar Container</strong>。</li>
<li><strong>临时容器 Ephemeral Container</strong>。</li>
</ul>
<p>一般来说，我们部署的大多是<strong>标准容器（ Application Container）</strong>。</p>
<h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a><strong>Deployment</strong></h2><p><strong>作用是管理和控制 Pod 和 ReplicaSet，管控它们运行在用户期望的状态中</strong>。哎，打个形象的比喻，<strong>Deployment 就是包工头</strong>，主要负责监督底下的工人 Pod 干活，确保每时每刻有用户要求数量的 Pod 在工作。如果一旦发现某个工人 Pod 不行了，就赶紧新拉一个 Pod 过来替换它。</p>
<blockquote>
<p>ReplicaSet 的目的是维护一组在任何时候都处于运行状态的 Pod 副本的稳定集合。 因此，它通常用来保证给定数量的、完全相同的 Pod 的可用性。</p>
</blockquote>
<p><img src="https://pic3.zhimg.com/80/v2-7b1633cfca5e301706ffdaa064f38296_1440w.webp"><span class="image-caption">img</span></p>
<h2 id="NameSpace"><a href="#NameSpace" class="headerlink" title="NameSpace"></a>NameSpace</h2><p>在Kubernetes中，Namespace（命名空间）是用于<strong>隔离和管理Kubernetes资源</strong>的一种机制。它可以将Kubernetes集群划分为多个虚拟的集群，每个Namespace中的资源互相隔离，从而实现多租户和多组织之间的资源共享和管理。</p>
<p>Namespace的主要作用包括：</p>
<ol>
<li>隔离资源：不同Namespace中的<strong>资源相互隔离</strong>，避免资源冲突和影响。例如，在同一个集群中，可以将开发、测试和生产环境的资源分别放在不同的Namespace中，从而避免互相干扰和影响。</li>
<li>管理访问控制：<strong>通过Namespace可以实现资源的访问控制和权限管理</strong>。管理员可以为每个Namespace分配不同的角色和权限，使得不同的团队和用户拥有不同的访问权限和操作权限。</li>
<li>管理资源配额：通过Namespace可以限制资源的使用量和配额，从而避免资源滥用和浪费。管理员可以为每个Namespace设置不同的资源配额和限制，例如CPU、内存和存储资源等。</li>
<li>简化部署和管理：通过Namespace可以将相关的资源组织到一起，从而简化资源的部署和管理。管理员可以通过Namespace来自动部署和管理相关的应用程序和服务，使得资源的管理更加高效和可靠。</li>
</ol>
<p>需要注意的是，<strong>不同的Namespace中的资源可以通过Service</strong>和Ingress等对象进行访问和通信。同时，Kubernetes中还有一些默认的Namespace，例如default、kube-system和kube-public等，分别用于存储默认的资源和集群级别的资源。</p>
<h1 id="2-k8s架构"><a href="#2-k8s架构" class="headerlink" title="2.k8s架构"></a>2.k8s架构</h1><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230630142727042.png"><span class="image-caption">image-20230630142727042</span></p>
<h1 id="3-yaml文件例"><a href="#3-yaml文件例" class="headerlink" title="3.yaml文件例"></a>3.yaml文件例</h1><p>以部署一个Pod的yaml文件为例，简单介绍部署所需的关键信息</p>
<figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">apiVersion: v1<br>kind: Pod<br>metadata:<br>  name: memory-demo<br>  namespace: mem-example<br>spec:<br>  containers:<br>  - name: memory-demo-ctr<br>    image: polinux/stress<br>    resources:<br>      limits:<br>        memory: &quot;200Mi&quot;<br>      requests:<br>        memory: &quot;100Mi&quot;<br>    command: [&quot;stress&quot;]<br>    args: [&quot;--vm&quot;, &quot;1&quot;, &quot;--vm-bytes&quot;, &quot;150M&quot;, &quot;--vm-hang&quot;, &quot;1&quot;]<br>    volumeMounts:<br>    - name: redis-storage<br>      mountPath: /data/redis<br>  volumes:<br>  - name: redis-storage<br>    emptyDir: &#123;&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>apiVersion</code>记录 K8S 的 API Server 版本，现在看到的都是<code>v1</code>，用户不用管。</p>
</li>
<li><p><code>kind</code>记录该 yaml 的对象，比如这是一份 Pod 的 yaml 配置文件，那么值内容就是<code>Pod</code>。</p>
</li>
<li><p><code>metadata</code>记录了 Pod 自身的元数据，比如这个 Pod 的名字、这个 Pod 属于哪个 namespace（命名空间的概念，后文会详述，暂时理解为“同一个命名空间内的对象互相可见”）。</p>
</li>
<li><p><code>spec</code>记录了 Pod 内部所有的资源的详细信息，看懂这个很重要：</p>
</li>
<li><ul>
<li><code>containers</code>记录了 Pod 内的容器信息，<code>containers</code>包括了：<code>name</code>容器名，<code>image</code>容器的镜像地址，<code>resources</code>容器需要的 CPU、内存、GPU 等资源，<code>command</code>容器的入口命令，<code>args</code>容器的入口参数，<code>volumeMounts</code>容器要挂载的 Pod 数据卷等。可以看到，<strong>上述这些信息都是启动容器的必要和必需的信息</strong>。</li>
<li><code>volumes</code>记录了 Pod 内的数据卷信息，后文会详细介绍 Pod 的数据卷。</li>
</ul>
</li>
</ul>
<h1 id="4-其他混乱概念"><a href="#4-其他混乱概念" class="headerlink" title="4.其他混乱概念"></a>4.其他混乱概念</h1><h2 id="Service和Deployment"><a href="#Service和Deployment" class="headerlink" title="Service和Deployment"></a>Service和Deployment</h2><ul>
<li>Service监控某一Deployment（并转发其中的端口），进而监控Deployment内部的Container</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-e31e74d4893707f7537113b075df62c4_1440w.webp"><span class="image-caption">img</span></p>
<h2 id="Cluster的访问权限"><a href="#Cluster的访问权限" class="headerlink" title="Cluster的访问权限"></a>Cluster的访问权限<img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230705114203865.png"><span class="image-caption">image-20230705114203865</span></h2><h2 id="不同Port的类型"><a href="#不同Port的类型" class="headerlink" title="不同Port的类型"></a>不同Port的类型</h2><p><img src="https://pic4.zhimg.com/80/v2-62bfa253308a9676f26bbb8beb4b3baf_1440w.webp"><span class="image-caption">img</span></p>
<p><strong>port</strong></p>
<ul>
<li>nodePort： 使用nodeIp：nodePort 从外部访问请求某个service</li>
<li>Port： k8s 集群内部访问service端口， 通过clusterip:port 请求某个service</li>
<li>targetPort：是pod的端口，从port和nodePort来的流量经过kube-proxy流入到后端pod的targetPort上，最后进入容器</li>
<li>containerPort：是pod内部容器的端口，targetPort映射到containerPort</li>
</ul>
<h2 id="pod和Container的关系"><a href="#pod和Container的关系" class="headerlink" title="pod和Container的关系"></a><strong>pod和Container</strong>的关系</h2><ul>
<li>Pod是Kubernetes中最小的可部署对象，它可以理解为一个逻辑主机，可以包含一个或多个Container，以及共享的网络和存储资源。容器是运行应用程序的实际载体，它们可以在同一个Pod中协同工作，或者在不同的Pod中独立运行，从而实现更灵活的应用程序部署和管理。</li>
<li>需要注意的是，在设计Pod时，应该避免将多个不相关的容器放在同一个Pod中。通常情况下，一个Pod应该只包含一个主要容器，例如应用程序容器，以及一些辅助容器，例如日志收集器和监控代理等。这样可以确保Pod的可维护性和可扩展性，并提高应用程序的可靠性和性能。</li>
</ul>
]]></content>
      <categories>
        <category>云原生</category>
      </categories>
  </entry>
  <entry>
    <title>Leetcode个人笔记-medium</title>
    <url>/2024/01/10/leetcode%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>随便刷刷</p>
<span id="more"></span>



<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>动规是由<strong>前一个状态推导</strong>出来的，而贪心是局部直接选最优的</p>
<p>维数相当于需要的状态的个数？</p>
<p><strong>对于动态规划问题，我将拆解为如下五步曲</strong></p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
<p>写代码之前</p>
<ul>
<li>推导状态转移方程</li>
<li>把<strong>状态转移</strong>在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果。</li>
<li>debug: <strong>找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！</strong></li>
</ul>
<h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><strong>121. 买卖股票的最佳时机</strong></h2><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a><strong>贪心</strong></h3><p>因为股票就买卖一次，那么贪心的想法很自然就是取最左最小值，取最右最大值，那么得到的差值就是最大利润。</p>
<p>时间复杂度O()</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++) &#123;<br>     low = <span class="hljs-built_in">min</span>(low, prices[i]);  <span class="hljs-comment">// 取最左最小价格</span><br>     result = <span class="hljs-built_in">max</span>(result, prices[i] - low); <span class="hljs-comment">// 直接取最大区间利润</span><br> &#125;<br></code></pre></td></tr></table></figure>

<h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a><strong>动态规划</strong></h3><p>动规五部曲分析如下：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>dp[i][0] 表示第i天持有股票所得最多现金 ，<strong>这里可能有同学疑惑，本题中只能买卖一次，持有股票之后哪还有现金呢？</strong></p>
<p>其实一开始现金是0，那么加入第i天买入股票现金就是 -prices[i]， 这是一个负数。</p>
<p>dp[i][1] 表示第i天不持有股票所得最多现金</p>
<p><strong>注意这里说的是“持有”，“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态</strong></p>
<p>很多同学把“持有”和“买入”没区分清楚。</p>
<p>在下面递推公式分析中，我会进一步讲解。</p>
<ol>
<li>确定递推公式</li>
</ol>
<p>如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来</p>
<ul>
<li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]</li>
<li>第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]</li>
</ul>
<p>那么dp[i][0]应该选所得现金最大的，所以dp[i][0] &#x3D; max(dp[i - 1][0], -prices[i]);</p>
<p>如果第i天不持有股票即dp[i][1]， 也可以由两个状态推出来</p>
<ul>
<li>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1]</li>
<li>第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：prices[i] + dp[i - 1][0]</li>
</ul>
<p>同样dp[i][1]取最大的，dp[i][1] &#x3D; max(dp[i - 1][1], prices[i] + dp[i - 1][0]);</p>
<p>这样递推公式我们就分析完了</p>
<ol>
<li>dp数组如何初始化</li>
</ol>
<p>由递推公式 dp[i][0] &#x3D; max(dp[i - 1][0], -prices[i]); 和 dp[i][1] &#x3D; max(dp[i - 1][1], prices[i] + dp[i - 1][0]);可以看出</p>
<p>其基础都是要从dp[0][0]和dp[0][1]推导出来。</p>
<p>那么dp[0][0]表示第0天持有股票，此时的持有股票就一定是买入股票了，因为不可能有前一天推出来，所以dp[0][0] -&#x3D; prices[0];</p>
<p>dp[0][1]表示第0天不持有股票，不持有股票那么现金就是0，所以dp[0][1] &#x3D; 0;</p>
<ol>
<li>确定遍历顺序</li>
</ol>
<p>从递推公式可以看出dp[i]都是由dp[i - 1]推导出来的，那么一定是从前向后遍历。</p>
<ol>
<li>举例推导dp数组</li>
</ol>
<p>以示例1，输入：[7,1,5,3,6,4]为例，dp数组状态如下：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210224225642465.png"><span class="image-caption">image</span></p>
<h2 id="1997-访问完所有房间的第一天"><a href="#1997-访问完所有房间的第一天" class="headerlink" title="1997. 访问完所有房间的第一天"></a><strong>1997. 访问完所有房间的第一天</strong></h2><h3 id="前缀和优化"><a href="#前缀和优化" class="headerlink" title="前缀和优化"></a>前缀和优化</h3><p>通过前缀和，我们可以把<strong>连续子数组的元素和转换成两个前缀和的差</strong></p>
<ul>
<li>前缀和大小比原数组大1</li>
<li>时间复杂度：初始化 O(n)。其中n为 nums的长度。</li>
<li>空间复杂度：O(n)</li>
</ul>
<p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/56ceba07-d0ed-41cb-8031-a7aca0da9c79/af358f32-0477-403f-9b05-7ecd9a161f33/Untitled.png"><span class="image-caption">Untitled</span>)</p>
<h3 id="取mod技巧"><a href="#取mod技巧" class="headerlink" title="取mod技巧"></a>取mod技巧</h3><p>在for中取模，防止爆long</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">x = (x + MOD) % MOD; <span class="hljs-comment">// + MOD 避免算出负数</span><br></code></pre></td></tr></table></figure>

<h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><strong>70. 爬楼梯</strong></h2><p>动规五部曲：</p>
<p>定义一个一维数组来记录不同楼层的状态</p>
<ol>
<li>确定dp数组以及下标的含义<ol>
<li>dp[i]： 爬到第i层楼梯，有dp[i]种方法</li>
</ol>
</li>
<li>确定递推公式<ol>
<li>所以dp[i] &#x3D; dp[i - 1] + dp[i - 2] 。在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。这体现出确定dp数组以及下标的含义的重要性！</li>
</ol>
</li>
<li>初始化<ol>
<li>不考虑dp[0]如何初始化，只初始化dp[1] &#x3D; 1，dp[2] &#x3D; 2</li>
</ol>
</li>
<li>确定遍历顺序<ol>
<li><strong>从递推公式dp[i] &#x3D; dp[i - 1] + dp[i - 2];中可以看出</strong>，遍历顺序一定是从前向后遍历的</li>
</ol>
</li>
<li>举例推导dp数组<ol>
<li>如果代码出问题了，就把dp table 打印出来，看看究竟是不是和自己推导的一样。</li>
</ol>
</li>
</ol>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a><strong>拓展</strong></h3><p>这道题目还可以继续深化，就是一步一个台阶，两个台阶，三个台阶，直到 m个台阶，有多少种方法爬到n阶楼顶。</p>
<p>这其实是一个完全背包问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123; <span class="hljs-comment">// 把m换成2，就可以AC爬楼梯这道题</span><br>                <span class="hljs-keyword">if</span> (i - j &gt;= <span class="hljs-number">0</span>) dp[i] += dp[i - j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h1><p>最简单的是推导公式了，推导公式估计看一遍就记下来了</p>
<ul>
<li><strong>难在如何初始化</strong></li>
<li><strong>难在遍历顺序</strong></li>
</ul>
<h2 id="代码模版"><a href="#代码模版" class="headerlink" title="代码模版"></a>代码模版</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_2_wei_bag_problem1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">weight</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 存储每件物品所占空间</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">value</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">// 存储每件物品价值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; weight[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>        cin &gt;&gt; value[j];<br>    &#125;<br>    bagweight  = <span class="hljs-built_in">max</span>(weight) <span class="hljs-comment">// 伪代码</span><br>    <span class="hljs-comment">// dp数组, dp[i][j]代表行李箱空间为j的情况下,从下标为[0, i]的物品里面任意取,能达到的最大价值</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(weight.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(bagweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-comment">// 初始化, 因为需要用到dp[i - 1]的值</span><br>    <span class="hljs-comment">// j &lt; weight[0]已在上方被初始化为0</span><br>    <span class="hljs-comment">// j &gt;= weight[0]的值就初始化为value[0]</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) &#123;<br>        dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 遍历科研物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) &#123; <span class="hljs-comment">// 遍历行李箱容量</span><br>            <span class="hljs-comment">// 如果装不下这个物品,那么就继承dp[i - 1][j]的值</span><br>            <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-comment">// 如果能装下,就将值更新为 不装这个物品的最大值 和 装这个物品的最大值 中的 最大值</span><br>            <span class="hljs-comment">// 装这个物品的最大值由容量为j - weight[i]的包任意放入序号为[0, i - 1]的最大值 + 该物品的价值构成</span><br>            <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[weight.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][bagweight] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="遍历方向如何判断？"><a href="#遍历方向如何判断？" class="headerlink" title="遍历方向如何判断？"></a>遍历方向如何判断？</h2><p><strong>要理解递归的本质和递推的方向</strong>。</p>
<p>dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 递归公式中可以看出dp[i][j]是靠dp[i-1][j]和dp[i - 1][j - weight[i]]推导出来的。</p>
<p>dp[i-1][j]和dp[i - 1][j - weight[i]] 都在dp[i][j]的左上角方向（包括正上方向），那么先遍历物品，再遍历背包的过程如图所示：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/202101101032124.png"><span class="image-caption">image</span></p>
<p>再来看看先遍历背包，再遍历物品呢，如图：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210110103244701.png"><span class="image-caption">image</span></p>
<p>可以看出，虽然两个for循环遍历的次序不同，但是<strong>dp[i][j]所需要的数据就是左上角</strong>，根本不影响dp[i][j]公式的推导！</p>
<ul>
<li>其他变体，就不一定都行了，得看数据是否在左上角</li>
</ul>
<h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><h1 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h1><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归算法的时间复杂度本质上是要看: <strong>递归的次数 * 每次递归中的操作次数</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">function3</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> x;<br><br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">function3</span>(x, n / <span class="hljs-number">2</span>) * <span class="hljs-built_in">function3</span>(x, n / <span class="hljs-number">2</span>)*x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">function3</span>(x, n / <span class="hljs-number">2</span>) * <span class="hljs-built_in">function3</span>(x, n / <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/56ceba07-d0ed-41cb-8031-a7aca0da9c79/d8417409-28e7-4992-bc98-f414ee85a5e1/Untitled.png"><span class="image-caption">Untitled</span>)</p>
<p>这棵满二叉树的节点数量就是<code>2^3 + 2^2 + 2^1 + 2^0 = 15</code>。<strong>时间复杂度忽略掉常数项<code>-1</code>之后，这个递归算法的时间复杂度依然是O(n)</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">function4</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-type">int</span> t = <span class="hljs-built_in">function4</span>(x, n / <span class="hljs-number">2</span>);<span class="hljs-comment">// 这里相对于function3，是把这个递归操作抽取出来</span><br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> t * t * x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> t * t;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>依然还是看他递归了多少次，可以看到这里仅仅有一个递归调用，且每次都是n&#x2F;2 ，所以这里我们一共调用了log以2为底n的对数次。</p>
<p>**每次递归了做都是一次乘法操作，这也是一个常数项的操作，那么这个递归算法的时间复杂度才是真正的O(logn)**。</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p><strong>C++中二维数组在地址空间上是连续的</strong>。</p>
<p>Java的二维数组可能是如下排列的方式：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201214111631844.png"><span class="image-caption">image</span></p>
<h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a>704.二分查找</h2><p><strong>前提是数组为有序数组</strong>，同时题目还强调<strong>数组中无重复元素</strong></p>
<p>区间的定义这就决定了二分法的代码应该如何写，<strong>因为定义target在[left, right]区间，所以有如下两点：</strong></p>
<ul>
<li>while (left &lt;&#x3D; right) 要使用 &lt;&#x3D; ，因为left &#x3D;&#x3D; right是有意义的，所以使用 &lt;&#x3D;</li>
<li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li>
</ul>
<figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> middle = <span class="hljs-built_in">left</span> + ((<span class="hljs-built_in">right</span> - <span class="hljs-built_in">left</span>) / <span class="hljs-number">2</span>);// 防止溢出 等同于(<span class="hljs-built_in">left</span> + <span class="hljs-built_in">right</span>)/<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a><strong>209.长度最小的子数组</strong></h2><p>滑动窗口经典题</p>
<ul>
<li>O（N)时间</li>
</ul>
<p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p>
<ul>
<li>双指针法的一种</li>
<li>思考：如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。<ul>
<li>窗口内是什么？</li>
<li>如何移动窗口的起始位置？</li>
<li>如何移动窗口的结束位置？</li>
</ul>
</li>
</ul>
<p>while后不要加分号’;’ ！！！</p>
<h2 id="54-遍历螺旋矩阵"><a href="#54-遍历螺旋矩阵" class="headerlink" title="54.遍历螺旋矩阵"></a>54.遍历螺旋矩阵</h2><h2 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><strong>59. 螺旋矩阵 II</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// vector前插与后插</span><br>matrix.<span class="hljs-built_in">insert</span>(matrix.<span class="hljs-built_in">begin</span>(),empty1);<br>matrix.<span class="hljs-built_in">push_back</span>(empty2);<br></code></pre></td></tr></table></figure>

<p>思路1：填充0，遇到0则转弯</p>
<ul>
<li>容错率高</li>
</ul>
<p>思路2：定义当前左右上下边界 <code>l,r,t,b</code>.  四个for循环，每个循环后调整边界</p>
<ul>
<li>效率高</li>
</ul>
<p>思路3：四个for循环，每个循环后n-2。套圈思维。奇偶分开处理</p>
<h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><p>处理子串</p>
<p>处理非顺序数组</p>
<p>处理区间和</p>
<h3 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a><strong>560. 和为 K 的子数组</strong></h3><p><strong>前缀和 + 哈希表优化</strong></p>
<ul>
<li>构建前缀和数组，以快速计算区间和；</li>
<li>由于只关心次数，不关心具体的解，我们可以使用哈希表加速运算；</li>
</ul>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="203-移除元素"><a href="#203-移除元素" class="headerlink" title="203.移除元素"></a>203.移除元素</h2><p>养成手动清理内存的习惯。</p>
<ul>
<li>malloc</li>
</ul>
<p>头结点如何移除</p>
<ul>
<li>将头结点向后移动一位就可以</li>
</ul>
<p>逻辑统一化</p>
<ul>
<li>添加虚拟头结点，则不用分类</li>
<li></li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">```cpp<br>ListNode* dummyHead = new ListNode(<span class="hljs-number">0</span>); <span class="hljs-regexp">//</span> 设置一个虚拟头结点<br>        dummyHead-&gt;<span class="hljs-keyword">next</span> = head; <span class="hljs-regexp">//</span> 将虚拟头结点指向head，这样方便后面做删除操作<br>```<br></code></pre></td></tr></table></figure>

<p>空节点处理</p>
<ul>
<li><code>while(fast != NULL &amp;&amp; fast-&gt;next != NULL)</code></li>
</ul>
<h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a>19.<strong>删除链表的倒数第N个节点</strong></h2><p>双指针法。适用于寻找距离尾部第k个节点、寻找环入口、寻找公共尾部入口等。</p>
<p>同样可以添加虚拟头结点</p>
<ul>
<li>最后 return dummyHead-&gt;next;</li>
</ul>
<p>while代替for</p>
<p>- </p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-string">``</span><span class="hljs-string">`cpp</span><br><span class="hljs-string">while(n-- &amp;&amp; fast != NULL) &#123;</span><br><span class="hljs-string">            fast = fast-&gt;next;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">`</span><span class="hljs-string">``</span><br></code></pre></td></tr></table></figure>

<h2 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a><strong>142.环形链表II</strong></h2><p>方法一：哈希表</p>
<ul>
<li>一个非常直观的思路是：我们遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。借助哈希表可以很方便地实现。</li>
<li>O（n）空间，O(n)速度</li>
</ul>
<p>方法二：快慢指针</p>
<ul>
<li>我们使用两个指针，它们起始都位于链表的头部。slow指针每次向后移动一个位置，而 fast指针向后移动两个位置。如果链表中存在环，fast指针最终将再次与 slow指针在环中相遇。</li>
<li>数学计算可知，x&#x3D;z</li>
<li>O（1）空间，O(n)速度</li>
</ul>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><ul>
<li>哈希法是<strong>牺牲了空间换取了时间</strong></li>
<li>遇到需要判断一个元素是否出现过的场景应该第一时间想到哈希法！</li>
</ul>
<p>在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</p>
<table>
<thead>
<tr>
<th>集合</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::set</td>
<td>红黑树</td>
<td>有序</td>
<td>否</td>
<td>否</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::multiset</td>
<td>红黑树</td>
<td>有序</td>
<td>是</td>
<td>否</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::unordered_set</td>
<td>哈希表</td>
<td>无序</td>
<td>否</td>
<td>否</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p>
<table>
<thead>
<tr>
<th>映射</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::map</td>
<td>红黑树</td>
<td>key有序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::multimap</td>
<td>红黑树</td>
<td>key有序</td>
<td>key可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::unordered_map</td>
<td>哈希表</td>
<td>key无序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p>
<p>当我们要使用集合来解决哈希问题的时候，<strong>优先使用unordered_set</strong>，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。</p>
<h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a><strong>242.有效的字母异位词</strong></h2><p>判断字符个数，可以映射字符到26长度的数组（即哈希表）</p>
<ul>
<li>也可使用unordered_map</li>
</ul>
<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><strong>1. 两数之和</strong></h2><p>本题其实有四个重点：</p>
<ul>
<li>为什么会想到用哈希表</li>
<li>哈希表为什么用map</li>
<li>本题map是用来存什么的<ul>
<li>访问过的数组</li>
</ul>
</li>
<li>map中的key和value用来存什么的<ul>
<li>方便查下标</li>
</ul>
</li>
</ul>
<p><strong>什么时候使用哈希法</strong></p>
<ul>
<li>当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。</li>
</ul>
<p>两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。map最合适</p>
<ul>
<li>数组的大小是受限制的，而set元素很少，哈希值太大会造成内存空间的浪费。</li>
<li><strong>这道题目中并不需要key有序，选择std::unordered_map 效率更高！</strong></li>
</ul>
<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><strong>15. 三数之和</strong></h2><p>排序，方便去重</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure>

<ul>
<li>使用哈希法，N^2可行。但最大问题在于去重细节多</li>
<li>使用双指针法，同样N^2，但更容易去重，原因是排序后指针的移动非常方便。而哈希需要单独判断，并且b和c元素的顺序混乱</li>
<li></li>
</ul>
<p><strong>防止越界</strong></p>
<ul>
<li>数组迭代去重，尽量使用num[i-1]而不是i+1</li>
<li>所有取数组操作前&#x2F;<strong>对索引加减后</strong>，都判断是否越界（如nums[right+1]前，判断right!&#x3D;len-1）</li>
</ul>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a><strong>344.反转字符串</strong></h2><ul>
<li>双指针法</li>
</ul>
<p><strong>如果题目关键的部分直接用库函数就可以解决，建议不要使用库函数。</strong></p>
<ul>
<li>不了解库函数时间复杂度</li>
</ul>
<p><strong>如果库函数仅仅是 解题过程中的一小部分，并且你已经很清楚这个库函数的内部实现原理的话，可以考虑使用库函数。</strong></p>
<h2 id="541-反转字符串II"><a href="#541-反转字符串II" class="headerlink" title="541. 反转字符串II"></a><strong>541. 反转字符串II</strong></h2><ul>
<li>固定规律，用for</li>
</ul>
<p>当需要<strong>固定规律</strong>一段一段去处理字符串的时候，可以在for循环的表达式上做做文章。</p>
<h2 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151.翻转字符串里的单词"></a><strong>151.翻转字符串里的单词</strong></h2><p><strong>学会分解步骤</strong></p>
<p>O(1)空间法</p>
<ul>
<li>移除多余空格<ul>
<li>双指针法，把fast的字符移到slow前端，手动添加空格。最后resize(slow)</li>
</ul>
</li>
<li>将整个字符串反转</li>
<li>将每个单词反转</li>
</ul>
<p>双指针法：</p>
<ul>
<li>移除多余空格</li>
<li>从最后开始扫描单词</li>
<li>遇到空格，调整指针添加新字符串</li>
</ul>
<h2 id="28-实现strStr"><a href="#28-实现strStr" class="headerlink" title="28.实现strStr()"></a>28.实现strStr()</h2><ul>
<li>所以整个KMP算法的时间复杂度是O(n+m)的。其中n为文本串长度，m为模式串长度，因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是O(n)，不需要回退。之前还要单独生成next数组，时间复杂度是O(m)。</li>
<li>暴力的解法因为每次都要回退，是O(n × m)，所以<strong>KMP在字符串匹配中极大地提高了搜索的效率。</strong></li>
</ul>
<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><ul>
<li>KMP主要应用在字符串匹配上。</li>
</ul>
<p>KMP的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</strong></p>
<ul>
<li>如何记录已经匹配的文本内容，是KMP的重点：next数组</li>
</ul>
<p>next数组就是一个<strong>前缀表（prefix table</strong>）。</p>
<ul>
<li><p>前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。</p>
</li>
<li><p>前缀表</p>
<p>记录下标i之前（包括i）的字符串中，有多大长度的最长公共前后缀</p>
<ul>
<li>最长公共前后缀定义：长度为前1个字符的子串<code>a</code>，最长相同前后缀的长度为0。长度为前2个字符的子串<code>aa</code>，最长相同前后缀的长度为1。长度为前3个字符的子串<code>aab</code>，最长相同前后缀的长度为0。</li>
</ul>
</li>
</ul>
<p>本质上：当不匹配时，待匹配串回到前缀末端，匹配串继续前行（后缀已与公共前缀匹配）</p>
<p>举一个例子：</p>
<ul>
<li><p>要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。</p>
</li>
<li><p>下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们<strong>找到与其相同的前缀</strong>的后面重新匹配就可以了。</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B22.gif"><span class="image-caption">image</span></p>
</li>
<li><p>找到的不匹配的位置， 那么此时我们要看它的前一个字符的前缀表的数值是多少。</p>
</li>
<li><p>前一个字符的前缀表的数值是2， 所以把下标移动到下标2的位置继续比配。 可以再反复看一下上面的动画。</p>
</li>
</ul>
<p><strong>next数组的构建</strong></p>
<ul>
<li><p>构建和匹配非常相似，</p>
<p>本质上都是当不匹配时待匹配串回到前缀末端，匹配串继续前行（后缀已与公共前缀匹配）</p>
<ul>
<li>求next过程实际上是dp（动态规划），<strong>只与前一个状态有关</strong>：</li>
<li>若不匹配，一直往前退到0或匹配为止</li>
<li>若匹配，则将之前的结果<strong>传递</strong>：</li>
<li>因为之前的结果不为0时，前后缀有相等的部分，所以next[j]所指的实际是与当前值相等的前缀，可视为将前缀从前面拖了过来，就不必将指针从初始开始匹配了，所以之前的结果是可以传递的。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span> </span>&#123;<br>       <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>       next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>           <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]) &#123; <span class="hljs-comment">// j要保证大于0，因为下面有取j-1作为数组下标的操作</span><br>               j = next[j - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 注意这里，是要找前一位的对应的回退位置了</span><br>           &#125;<br>           <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>               j++;<br>           &#125;<br>           next[i] = j;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>模式串匹配文本串的整体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; haystack.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;<br>        j = next[j - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (haystack[i] == needle[j]) &#123;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (j == needle.<span class="hljs-built_in">size</span>() ) &#123;<br>        <span class="hljs-keyword">return</span> (i - needle.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>while 是为了 回退直到前后缀一致</li>
</ul>
<h2 id="459-判断重复字符子串"><a href="#459-判断重复字符子串" class="headerlink" title="459.判断重复字符子串"></a>459.判断重复字符子串</h2><p>解法1：字符串复制，判断新字符串内是否存在原字符串</p>
<ul>
<li><strong>等价转化思维</strong></li>
<li>判断新字符串内是否存在原字符串时，可使用KMP,或是find函数</li>
</ul>
<p>解法2：构造next公共前后缀表</p>
<ul>
<li><p>若next[len-1]不为0，且公共前缀能被len整除，说明存在重复子串</p>
</li>
<li><h2 id="等价转化思维。证明用到string位置间的相等转化"><a href="#等价转化思维。证明用到string位置间的相等转化" class="headerlink" title="等价转化思维。证明用到string位置间的相等转化"></a>等价转化思维。证明用到<strong>string位置间的相等转化</strong></h2><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/56ceba07-d0ed-41cb-8031-a7aca0da9c79/ec0a8b69-5c65-475d-8b54-e3effb9ef8c8/Untitled.png"><span class="image-caption">Untitled</span>)</p>
</li>
</ul>
<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p><strong>两个指针在一个for循环下完成两个for循环的工作</strong></p>
<p>形式多样</p>
<ul>
<li>快慢指针</li>
<li>正向指针 负向指针</li>
</ul>
<p>除了链表一些题目一定要使用双指针，其他题目都是使用双指针来提高效率，一般是将O(n^2)的时间复杂度，降为O(n)</p>
<h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><p>队列是先进先出，栈是先进后出。</p>
<p>常用方法：</p>
<ul>
<li>栈</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 栈：</span><br>stack&lt;<span class="hljs-type">int</span>&gt; s;<br>s.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>s.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br><br>s.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 2 被弹出</span><br><br><span class="hljs-type">int</span> top_element = s.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// top_element = 1</span><br><br><span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">empty</span>()) &#123;<br>  <span class="hljs-comment">// 栈为空</span><br>&#125;<br><br><span class="hljs-type">size_t</span> size = s.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// size = 1</span><br><br>stack&lt;<span class="hljs-type">int</span>&gt; s1, s2;<br>s1.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>s1.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>s2.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br>s2.<span class="hljs-built_in">push</span>(<span class="hljs-number">4</span>);<br><br>s1.<span class="hljs-built_in">swap</span>(s2); <span class="hljs-comment">// 交换</span><br><br><span class="hljs-comment">// 现在 s1 中包含元素 3 和 4，s2 中包含元素 1 和 2</span><br></code></pre></td></tr></table></figure>

<ul>
<li><h2 id="队列：先进先出"><a href="#队列：先进先出" class="headerlink" title="队列：先进先出"></a>队列：先进先出</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">queue&lt;<span class="hljs-type">int</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br><br>q.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 1 被弹出</span><br><br><span class="hljs-comment">// 3. front(): 返回队列首部元素，但不弹出。</span><br><span class="hljs-type">int</span> front_element = q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// front_element = 1</span><br><br><span class="hljs-comment">// 4. back(): 返回队列尾部元素，但不弹出。</span><br><span class="hljs-type">int</span> back_element = q.<span class="hljs-built_in">back</span>(); <span class="hljs-comment">// back_element = 2</span><br><br><span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">empty</span>()) &#123;<br>  <span class="hljs-comment">// 队列为空</span><br>&#125;<br><br><span class="hljs-type">size_t</span> size = q.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// size = 1</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p>底层：</p>
<ul>
<li>队列、栈是以底层容器完成其所有的工作，对外提供统一的接口<ul>
<li>底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。</li>
</ul>
</li>
<li>所以STL中栈往往不被归类为容器，而被归类为<strong>container adapter（容器适配器</strong>）。</li>
</ul>
<p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/56ceba07-d0ed-41cb-8031-a7aca0da9c79/86e838ef-c64f-4fad-b638-c1aaf8971e6a/Untitled.png)"><span class="image-caption">Untitled</span></p>
<ul>
<li>默认是deque。我们也可以指定vector为栈的底层实现，初始化语句如下：<ul>
<li><code>std::stack&lt;int, std::vector&lt;int&gt; &gt; third;  // 使用vector为底层容器的栈</code></li>
<li><code>std::queue&lt;int, std::list&lt;int&gt;&gt; third; // 定义以list为底层容器的队列</code></li>
</ul>
</li>
</ul>
<h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><strong>232. 用栈实现队列</strong></h2><p>双栈模拟，in与out栈</p>
<ul>
<li>本质：每次倒腾，顺序相反，考虑push做文章</li>
<li>关键：保持顺序。<ul>
<li>关键在于<strong>把数据从输入栈倒入输出栈的条件是输出栈为空</strong>，这样就维持了输出栈顶是队列开头的定义，pop与peek不会出错</li>
</ul>
</li>
</ul>
<p>bug:</p>
<ul>
<li><code>while (!inStack.empty()) 而不是for(int i=0;i&lt;in.size();)</code></li>
<li><code>//size是动态的，不建议用</code></li>
</ul>
<h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><strong>225. 用队列实现栈</strong></h2><ul>
<li>本质：每次倒腾，顺序不变。所以考虑pop做文章</li>
<li>解法：一个队列在模拟栈弹出元素的时候只要将<strong>队列头部的元素（除了最后一个元素外） 重新添加到队列尾部</strong>，此时再去弹出元素就是栈的顺序了。</li>
</ul>
<h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><strong>20. 有效的括号</strong></h2><p><strong>分析很重要，代码要囊括所有情况：</strong>有哪几种不匹配的情况</p>
<ol>
<li><p>第一种情况，字符串里左方向的括号多余了 ，所以不匹配。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2020080915505387.png"><span class="image-caption">image</span></p>
</li>
<li><p>第二种情况，括号没有多余，但是 括号的类型没有匹配上。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200809155107397.png"><span class="image-caption">image</span></p>
</li>
<li><p>第三种情况，字符串里右方向的括号多余了，所以不匹配。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200809155115779.png"><span class="image-caption">image</span></p>
</li>
</ol>
<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><strong>739. 每日温度</strong></h2><ul>
<li>压栈可以压index，不一定压数据。map&lt;int,int&gt;的替代方案</li>
</ul>
<p>我怎么能想到用单调栈呢？ 什么时候用单调栈呢？</p>
<ul>
<li><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</strong>。时间复杂度为O(n)。</li>
<li><strong>单调栈的本质是空间换时间</strong>，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，</li>
</ul>
<p>在使用单调栈的时候首先要明确如下几点：</p>
<ol>
<li>单调栈里存放的元素是什么？</li>
</ol>
<ul>
<li>单调栈里<strong>只需要存放元素的下标i</strong>就可以了，如果需要使用对应的元素，直接T[i]就可以获取。</li>
</ul>
<ol>
<li>单调栈里元素是递增呢？ 还是递减呢？(<strong>顺序的描述为 从栈头到栈底的顺序</strong>)</li>
</ol>
<ul>
<li>如果求一个元素右边第一个更大元素，单调栈就是递增的，如果求一个元素右边第一个更小元素，单调栈就是递减的。</li>
<li></li>
</ul>
<p>加入T[6]，需要将栈里的T[5]，T[2]弹出</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2021021912483374.jpg"><span class="image-caption">image</span></p>
<hr>
<p>同理，继续弹出</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2021021912490098.jpg"><span class="image-caption">image</span></p>
<h2 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496.下一个更大元素 I"></a><strong>496.下一个更大元素 I</strong></h2><ol>
<li>没有重复元素，我们就可以用map哈希表来做映射了</li>
<li>求每个元素下一个比当前元素大的元素的位置，用单调栈。</li>
</ol>
<p>push索引下标和值都可以。看输出要求。</p>
<ul>
<li>索引更通用，但会慢</li>
</ul>
<p>时间复杂度: O(m＋n)，其中 m是nums1的长度，n是nums2的长度。我们需要遍历nums2以计算nums2中每个元素右边的第一个更大的值;需要遍历nums1以生成查询结果。</p>
<h2 id="503-下一个更大元素II"><a href="#503-下一个更大元素II" class="headerlink" title="503.下一个更大元素II"></a><strong>503.下一个更大元素II</strong></h2><p>单调栈思路一样。</p>
<p>本篇我侧重说一说如何处理循环数组。</p>
<ul>
<li>法1：更优雅<ul>
<li><code>for (int i = 1; i &lt; nums.size() * 2; i++)</code>  之后的i都变成<code>i % nums.size()</code></li>
</ul>
</li>
<li>法2：似乎更快<ul>
<li>作标志位判断。只用取余count次</li>
</ul>
</li>
</ul>
<h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><strong>42. 接雨水</strong></h2><p>自己写   过了！</p>
<p>暴力解法：</p>
<ul>
<li><p>按列计算。雨水高度为min(lHeight, rHeight) - height。</p>
<ul>
<li>注意lHeight和rHeight是最远的，不是最近的</li>
<li>每一列sum+&#x3D;雨水高度-height</li>
</ul>
<p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/56ceba07-d0ed-41cb-8031-a7aca0da9c79/ca53edfd-3c6e-409a-b86f-f80588603dcc/Untitled.png"><span class="image-caption">Untitled</span>)</p>
</li>
</ul>
<p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/56ceba07-d0ed-41cb-8031-a7aca0da9c79/66a728d1-15de-4425-9954-e8f2dd5bf0b6/20210402091208445.png"><span class="image-caption">20210402091208445.png)</span>)</p>
<h3 id="单调栈-1"><a href="#单调栈-1" class="headerlink" title="单调栈"></a>单调栈</h3><p>为什么用？</p>
<ul>
<li>与<strong>左右找第一个最小&#x2F;最大</strong>有关，找每个柱子左右两边第一个大于该柱子高度</li>
</ul>
<p><strong>1.判断单调顺序</strong></p>
<ul>
<li>从栈头（元素从栈头弹出）到栈底的顺序应该是从小到大的顺序。因为一旦发现添加的柱子高度大于栈头元素了，此时就出现凹槽了<ul>
<li>如果从大到小，只能判断出突出山峰在哪儿</li>
</ul>
</li>
<li>栈头元素就是凹槽底部的柱子，栈头第二个元素就是凹槽左边的柱子，而添加的元素就是凹槽右边的柱子。</li>
</ul>
<p><strong>2.考虑相同处理</strong></p>
<ul>
<li>如果遇到相同高度的柱子，需要使用最右边的柱子来计算宽度。</li>
</ul>
<p><strong>3.栈里要保存什么数值</strong></p>
<p>使用单调栈，也是通过 长 * 宽 , <strong>按行来计算</strong>雨水面积的。</p>
<ul>
<li>长就是通过柱子的高度来计算，宽是通过柱子之间的下标来计算，</li>
<li>栈里就存放下标就行，想要知道对应的高度，通过height[stack.top()] 就知道弹出的下标对应的高度了。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; height[i] &gt; height[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 这里是while,往回计算行直到找到更高的</span><br>    <span class="hljs-type">int</span> mid = st.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 最低点。处理涉及栈中前两个元素和栈外一个元素</span><br>    st.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> h = <span class="hljs-built_in">min</span>(height[st.<span class="hljs-built_in">top</span>()], height[i]) - height[mid];<br>        <span class="hljs-type">int</span> w = i - st.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意减一，只求中间宽度</span><br>        sum += h * w;<br>    &#125;<br>&#125;<br>st.<span class="hljs-built_in">push</span>(i);<br></code></pre></td></tr></table></figure>

<p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/56ceba07-d0ed-41cb-8031-a7aca0da9c79/3551b413-ac19-4ec6-9325-e6392066ecd4/Untitled.png"><span class="image-caption">Untitled</span>)</p>
<h3 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h3><p>每到一个柱子都向两边遍历一遍，这其实是有重复计算的。</p>
<ul>
<li>我们把每一个位置的左边最高高度<strong>记录在一个数组上</strong>（maxLeft），右边最高高度记录在一个数组上（maxRight），这样就避免了重复计算。</li>
</ul>
<p><strong>区分：找最远的max还是最近的max</strong></p>
<p>- </p>
<figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel">```cpp<br>      for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>;i++)&#123;<br>          <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = i-<span class="hljs-number">1</span>;<br>          while(<span class="hljs-built_in">left</span>&gt;=<span class="hljs-number">0</span> &amp;&amp; height[<span class="hljs-built_in">left</span>]&lt;=height[i])&#123;<br>              <span class="hljs-built_in">left</span> = maxLeft[<span class="hljs-built_in">left</span>];<br>          &#125;<br>          maxLeft[i] = <span class="hljs-built_in">left</span>; //跳跃找最近的<span class="hljs-built_in">max</span><br>      &#125;<br><br>      <br>      for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">len</span>;i++)&#123;<br>          <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = i-<span class="hljs-number">1</span>;<br>          maxLeft[i] = <span class="hljs-built_in">max</span>(maxLeft[<span class="hljs-built_in">left</span>],height[i]); // 找最远的<span class="hljs-built_in">max</span><br>      &#125;<br>```<br></code></pre></td></tr></table></figure>

<h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><strong>84. 柱状图中最大的矩形</strong></h2><p>暴力解法：以单个矩形为基准，暴力向两边延伸</p>
<ul>
<li>可以先写暴力找思路</li>
<li>看到时间复杂度为 O(N2) 和空间复杂度为 O(1)的组合，就可以考虑怎么空间换时间</li>
</ul>
<h3 id="双指针-2"><a href="#双指针-2" class="headerlink" title="双指针"></a>双指针</h3><p>双指针解法：同样思路的优化</p>
<ul>
<li>两层for —&gt; <strong>先记录后计算</strong></li>
<li>同样两层for，但向左遍历时跳跃，速度极大加快<ul>
<li>必须记录在数组，才能跳跃</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//记录每一个柱子，向左的 第一个更小 的下标</span><br>minLeft[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 哨兵</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)&#123;<br>    <span class="hljs-type">int</span> left = i<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(left&gt;=<span class="hljs-number">0</span> &amp;&amp; heights[left]&gt;=heights[i])&#123;<br>        left = minLeft[left];<span class="hljs-comment">//跳着找，更快。类似KMP</span><br>    &#125;<br>    minLeft[i] = left;<br>&#125;<br><br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>    res = <span class="hljs-built_in">max</span>(res,heights[i]*(minRight[i]-minLeft[i]<span class="hljs-number">-1</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="单调栈-2"><a href="#单调栈-2" class="headerlink" title="单调栈"></a>单调栈</h3><p>暴力解法的优化，</p>
<ul>
<li><a href="https://programmercarl.com/0042.%E6%8E%A5%E9%9B%A8%E6%B0%B4.html"><strong>42. 接雨水 (opens new window)</strong></a>是找每个柱子左右两边第一个大于该柱子高度的柱子，而本题是找每个柱子左右两边第一个小于该柱子的柱子。所以从栈头（元素从栈头弹出）到栈底的顺序应该是从大到小的顺序！</li>
</ul>
<p><strong>为什么用单调栈</strong></p>
<ul>
<li><p>任何一个长方体，要满足</p>
<p>向左右不能再延伸</p>
<p>的条件，即左右矩形要更小</p>
<ul>
<li>与左右最大&#x2F;最小值有关</li>
<li>在缓存数据的时候是从左向右缓存的，计算出一个结果的顺序是从右向左的，并且<strong>计算完成以后我们就不再需要</strong>了，符合<strong>后进先出的特点</strong>。因此，我们需要的这个作为缓存的数据结构就是<strong>栈</strong>。</li>
</ul>
</li>
</ul>
<p>怎么求</p>
<ul>
<li>栈顶和栈顶的下一个元素以及要入栈的三个元素组成了我们要求最大面积的高度和宽度</li>
<li></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; heights[i] &lt; heights[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 注意while，遍历某一右边界对应的所有左边界。i++为调整右边界</span><br>    <span class="hljs-type">int</span> mid = st.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 中间的最小高度</span><br>    st.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> left = st.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-type">int</span> right = i;<br>        <span class="hljs-type">int</span> w = right - left - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> h = heights[mid];<br>        result = <span class="hljs-built_in">max</span>(result, w * h);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><p>考虑两种特殊的情况：</p>
<ul>
<li>弹栈的时候，栈为空；</li>
<li>遍历完成以后，栈中还有元素；</li>
</ul>
<p>为此可以我们可以在输入数组的两端加上两个高度为 0 （或者是 0.5，只要比 1 严格小都行）的柱形，可以回避上面这两种分类讨论。这两个站在两边的柱形有一个很形象的名词，叫做<strong>哨兵（Sentinel）</strong>。</p>
<blockquote>
<p>如果数组本身是降序的，例如 [8,6,4,2]，在 8 入栈后，6 开始与8 进行比较，此时我们得到 mid（8），rigt（6），但是得不到 left。</p>
</blockquote>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><strong>215. 数组中的第K个最大元素</strong></h2><h3 id="堆解法"><a href="#堆解法" class="headerlink" title="堆解法"></a>堆解法</h3><p>时间复杂度：O(nlog⁡n)</p>
<ul>
<li><p>建堆的时间代价是 O(n)</p>
<ul>
<li>复杂度分析并不是简单相乘：<a href="https://www.hello-algo.com/chapter_heap/build_heap/#823">8.2  建堆操作 - Hello 算法 (hello-algo.com)</a></li>
<li></li>
</ul>
<p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/56ceba07-d0ed-41cb-8031-a7aca0da9c79/9bb9ce05-294e-42d3-8e51-39344e345cc5/Untitled.png"><span class="image-caption">Untitled</span>)</p>
</li>
<li><p>删除的总代价是 O(klog⁡n)</p>
</li>
<li><p>因为 k&lt;n，故渐进时间复杂为 O(n+klog⁡n)&#x3D;O(nlog⁡n)</p>
</li>
</ul>
<p>空间复杂度：O(log⁡n)O(\log n)O(logn)，即递归使用栈空间的空间代价。</p>
<p><strong>建堆</strong></p>
<p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/56ceba07-d0ed-41cb-8031-a7aca0da9c79/82fd7db0-68ae-4cdc-91dc-e1b5d06df179/Untitled.png"><span class="image-caption">Untitled</span>)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">maxHeapify</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> heapSize)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l = i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, r = i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>, largest = i;<br>        <span class="hljs-keyword">if</span> (l &lt; heapSize &amp;&amp; a[l] &gt; a[largest]) &#123;<br>            largest = l;<br>        &#125; <br>        <span class="hljs-keyword">if</span> (r &lt; heapSize &amp;&amp; a[r] &gt; a[largest]) &#123;<br>            largest = r;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (largest != i) &#123;<br>            <span class="hljs-built_in">swap</span>(a[i], a[largest]);<br>            <span class="hljs-built_in">maxHeapify</span>(a, largest, heapSize); <span class="hljs-comment">//向子节点递归</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildMaxHeap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">int</span> heapSize)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = heapSize / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-built_in">maxHeapify</span>(a, i, heapSize); <span class="hljs-comment">// 处理i个元素与其子女为大根堆</span><br>        &#125; <br>    &#125;<br></code></pre></td></tr></table></figure>

<p><strong>删除堆顶</strong></p>
<p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/56ceba07-d0ed-41cb-8031-a7aca0da9c79/8de0a18f-359e-4995-8e29-31416d77bda1/Untitled.png"><span class="image-caption">Untitled</span>)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> heapSize = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">buildMaxHeap</span>(nums, heapSize);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= nums.<span class="hljs-built_in">size</span>() - k + <span class="hljs-number">1</span>; --i) &#123;<br>        <span class="hljs-built_in">swap</span>(nums[<span class="hljs-number">0</span>], nums[i]); <span class="hljs-comment">//除堆顶</span><br>        --heapSize;<br>        <span class="hljs-built_in">maxHeapify</span>(nums, <span class="hljs-number">0</span>, heapSize); <span class="hljs-comment">// 递归重排</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="桶排序解法"><a href="#桶排序解法" class="headerlink" title="桶排序解法"></a>桶排序解法</h3><p>复杂度O(n)，要求数字值不能太大</p>
<blockquote>
<p>在一般情况下，桶排序的时间复杂度为O(N + K)，具体解释如下：</p>
<ol>
<li><strong>桶的创建和元素分配（线性时间复杂度）</strong>：创建桶数组的时间复杂度为O(K)，遍历输入数组将元素分配到各个桶中的时间复杂度为O(N)。</li>
<li><strong>桶内排序（线性时间复杂度）</strong>：对每个非空的桶进行排序的时间复杂度取决于桶内元素的个数和所使用的排序算法。如果桶内元素个数较少，可以使用简单且具有线性时间复杂度的排序算法（如插入排序）。因此，桶内排序的时间复杂度可以视为O(1)。</li>
<li><strong>桶之间的合并（线性时间复杂度）</strong>：将各个桶中的元素按照顺序合并起来的时间复杂度为O(K)。</li>
</ol>
<p>综上所述，桶排序的时间复杂度为O(N + K)，其中N是元素的数量，K是桶的数量。需要注意的是，当K接近N时，桶排序的时间复杂度接近O(N)，因此，桶的数量的选择对于桶排序的性能具有一定的影响。通常情况下，<strong>选择一个合适的桶的数量</strong>可以使得桶排序具有较好的性能。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> buckets[<span class="hljs-number">20001</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            buckets[nums[i] + <span class="hljs-number">10000</span>]++; <span class="hljs-comment">//记录有几个大值</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">20000</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            k = k - buckets[i];<br>            <span class="hljs-keyword">if</span> (k &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> i - <span class="hljs-number">10000</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>MacOS使用入门</title>
    <url>/2023/06/12/mac%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p> MacOS使用入门</p>
<span id="more"></span>



<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20240712191500973.png"><span class="image-caption">image-20240712191500973</span></p>
<h1 id="WIN远程连接"><a href="#WIN远程连接" class="headerlink" title="WIN远程连接"></a>WIN远程连接</h1><p>内网穿透</p>
<ul>
<li>tcp:&#x2F;&#x2F;server.natappfree.cc:45985</li>
</ul>
<p>第三方软件</p>
<ul>
<li>TODESK</li>
</ul>
<h1 id="第三方应用权限"><a href="#第三方应用权限" class="headerlink" title="第三方应用权限"></a>第三方应用权限</h1><ul>
<li><code>sudo xattr -r -d com.apple.quarantine</code></li>
<li><a href="https://www.maczl.com/macOS_Notarization.html">当Mac软件提示损坏时可以绕过公证或者在Mac本地为软件签名 - 苹果Mac版_注册机_安装包 | Mac助理 (maczl.com)</a></li>
</ul>
<h1 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h1><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20240712191440563.png"><span class="image-caption">image-20240712191440563</span></p>
<p>搜索</p>
<ol>
<li><strong>进入命令模式</strong>：在 Normal 模式下，按下 <strong><code>/</code></strong> 键来进入搜索模式。</li>
<li><strong>输入搜索字符串</strong>：在命令行中输入你想要搜索的字符串，并按下回车键。例如，如果你想要搜索单词 “example”，你就可以输入 <strong><code>/example</code></strong> 然后按下回车键。</li>
<li><strong>浏览搜索结果</strong>：按下回车键后，Vim 会将光标移动到第一个匹配的位置。你可以使用 <strong><code>n</code></strong> 键来跳转到下一个匹配项，使用 <strong><code>N</code></strong> 键跳转到上一个匹配项。</li>
<li><strong>退出搜索模式</strong>：你可以按下 <strong><code>Esc</code></strong> 键来退出搜索模式。</li>
</ol>
<p>创建新行</p>
<ol>
<li>在当前行下方创建新行<ul>
<li>在 Normal 模式下，按下 <strong><code>o</code></strong> 键（小写字母 o）。这会在当前行的下方插入一个新行，并将光标移动到新行的开头，以便你可以输入内容。</li>
</ul>
</li>
<li>在当前行上方创建新行<ul>
<li>在 Normal 模式下，按下 <strong><code>O</code></strong> 键（大写字母 O）。这会在当前行的上方插入一个新行，并将光标移动到新行的开头。</li>
</ul>
</li>
<li>在当前行插入一个新行<ul>
<li>在 Normal 模式下，按下 <strong><code>Shift</code></strong> + **<code>Enter</code>**。这会在当前行插入一个新行，但不会移动光标，你可以继续在当前行输入内容。</li>
</ul>
</li>
</ol>
<p>撤销操作通常使用 <strong><code>u</code></strong> 键，它代表”undo”</p>
<p>重做撤销的操作（即取消撤销）使用 <strong><code>Ctrl</code></strong> + <strong><code>r</code></strong> 键</p>
<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><p>ommand+F3：可以快速显示桌面</p>
<p><strong>一.修饰键符号</strong></p>
<p>Command &#x3D;⌘</p>
<p>Shift &#x3D;⇧</p>
<p>Option &#x3D;⌥</p>
<p>Control&#x3D; ⌃</p>
<p>Caps Lock &#x3D;⇪</p>
<p>Fn</p>
<p><strong>二.程序控制</strong></p>
<p>⌘+Q：退出程序</p>
<p>⌘+W：关闭窗口</p>
<p>⌘+M：最小化</p>
<p>⌘+H：隐藏当前窗口</p>
<p>⌘+⌥+H：隐藏其他所有窗口</p>
<p>⌘+Tab：切换应用</p>
<p><strong>三、终端快捷键</strong></p>
<p><strong>⌃ + u：清空当前行</strong></p>
<p><strong>⌃ + a：移动到行首</strong></p>
<p><strong>⌃ + e：移动到行尾</strong></p>
<p><strong>⌃ + f：向前移动</strong></p>
<p>⌃ + b：向后移动</p>
<p>⌃ + p：上一条命令</p>
<p>⌃ + n：下一条命令</p>
<p>⌃ + r：搜索历史命令</p>
<p>⌃ + y：召回最近用命令删除的文字</p>
<p>⌃ + h：删除光标之前的字符</p>
<p>⌃ + d：删除光标所指的字符</p>
<p><strong>⌃ + w：删除光标之前的单词</strong></p>
<p><strong>⌃ + k：删除从光标到行尾的内容</strong></p>
<p>⌃ + t：交换光标和之前的字符</p>
<p><strong>三.访达 快捷键</strong></p>
<p>⌘+N：打开新窗口</p>
<p>⌘ + t：新建标签页</p>
<p>⌘+E：推出所选磁盘或宗卷</p>
<p>⇧+⌘+O：打开文稿文件夹</p>
<p>⇧+⌘+D：打开桌面文件夹</p>
<p>⌘+Delete：将文件移至废纸篓</p>
<p><strong>四.浏览器快捷键</strong></p>
<p>⌘+T：新建标签页</p>
<p>⇧+⌘+T：恢复关闭的标签页（Chrome）</p>
<p>⌘+L：快速输入网址</p>
<p>⌘+R：刷新页面</p>
<p>⌘++&#x2F;—：放大&#x2F;缩小页面</p>
<p>⌘+0：恢复默认大小</p>
<p>⇧+空格键&#x2F;空格键：滚动页面</p>
<h1 id="brew常用命令"><a href="#brew常用命令" class="headerlink" title="brew常用命令"></a>brew常用命令</h1><h2 id="1、安装卸载软件"><a href="#1、安装卸载软件" class="headerlink" title="1、安装卸载软件"></a>1、安装卸载软件</h2><ol>
<li><code>brew --version</code> 或者 <code>brew -v</code> 显示brew版本信息</li>
<li><code>brew install &lt;formula&gt;</code> 安装指定软件</li>
<li><code>brew uninstall &lt;formula&gt;</code> 卸载指定软件</li>
<li><code>brew list</code> 显示所有的已安装的软件</li>
<li><code>brew search text</code> 搜索本地远程仓库的软件，已安装会显示绿色的勾</li>
<li><code>brew search /text/</code> 使用正则表达式搜软件</li>
<li><code>brew info &lt;formula&gt;</code> 显示指定软件信息</li>
<li><code>brew reinstall &lt;formula&gt;</code> 重新安装指定软件，先卸载后安装</li>
<li><code>brew install &lt;formula&gt; --build-from-source</code> 源码安装指定软件，可以给定指定参数</li>
<li><code>brew commands</code> 列出所有可用命令</li>
</ol>
<h2 id="2、升级软件相关"><a href="#2、升级软件相关" class="headerlink" title="2、升级软件相关"></a>2、升级软件相关</h2><ol>
<li><code>brew update</code> 自动升级homebrew （从github下载最新版本）</li>
<li><code>brew outdated</code> 检测已经过时的软件</li>
<li><code>brew upgrade</code> 升级所有已过时的软件，即列出的以过时软件</li>
<li><code>brew upgrade &lt;formula&gt;</code> 升级指定的软件</li>
<li><code>brew pin &lt;formula&gt;</code> 禁止指定软件升级</li>
<li><code>brew unpin &lt;formula&gt;</code> 解锁禁止升级</li>
<li><code>brew upgrade --all</code> 升级所有的软件包，包括未清理干净的旧版本的包</li>
<li><code>brew edit &lt;formula&gt;</code> 编辑软件，不会的情况下慎用</li>
<li><code>brew tap</code> 列出本地资源仓库，其中 homebrew 是默认仓库，其它都是第三方仓库</li>
<li><code>brew tap &lt;user/repo&gt;</code> 添加第三方仓库，命名的规则按照github来定的。<a href="https://links.jianshu.com/go?to=https://docs.brew.sh/Taps">使用</a></li>
<li><code>brew untap &lt;user/repo&gt;</code> 删除仓库</li>
<li><code>brew deps &lt;formula&gt;</code> 查看指定软件依赖于哪些软件</li>
<li><code>brew uses &lt;formula&gt;</code> 查看指定软件被哪些软件所依赖</li>
</ol>
<h2 id="3、清理相关"><a href="#3、清理相关" class="headerlink" title="3、清理相关"></a>3、清理相关</h2><p>homebrew再升级软件时候不会清理相关的旧版本，在软件升级后我们可以使用如下命令清理</p>
<ol>
<li><code>brew cleanup -n</code> 列出需要清理的内容</li>
<li><code>brew cleanup &lt;formula&gt;</code> 清理指定的软件过时包</li>
<li><code>brew cleanup</code> 清理所有的过时软件</li>
<li><code>brew unistall &lt;formula&gt;</code> 卸载指定软件</li>
<li><code>brew unistall &lt;fromula&gt; --force</code> 彻底卸载指定软件，包括旧版本</li>
</ol>
<p>通过brew安装的文件会自动设置环境变量，所以不用担心命令行不能启动的问题。</p>
]]></content>
      <categories>
        <category>电脑技巧</category>
      </categories>
  </entry>
  <entry>
    <title>友链</title>
    <url>/2099/01/01/%E5%8F%8B%E9%93%BE/</url>
    <content><![CDATA[<p>来找我和我的朋友们玩。</p>
<span id="more"></span>



<p>💗<a href="https://quas-modo.github.io/">quas-modoCarpe diem</a> pluck the day</p>
<p>💗<a href="https://cardigan1008.fun/">cardigan1008’s blog</a> 倪佬</p>
<p>💗<a href="https://pengzna.top/">Pengzna</a> 好好学习 好好生活！</p>
<p>💗<a href="https://naturalifica.top/">怀明带你夜生活</a> 数学爱好者</p>
<p>💗<a href="https://ericcoderg.top/">EricCoderG</a> 耿佬</p>
<p>💗<a href="https://eumendies.me/">Eumendies</a> 刘总</p>
]]></content>
      <categories>
        <category>杂文</category>
      </categories>
  </entry>
  <entry>
    <title>人体神经网络调参不完全指南</title>
    <url>/2022/07/08/%E4%BA%BA%E4%BD%93%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>用调参的方式理解人体健康状态</p>
<span id="more"></span>

<p>转自知乎与个人整理。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>去年 5 月曾经写了一篇文章介绍了下 <a href="https://zhuanlan.zhihu.com/p/371254789">Lex Fridman 大佬的日常生活安排</a>，后续我也根据他的方法对自己的日常生活做了一系列规范和改进。这一年整体实行下来，效果还是非常显著的，本文的最后会对我的一些实践以及借助的工具做一些分享。</p>
<p>最近几个月，偶然在油管上看到了个 <a href="https://link.zhihu.com/?target=https://youtu.be/2ekdc6jCu2E">Rich Roll 采访 Andrew Huberman 的 podcast</a>，介绍了如何提升我们日常工作，学习表现的相关神经科学原理与可以利用的“工具”，瞬间打开了一扇新世界的大门。后续又一连追了好几集 Huberman 自己的  podcast，从各个方面了解了一下跟我们日常生活，健康，学习，工作，锻炼等方面相关的知识。与其它很多讲“养生”的文章和视频最大的区别在于，Huberman 本身是斯坦福的神经科学教授，其中讲述的内容都是来自于高质量，peer reviewed 的科学研究成果，从机体工作原理出发，非常细致的介绍了相关的实验和结论，并给出了很多实操建议（很多都是零成本，不是搞推销的……）。</p>
<p>通过一系列的学习，逐渐有种学习了各种人类的“组成和操作原理”的感觉。通过一系列的工具和实践，我们也可以<strong>像调优软件程序那样来“调优”我们自身的人体系统</strong>。这篇文章就来介绍一些相关的知识内容。注意，原版的 podcast 中有非常多专业性的阐述，在这篇文章中基本都去掉了，尽量以故事性的描述来讲解，相对会比较好理解。当然准确性也会因此有所下降，如果希望获取更专业的内容，强烈建议观看 <a href="https://link.zhihu.com/?target=https://hubermanlab.com/">原版的 podcast 内容</a>。</p>
<h2 id="睡眠"><a href="#睡眠" class="headerlink" title="睡眠"></a>睡眠</h2><p>如果你想要获得健康，更好的工作学习状态，提升生理健康如免疫，新陈代谢，以及心理健康如更好的心情，专注能力等，最最重要的前提是拥有一个良好的睡眠。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>睡眠最重要的控制机理是我们内在的生物钟。随着生物钟的影响，我们体内的各类化学物质会发生变化，体温也随之改变，会影响我们的各种内在状态和外在行为。Huberman  教授很形象的描述了这个“生物钟”的具体作用方式：在早上，身体释放的皮质醇（cortisol）和肾上腺素（aderenaline）会让我们醒来，同时还会设定松果体释放褪黑素的倒计时钟，会在十多个小时之后让我们感到困意再次入睡。</p>
<p>影响这个生物钟的最大因素是光照。我们的眼睛除了能够看到东西，另外一个重大的作用就是<strong>通过黑视素神经节细胞来接收光照信息，用以设定我们的内在生物钟</strong>。这也是为什么有时候我们通宵工作之后，虽然已经持续很久时间没有睡眠了，但随着太阳升起，整体的生物钟被设定到了类似起床时的状态，各类化学物质的释放会让我们突然感觉又有精神了。后续很多最佳实践里也都跟这个原理相关，我们需要控制自己接收光照的时间点，类型和时长。</p>
<p>此外，<strong>体温也是一个用于控制我们生物钟的手段</strong>。一般来说我们的体温会从深睡眠中比较低的状态逐渐升高，到醒来后持续上升。到了一天的后半段会开始逐渐下降，直到再次进入睡眠。</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>基于上面的原理，Huberman 教授提供了一系列提升睡眠的最佳实践：</p>
<ul>
<li><p>皮质醇的释放与接触阳光有关，因此如果想尽快醒来且保持日间良好的精神状态，<strong>起床后应该到外面去接触阳光，持续 2-10 分钟</strong>。这对于血压控制，心理状态，<strong>设定睡眠的“倒计时钟”</strong>等都有很大好处。户外日光的效果最好，如果是人造光源，蓝光的效果会比较好，且最好是上部（天空的位置）的光源。根据光照强度推算，隔着窗户接收日光的强度会降低 50%以上，而达到同样效果所需要的光照时间则需要 50 到 100  倍。有意思的是，这一点对于视障人士也有效，因为前面提到的黑视素神经节细胞并不是用于视觉成像的细胞。</p>
</li>
<li><p>对应的，<strong>在晚上要尽量减少光源的接触</strong>，因为这会扰乱我们的生物钟，让身体系统误以为是在白天。尤其是晚上 11 点到次日凌晨 4 点之间接收光源，会抑制后续几天的多巴胺的释放，<strong>影响心情，心理健康，专注度，学习能力，新陈代谢</strong>等等。关于多巴胺的作用和机理，后面会再单独介绍。</p>
</li>
<li><p>如果不可避免需要在晚上接触光源，处于较低位置，暗淡的红光，蜡烛之类的会相对好一些。如果要看电脑，建议使用 <strong>blue blockers 眼镜</strong>，这跟一些电脑软件会自动调节屏幕色温的效果可能类似。</p>
</li>
<li><p><strong>傍晚观察落日</strong>，对于后续入睡也有帮助，甚至能减轻晚上摄入光照的负面影响，有点神奇。</p>
</li>
<li><p>人一天中的精神状态一般会在中间有个短暂的低谷，所以午睡对于有些人可能是有帮助的。也可以用一些其它的非睡眠深度休息的方式来替代，如 <a href="https://link.zhihu.com/?target=https://youtu.be/M0u9GST_j3s">Yoga Nidra</a>，冥想，自我催眠（可以利用一些 App）等。</p>
</li>
<li><p>体温对生物钟周期的影响：</p>
</li>
<li><ul>
<li>早上洗冷水澡，会让人快速升温，从而把睡眠周期往前移（早起）。</li>
<li><strong>晚上锻炼身体</strong>×，会让人保持高体温，从而延后周期（晚睡）。</li>
<li>可以选购一些<strong>自动控制体温的智能床垫</strong>来提升睡眠质量。</li>
</ul>
</li>
<li><p>一般建议的锻炼时间：醒来后 30 分钟，3 小时和 11 小时这三个时间点。不过总体来看好像影响度比较小。</p>
</li>
<li><p>饮食和药物因素：</p>
</li>
<li><ul>
<li>咖啡因会占据腺苷（adenosine）的受体，阻断入睡的信号。有不少文章都提到<strong>中午之后尽量不要喝咖啡</strong>，但 Huberman 表示没有科学实验表明咖啡因对所有人的效果是一样的，得根据自己的测试情况来。比如他自己在下午 5 点喝咖啡也能正常入睡。</li>
<li><strong>镁</strong>，对入睡有帮助。</li>
<li>芹黄素也能帮助入睡，但要注意对雌性激素的影响。</li>
<li>建议<strong>不要摄入太多牛磺酸</strong>。</li>
<li>不建议通过摄入褪黑素来帮助入睡，褪黑素药物本身的规格把控不严格，且<strong>褪黑素容易引起抑郁情绪。</strong></li>
<li>中午可以吃低卡路里以及含酪氨酸的食物，如坚果，大豆，部分蔬菜等，提升多巴胺，肾上腺素，保持清醒。</li>
<li>晚上则可以吃点淀粉，白肉等富含色氨酸的食物，进而转化为血清素，会让人更加平静，容易入睡。</li>
</ul>
</li>
<li><p>对于绝大多数人，**<u>6-8 小时</u>**的睡眠时长是比较健康的。</p>
</li>
<li><p>对于各类药物的检索可以参考：<a href="https://link.zhihu.com/?target=https://examine.com/">examine.com</a>。</p>
</li>
</ul>
<h2 id="饮食"><a href="#饮食" class="headerlink" title="饮食"></a>饮食</h2><p>在前面 Lex 的分享中，提到了他采取了生酮饮食以及 fasting（禁食）的习惯，这引起了我对于饮食习惯的注意。Huberman 教授正好也有几个 podcast 介绍了 fasting，肠道健康等话题，很有意思。</p>
<h3 id="Fasting-的背景"><a href="#Fasting-的背景" class="headerlink" title="Fasting 的背景"></a>Fasting 的背景</h3><p>我们可以把身体跟进食相关的化学状态分成 2 类：</p>
<ol>
<li>吃饱了的状态，也就是血糖含量较高的状态。此时我们身体会更活跃的进行体内细胞的复制与成长。</li>
<li>禁食的状态，也就是血糖含量较低的状态。此时我们的身体会更活跃的进行体内细胞的修复与清理（autophagic）。</li>
</ol>
<p>由于睡眠时我们天然是不吃东西的，所以一般来说睡眠中的一部分时间会使我们处于禁食状态，饮食时间的选择实际上就是在控制上述两个状态的持续时间和平衡关系。比较有意思的是世界上很多民族文化和宗教中，都有一些跟禁食相关的习俗，甚至会持续很多天。</p>
<p>在 2012 年，科学家开始对小白鼠做实验，把他们分成两大组，一组可以在一天中的任何时间吃东西，而另一组只能在固定的 8  小时里吃东西。在大组里再区分小组，给小白鼠吃健康的和不健康的食物。结果发现，只能在 8  小时里吃东西的小白鼠们，即使吃的是不健康的高脂肪食物，他们的健康水平仍然得到了保持甚至提高，相比所有不做限制的组都有明显的提升。</p>
<p>这个研究震动了学术界，后续又有非常多的针对人类，不同性别，不同年龄，不同职业（包括运动员）的各种实验与论文发表，科学家们发现这种<strong>间歇性禁食状态对于身体有非常多的好处</strong>，包括：促进肝脏健康，胆汁酸代谢，炎症自愈，保持体重，提升 brown fat 储备（对健康有益），防止非酒精性脂肪肝，血糖控制，肠道健康等等。如果养成间歇性禁食的习惯 60 天以上，还会让我们的身体倾向于代谢脂肪来供能，控制体重。</p>
<p>因此，Huberman 教授指出，<strong>何时进食，与吃什么东西，其实是同等重要的</strong>。这个研究也让很多学术界的研究人员自己也都养成了 fasting 的习惯，包括 Huberman 自己。</p>
<h3 id="Fasting-的实践"><a href="#Fasting-的实践" class="headerlink" title="Fasting 的实践"></a>Fasting 的实践</h3><p>由于长时间的禁食难度较大，所以绝大多数的研究都专注于间歇性禁食，也就是 time restricted  feeding。简单来说就是跟前面的小白鼠实验一样，在一天的固定时间段来吃东西（跟睡眠周期对齐），而其它时间段都不摄入任何食物的做法。这里简单整理为基础和高阶两个版本：</p>
<ul>
<li>基础：如果想享受 fasting 的基础收益，最简单的执行原则是<strong>起床后至少 1 小时内不要吃东西，同时睡前的 2-3 小时不要吃任何东西</strong>。</li>
<li>高阶：目前研究结果中<strong>最理想的进食窗口是 8 小时</strong>，结合社会习俗等，一般比较合理的时间在 10-18 点或 12-20 点的范围。看起来<strong>不吃早饭并不是什么坏事</strong>（？）</li>
<li>作者特地温馨提醒，如果想通过健身来增肌，建议可以把这个时间窗口往前移，因为<strong>早上摄入蛋白质会对肌肉增长有益</strong>。而健身的时间可以自由选择。</li>
<li>尽量<strong>保证这个窗口时间的稳定性</strong>，也非常重要。否则就跟频繁倒时差产生的效果差不多，会打不少收益折扣。</li>
<li>如果想尝试高阶 fasting，建议逐渐切换进食习惯，例如每两天缩短 1 小时的进食窗口，逐渐达到理想的 8 小时。</li>
</ul>
<p>值得注意的是，这里说的不吃任何东西，并不是说连水也不能喝。从前面的背景可以看到，是否处于禁食状态，主要依据是血糖水平，因此：</p>
<ul>
<li>喝水，茶，咖啡（不加牛奶）等，并不会中断禁食。但<strong>一勺糖的摄入就会中断</strong>。</li>
<li>晚饭后想尽快进入禁食状态，可以做一些轻量运动，比如散步等，加快血糖清理。</li>
<li>二甲双胍，黄连素（berberine）等可以直接促进血糖清理。肉桂皮，柠檬汁，也能轻微降低血糖。</li>
</ul>
<p>最后，如果禁食期间觉得有些头晕，颤抖，并不需要立刻进食或摄入糖分。可以<strong>喝一点盐水（可以加柠檬汁）</strong>，一般就能很好的缓解症状。这让我想起 Lex 会提到了会服用药片来补充各种电解质元素，比如钠，镁，钾等。</p>
<h3 id="饮食与消化道健康"><a href="#饮食与消化道健康" class="headerlink" title="饮食与消化道健康"></a>饮食与消化道健康</h3><p>由于我个人的肠胃功能比较差，所以也特别关注了一下消化道健康的话题。Huberman 邀请了一位非常知名的微生物学家 Sonnenburg 来介绍肠胃微生物群落与我们的健康之间的关系，也是学到了很多新的知识：</p>
<ul>
<li>肠道的微生物群不仅影响消化系统的健康运作，<strong>对人体的免疫系统也起到了非常关键的因素</strong>。</li>
<li>婴儿出生，成长的方式会形成非常不同的肠道菌群生态。暴露在微生物环境中（但要注意会引起疾病的情况），对于维持菌群环境是有益的，比如家里养宠物，让孩子自由玩耍等，不需要过度清洁与消毒。</li>
<li>什么是健康的肠道菌群生态，目前没有一个标   准的结论。不过总体来看，<strong>菌群的多样性程度高，一般就表示更加健康</strong>。</li>
<li>抗生素会严重破坏肠道菌群生态，需要谨慎使用。</li>
</ul>
<p>在访谈中，两位重点讨论了一个实验，就是什么样的饮食方式会让我们更好的维持肠道菌群的多样性和健康。实验主要对比了两种附加饮食：</p>
<ul>
<li>高纤维食物：全谷类，豆类，蔬菜，坚果。这也是传统上被认为非常健康的食物，其中很多纤维的分解都需要肠道菌群的帮助，换句话说，纤维就是它们的“食物”。</li>
<li><strong>发酵类食物</strong>：酸奶，牛奶酒（kefir），康普茶，酸菜，泡菜，纳豆等。注意需要是自然发酵，一般是<strong>冷藏且非罐装</strong>的食品。而且像酸奶这类要格外注意<strong>不要加糖</strong>等添加剂。</li>
</ul>
<p>实验的结果也颇令人意外：</p>
<ul>
<li>摄入发酵类食品的组，显著提升了肠道菌群的多样性。被试者<strong>几十个免疫标志物的显著降低，对各类炎症都有更好的抑制作用</strong>。没想到吧，肠道菌群还能调节炎症。</li>
<li>肠道菌群本来的多样化程度比较高的人，摄入高纤维食物是有帮助的。如果不是，则摄入高纤维食物的帮助不大。在工业化进程中，人类的进食习惯已经有很多代都转变为了摄入大量肉类，加工食品等，肠道菌群的生态无法仅通过提高纤维食物的量来改变其族群结构。</li>
</ul>
<p>此外在访谈中，两位还讨论了具体食谱推荐的问题，引用了 <a href="https://link.zhihu.com/?target=https://youtu.be/sJLK3sVexIk">Christopher Gardner 关于生酮饮食与地中海饮食比较的研究</a>。这里总结一下实践建议：</p>
<ul>
<li>**如果要<u>改善肠道菌群生态，最好的方式是一天两次摄入天然发酵类食品</u>**。</li>
<li>高纤维食物对于肠道菌群生态的维护是有益的，建议日常饮食以植物类食物为主，尽量避免深度加工食品的摄入，控制糖的摄入。Sonnenburg 教授还讲了个故事，说微生物学家参加的会议，一般餐厅的沙拉吧总是会供不应求 :) 前面提到的 Rich Roll 大佬也是个素食者。</li>
<li><strong>益生菌的效果没有广泛研究支持</strong>，且这类产品的监管很有限。<strong>益生元的效果也是好坏参半</strong>，缺乏多样性，溶解速度太快等问题都使总体效果存疑。</li>
<li>地中海饮食相比生酮饮食来说对健康的影响效果接近，但更容易坚持遵循。另外生酮饮食如果长期实践可能有一定的风险。所以<strong>总体更推荐地中海饮食结构</strong>。</li>
</ul>
<p>另外值得参考的是我们也有官方的 <a href="https://link.zhihu.com/?target=https://sspai.com/post/72984">中国居民膳食指南</a>，或许更适合东方人的饮食习惯。</p>
<h2 id="心态与动力"><a href="#心态与动力" class="headerlink" title="心态与动力"></a>心态与动力</h2><p>这一部分主要介绍的是人体的多巴胺系统原理，以及如何利用它来形成健康，自律的生活方式。这一集是 Huberman 开播以来播放量最高的一集，对于强健我们的心智有着非常好的指导作用。</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>多巴胺是一种非常重要的化学物质，主要作用于两个神经回路：一个影响身体的运动，例如帕金森病与多巴胺的分泌不足有关；另一个则影响我们的动机，欲望与快乐，这几乎与我们从事的各种活动有关，无论是工作，学习还是社交，休闲娱乐。这里我们会主要讨论多巴胺的后者影响能力。</p>
<p>神经系统中多巴胺含量水平的高低会影响我们的情绪，当<strong>多巴胺水平低时，我们会感到情绪低落，没有动力，而多巴胺水平高时，我们会感到兴奋和快乐</strong>。在通常情况下，我们的身体处于多巴胺 baseline  的状态，当我们达成一些令人兴奋的目标（比如玩游戏胜利，考试拿高分）后，多巴胺的水平会达到一个高峰，此时我们就会获得巨大的愉悦感。在高峰之后，多巴胺水平会回落到比 baseline 更低的一个水平，且这个状态会持续一段时间。</p>
<p>这里有两个非常重要的原理：</p>
<ul>
<li><p>多巴胺绝对值含量的高低只是一方面，<strong>更重要的是其“相对变化量”的多少</strong>。比如在刷抖音时看到了一个很有趣的视频，多巴胺水平升高，你会感到快乐，刷到下一个视频时，你感到的快乐程度好像不会那么强烈了，因为多巴胺已经在一个比较高的水平，难以形成更大的变化量。而同样的视频，如果你是几天之后看到，或许你会觉得有意思的多。所以<strong>当你持续做一件喜欢的事情时，你感受到快乐的阈值也会不断提高</strong>。</p>
</li>
<li><p><strong>多巴胺的总体“储备”是有限的</strong>！也就是说无论你是通过学习，工作，娱乐，社交，运动等不同方式来获得快乐，所消耗的“快乐货币”都是同一种：多巴胺。举几个例子来看下这个原理带来的影响：</p>
</li>
<li><ul>
<li>很多自律的人都会说自己是 work hard，play hard  的生活方式，比如工作日通过高强度的工作来获得成就和满足感，休息日进行各种休闲娱乐，运动，社交等方式来获得快乐，其实背后都是在释放多巴胺来获取快乐。长期持续，我们身体的多巴胺 baseline 会逐渐下降，出现一种耗尽（burn out）的心理感觉，对很多事物无法保持之前的兴趣与精力。</li>
<li>很多人会对玩电子游戏着迷，因为它们能带来巨大的多巴胺释放刺激让人感到快乐。但要意识到，多巴胺的储备是有限的，如果对此上瘾，你的多巴胺耗尽问题就会变得非常严重：一方面能够引起你兴趣的事物会变少，可能只有玩游戏才能带来快乐；另一方面，后续甚至会导致玩游戏本身也无法触发多巴胺释放，引起严重的抑郁问题。</li>
</ul>
</li>
</ul>
<p>另外，<strong>多巴胺也具有叠加效应</strong>。比如你喜欢健身，那么运动就会刺激多巴胺的释放。而我们实际去健身时，可能会不自觉的安排了很多其它的“快乐因素”，比如选一个精神状态比较好的日子，运动前喝一些能量饮料，跟认识的朋友一起去，边健身边 social，听一些自己喜欢的音乐或  podcast，等等。这些因素也都会促进多巴胺的释放，让你感到“前所未有的快乐”。但要注意前面的原理，<strong>多巴胺的高峰越高，后面随之而来持续的低谷也会越长</strong>，而且长此以往，可能会降低你单纯从运动中获取快乐的能力。这样的例子还有很多，比如边跟朋友吃饭，边玩手机，拍照发朋友圈，可以计算一下叠加了几种快乐因素 :)</p>
<h3 id="影响多巴胺的外界因素"><a href="#影响多巴胺的外界因素" class="headerlink" title="影响多巴胺的外界因素"></a>影响多巴胺的外界因素</h3><p>我们来看下具体影响多巴胺释放的各类因素有哪些，首先是促进多巴胺分泌的：</p>
<ul>
<li>巧克力，提升到 1.5 倍的多巴胺 baseline</li>
<li>性行为，提升到 2 倍</li>
<li>尼古丁，提升到 2.5 倍</li>
<li>可卡因，提升到 2.5 倍</li>
<li>安非他命，提升到 10 倍</li>
<li>咖啡因本身只会少量提升多巴胺，但它会抑制一些多巴胺受体，提升同等多巴胺造成感受的效果</li>
<li>马黛茶，包含咖啡因，能控制血糖，还能保护多巴胺神经元</li>
<li>刺蒺藜豆也能提升多巴胺（基本等同于 L-DOPA），还能提升男性精子数量和质量</li>
<li>运动，带有主观成分，喜欢跑步的人，可以提升到 2 倍 baseline</li>
<li>健康的社交关系也会促进多巴胺释放</li>
</ul>
<p>食物方面感觉 Huberman 教授<strong>非常推荐马黛茶</strong>。</p>
<p>也有很多提升多巴胺释放或影响其效果的药物：</p>
<ul>
<li>L-Tyrosine（酪氨酸），提升多巴胺</li>
<li>Phenethylamine（PEA），巧克力中也包含，能够提升多巴胺</li>
<li>Huperzine A，提升多巴胺</li>
<li>各种“聪明药”，如 Adderall, Modafinil, Alpha-GPC, Ginkgo 等，留学党应该很多都有耳闻</li>
</ul>
<p>通常来说，<strong>不推荐持续使用这些药物</strong>，因为多巴胺释放之后的高峰会带来 baseline 水平的降低，导致无法享受活动的快乐，无法专注，限制学习能力和神经元可塑性等。Huberman 表示<strong>一周使用一次的频率应该是安全的</strong>。</p>
<p>最后还有一个比较特别的研究，就是<strong>冷水浴能够提升多巴胺释放到 baseline 的 2.5 倍左右</strong>，且持续时间更长，能达到 3 小时左右。建议使用 10-14 摄氏度的水温，注意安全。此外冷水浴也不需要太频繁，每周 11 分钟左右足够。如果已经习惯了冷水浴，那么也就没有释放多巴胺的效果了。</p>
<p>还有一些因素会降低多巴胺，如：</p>
<ul>
<li><strong>褪黑素，会引起多巴胺的减少</strong>。前面也提到过并不建议使用褪黑素来帮助入睡，或者适应时差等。</li>
<li>睡眠时段接触光源，也会引起接下来几天的多巴胺水平下降。<strong>半夜睡不着刷手机是很有害的哦</strong>。</li>
</ul>
<h3 id="维持健康的多巴胺水平"><a href="#维持健康的多巴胺水平" class="headerlink" title="维持健康的多巴胺水平"></a>维持健康的多巴胺水平</h3><p>了解了原理和各种影响因素后，我们来看下如何有效设计我们的生活工作方式来维持健康，可持续的多巴胺水平。</p>
<p>简单回顾一下，前面我们已经知道了多巴胺储备有限，且对一件事物上瘾会不断提高感受快乐的阈值，那么<strong>如何让我们能对一件事情保持长时间的兴趣和投入度，又不至于耗尽多巴胺呢</strong>？一个经典的例子是赌场的运作方式，我们并不是每一次下注都能赢，偶尔赢一次会释放多巴胺，而且根据赢得钱的多少有所上下浮动，这会吸引玩家持续参与。这就是一种非常有效的**<u>间歇性且随机的奖励</u>机制**。感觉很多游戏，社交网络产品也借鉴了这个思路来进行设计。</p>
<p>对于我们经常需要从事的活动，我们也可以模拟这个机制。还记得前面提到的<strong>多巴胺叠加效应</strong>吗？我们可以<strong>通过随机化叠加因素的多少，来实现多巴胺释放的差异性</strong>。还是以健身为例，我们可以随机决定今天是否要听音乐，是否去健身时带手机，是否要在健身前喝能量饮料等因素。如果其它什么都不做，只是单纯健身，那么多巴胺的释放量就会相对较低。如此就能模拟多巴胺释放有高有低的随机奖励机制。</p>
<h3 id="成长型思维"><a href="#成长型思维" class="headerlink" title="成长型思维"></a>成长型思维</h3><p>最后来看下如何构建良好的思维方式来利用多巴胺系统提升自我。</p>
<p>有一个非常知名的实验，挑选了一群天生喜爱画画的小朋友，在他们完成画作后给与一些奖励。后面在移除这些奖励后，小朋友们对于画画的兴趣和动力大大降低了。这个实验说明，当我们因为一个活动收到奖励（比如金钱，美食等）时，我们<strong>反而会降低活动本身的愉悦程度</strong>。而且多巴胺本身影响我们对时间的认知，同时也影响我们的情绪状态，如果我们<strong>始终以完成活动后的奖励为目标，则整个过程中就很少释放多巴胺，让原本困难的过程变得更加难以坚持</strong>。</p>
<p>仔细想一下，这是一个非常有意思的观察。多巴胺有点像我们的“本能系统”，决定了我们是否有动力做一件事。但反过来<strong>我们的主观思想却可以影响这个系统起作用的方式</strong>，这也是人类为何能摆脱动物本能，达成很多需要“反人性”的投入才能取得的成就的原因吧。上述的实验是我们的主观思想造成的一个反面作用的例子，我们自然也可以实现正面作用，那就是成长型思维。</p>
<p>具体来说，就是**通过<u>自我暗示，把努力过程本身当作一种“奖励”</u>**。我在努力学习，这个过程本身就是有趣的，会让我不断变得更强，这样的想法会在过程中激发身体系统释放多巴胺，而多巴胺提升了我们的情绪和动力水平，也会让努力的过程中碰到的困难变得相对容易克服。专注于这个过程的本身，而不是在过程前进行各种外界刺激（如前面提到的药物），或者在过程后给自己巨大的奖励。</p>
<p>这种思维方式看起来很主观，但这就是我们的神经系统工作的方式，虽然人类的“硬件系统”都差不多，但知识，思维这些运行之上的“软件”却可以千差万别。<strong>我们可以通过自律，自我暗示来改变自身对各类活动的喜好</strong>。例如通过暗示 fasting 对我们健康的益处，来获取满足感，而不是借助于 fasting  结束后的大快朵颐。通过自律抵御高油盐食物的吸引力，并且自我暗示植物类食物对身体的好处，坚持一段时间，会觉得花椰菜也挺美味的。这也是为什么我们在这篇文章中介绍了很多原理性的内容，而不仅仅是行为建议。因为这些原理知识能够让我们做更好的自我暗示 :)</p>
<p>这一节的 podcast 对我本人的冲击非常大，强烈建议大家观看这期 <a href="https://link.zhihu.com/?target=https://hubermanlab.com/controlling-your-dopamine-for-motivation-focus-and-satisfaction/">Mindset &amp; Drive</a>，相信也会有不同的收获。</p>
<h2 id="学习与专注"><a href="#学习与专注" class="headerlink" title="学习与专注"></a>学习与专注</h2><p>在了解了多巴胺的运作机制基础上，我们可以继续探究一些跟大脑健康，专注度，如何进行高效学习相关的话题。</p>
<h3 id="学习的原理"><a href="#学习的原理" class="headerlink" title="学习的原理"></a>学习的原理</h3><p>从脑神经科学来看，学习的本质是神经元的重新连接（rewire），进一步来看，需要大脑处在一种学习的化学状态下，也就是 Huberman 经常提到的神经可塑性（neuroplasticity）状态。</p>
<p>简单来说，当我们尝试做一些事情，但没有达到预期目标时，身体会给大脑发信号，“我犯错了”。处在这种犯错，沮丧的认知状态下，神经系统会释放肾上腺素（提升 alertness），乙醯胆碱（提升 focus），多巴胺（促进神经元的  change，rewire）等化学物质，激活神经元的可塑性。也就是说，<strong>犯错是我们进入学习状态的重要前提</strong>。搞机器学习的同学应该很熟悉了吧，这跟我们训练模型不是一模一样么 :) 另外很多人可能觉得心流（flow）状态是学习的最佳状态，而 Huberman 则不这么认为。<strong>心流是一种精神高度集中且接近于自动化的状态，是在做我们已经知道怎么做的事情，而不是在学习新的知识技能</strong>。</p>
<p>对于这个学习状态，经典的实验是给人们戴上一些能转变角度的眼镜，然后执行一些类似物体抓取的任务。由于看到的东西通过眼镜改变了其本来的位置，一开始在尝试时总会出现抓取动作的偏离。但后续在进入神经可塑性状态后，我们能逐渐适应相关的视觉偏移，协调自己的听觉，动作等都与之协同，顺利完成任务。更有意思的是，<strong>这个“<u>神经可塑性</u>”的化学状态是可以持续的</strong>，我们甚至可以先通过一些其它操作触发大脑的这个机制，再去进行真正的学习，以加快学习的速度。这里还有一个隐藏逻辑，当你在遇到挫折困难时，大脑进入了可塑性状态，而此时你却放弃了，那么<strong>神经元也会重新连接到这种容易放弃的行为模式，形成恶性循环</strong>。</p>
<p>人在年幼时期大脑天然的神经可塑性会比较好，而在 25 岁以后则会大大下降。我们后面会提到如何来进行克服。</p>
<p>另外，<strong>休息和睡眠时也会发生大量的神经元重连接的活动</strong>，这也是之前我们就提到过的，高质量的睡眠是实现很多生理，心理健康强壮的先决条件。</p>
<h3 id="利用神经可塑性"><a href="#利用神经可塑性" class="headerlink" title="利用神经可塑性"></a>利用神经可塑性</h3><p>如果正在阅读文章的你还未满 25 岁，那么恭喜你，你的神经可塑性仍然非常的好，可以<strong>尽可能广泛的学习各种知识和技能</strong>。比如你可以很快学会各种乐器，新的语言，新的运动，新的专业技能等等。通过更广阔领域的体验接触，尽量找到你最有兴趣的方向，可以后续再不断深入经营。</p>
<p>如果已经像我一样超过了 25 岁，那么还有很多办法来提升神经可塑性：</p>
<ul>
<li>通过实验发现，<strong>成年人对于小幅度的增量学习是完全可以适应与掌握的</strong>。例如每次视觉上的偏差只有 7 度，而不是一下子就来个 180 的大颠倒，那么成年人也能很快从错误中学习纠正。应用到实际学习中，我们每次学习的内容可以控制一下不要太多（本文有点违反了，建议收藏慢慢学习），多次积累来完成神经系统的调整学习。</li>
<li>对于达成目标的渴求度越高，重要性越大，奖励的刺激越大（比如为了生存），则神经可塑性就会越容易出现。这个比较符合直觉，但是现实中可操作性可能不高。</li>
<li>第三点最有意思，<strong>通过扰乱前庭神经系统（vestibular system），能够达到神经元可塑性的状态</strong>。简单来说，就是让你的身体有一些“新颖的重力体验”，如倒立，瑜伽，体操，滑板，任何让身体会失去平衡的一些状态等，会快速激发“我犯错了”的信号，进入学习状态，甚至可以在之后去做别的任务的学习。这一下子就让我想到了<strong>淘宝成立初期的“倒立文化”，没想到还真的有科学依据</strong>。需要注意的是，这个体验必须要新颖，也就是说如果你已经倒立很熟练了，那么去做倒立就是个日常行为，并不会给身体一种在犯错边缘，需要纠正的刺激。</li>
</ul>
<h3 id="学习的理想状态"><a href="#学习的理想状态" class="headerlink" title="学习的理想状态"></a>学习的理想状态</h3><p>除了神经可塑性的化学状态外，我们也需要注意其它的因素。例如我们<strong>不能太放松以至于有些昏昏欲睡，也不能太紧张激动，无法控制自己拥有清晰的思考</strong>等。这些也都跟我们体内的多巴胺，肾上腺素，乙醯胆碱，血清素，褪黑素等化学物质的水平有关，需要做好调节。在之前 Rich Roll 的访谈节目中，Huberman 提了一个非常有效的“呼吸工具”，叫<strong>生理叹息</strong>（Physiological Sigh）。操作方法上简单来说就是<strong>吸两口气，然后出一口长气</strong>。通常情况下，只要一两次生理叹息就足以使我们的压力和警觉水平迅速下降，让人感到更加平静，提升学习表现。</p>
<p>前面提到的成长型思维也很重要，在遇到错误导致的沮丧感觉时，可以不断<strong>增强自我暗示，失败是帮助我们学习成长的唯一路径，对我们是有益的，以此增加多巴胺的释放</strong>，提升学习动力和过程中的愉悦感。</p>
<p>联系到睡眠对学习的促进作用，也有一些研究提供了一些相关的 tips：</p>
<ul>
<li>在学习时听一些有规律的节拍，在<strong>入睡时也播放同样的微弱节拍</strong>，能够提升学习和记忆的效果。</li>
<li>一般在 90 分钟的学习后（人体生物钟的周期），可以选择进行 20 分钟的休息（non sleep deep rest），也会加强学习的效果。**<u>90-20定律</u>**</li>
<li>Gap effect，<strong>在学习中随机停止 10 秒钟</strong>，这些停止会在睡眠中加速“播放”，提升学习效果。</li>
</ul>
<h3 id="提升专注"><a href="#提升专注" class="headerlink" title="提升专注"></a>提升专注</h3><p>“专注”背后的机理是大脑中两种“网络模式”的协调，一种叫 Default network，在我们不做任何事情时被激活，另一种叫 Task  networks，在我们专注于做某些事情时被激活。普通人的大脑能够很好地协调这两个模式，两者像跷跷板一样，当一种模式被激活时另一种模式会被抑制。而具有专注障碍（比如多动症）的人来说，这两者无法很好的进行协调，因此会出现无法专注的现象。</p>
<p>通过提升多巴胺水平，可以有效促进这两种网络模式的协调，因此有非常多的多动症治疗药物都跟提升多巴胺有关，例如 <strong>Adderall，Modafinil</strong>  等。一些调查表明，这些药物（经常被称为聪明药，nootropics）在美国被滥用的程度甚至超过了大麻，不少“学霸”都以此来提升注意力，减少对睡眠的需求。但 Huberman  教授表示，一方面多巴胺的刺激提升后都会带来多巴胺水平的低谷，另一方面这些药物也可能导致上瘾，对新陈代谢作用造成扰动，有很多负面影响，<strong>对长期的学习与记忆效果可能并没有提升作用</strong>。在之前介绍多巴胺的章节也有提到，应该谨慎使用这类药物，并严格控制使用频率不能过高。</p>
<p>一些安全有效的提升专注力的方法包括：</p>
<ul>
<li>适量补充 **Omega-3 EPA <u>鱼油</u>**，这是神经细胞的组成原料之一，能够有效减轻抑郁，对治疗多动症（ADHD）也有帮助。</li>
<li><strong>通过<u>身体其它部分释放运动</u>，可以帮助提升注意力</strong>。教授举的例子是作为神经科医生在开刀时，如果采用半蹲半站的姿态（运动释放），拿手术刀的手更稳定不容易颤抖。这让我想起以前读书时很多同学习惯转笔，现在工作了也有不少人喜欢玩指尖陀螺，或者站立办公，可能都是类似效果。</li>
<li><strong><u>限制视野范围</u>，能够提升专注度</strong>。比如我们经常因为眼睛瞟到了任务栏上的消息提示闪动而分心，可以通过一些设置来进入“专注模式”。</li>
<li>视线的高低也会影响神经状态，<strong>视线往下看会让神经系统偏向镇静，放松，甚至困倦，而<u>视线向上</u>则会让系统提升警惕</strong>。工作时一般至少把显示器放置在<strong>鼻子</strong>位置之上。</li>
<li>大脑不擅长处理大量频繁的 <strong><u>context switch</u><strong>，典型的比如刷抖音，不同的信息以非常快的速度频繁切换，这对我们的注意力是有伤害作用的。2014 年的一项研究表示，</strong>我们每天在手机上花费的时间应该少于 60 分钟（青少年）&#x2F;120 分钟（成年）</strong>，以免引起注意力障碍问题。</li>
<li>还有研究表明，<strong>17 分钟的<u>冥想</u>，能够对大脑中的神经元做重新连接，永久地改善注意力</strong>。只要做一次就可以，完全可以尝试一下。</li>
</ul>
<h3 id="大脑健康"><a href="#大脑健康" class="headerlink" title="大脑健康"></a>大脑健康</h3><p>最后来看下提升大脑健康和效能的一些方法。</p>
<p>首先是前面提到过的，保证高质量的睡眠。</p>
<p>运动方面，<strong>对大脑直接帮助最大的是有氧运动</strong>，提升心肺功能，支持大脑供能。建议每周 150-180 分钟的有氧训练。</p>
<p>对于大脑健康有帮助的食物，其中前三点是比较重要的，后面的部分涉及的研究没有那么多：</p>
<ul>
<li><strong>Omega3, 尤其是 EPA 等脂肪酸</strong>，是大脑组成的重要部分，且一般人都容易摄入不足。多吃<strong>鱼</strong>，牡蛎，鱼子酱，奇亚籽，<strong>核桃，大豆</strong>。一天至少摄入 1.5 克，理想情况需要 3 克以上。不喜欢吃鱼的话可以辅助摄入鱼油。</li>
<li><strong>磷脂酰丝氨酸</strong>，也对认知能力有帮助。通过鱼，<strong>肉类，卷心菜</strong>来摄入。</li>
<li><strong>乙酰胆碱</strong>，重要的神经调质，提升注意力。摄入胆碱的重要来源是<strong>鸡蛋</strong>，尤其是蛋黄。土豆，坚果，水果中也含有，虽然没有蛋黄中的含量那么丰富。可以通过 Alpha-GPC 等补充剂来获取。</li>
<li>肌酸，尤其对于不吃肉的人，一天需要摄入 5 克左右。</li>
<li>花青素，在蓝莓，黑莓，葡萄等食物中有提供。可以降低 DNA 损伤，缓解认知下降等问题。大约每天需要 60-120 克蓝莓的补充。</li>
<li>谷氨酰胺，可以通过牛肉，鸡肉，鱼肉，鸡蛋，大豆，卷心菜，菠菜，芹菜等食物来摄取。提升大脑在缺氧（高海拔地区）下的表现，还能够抑制对糖的需求。</li>
<li>水，钠，钾，镁等电解质是神经元信号传递所需的基础元素，需要保证。</li>
</ul>
<p>这一节中还讨论了我们身体对各种食物喜好进行判断的三个渠道，前两个分别是味觉判断和营养成分的下意识判断。第三个比较有意思，也跟多巴胺有关，即我们可以<strong>通过提升大脑代谢的活跃度来增加对某种食物的喜好</strong>。比如你如果不喜欢吃鱼，一种方法是你可以**<u>把鱼跟你平时爱吃的食物一起吃</u><strong>，另一种是给自己足够的</strong><u>心理暗示</u>**，说服自己吃鱼是有益身体健康的。通过这两种办法，你都可以让大脑释放多巴胺，从而逐渐提升对鱼类食物的喜好程度。</p>
<p>最后，如果你对膳食补充剂感兴趣，还可以看看 <a href="https://link.zhihu.com/?target=https://www.thorne.com/u/huberman">Huberman 教授平时会吃的补充剂有哪些</a>。</p>
<h2 id="长寿"><a href="#长寿" class="headerlink" title="长寿"></a>长寿</h2><p>最后我们来看下如何延年益寿，这是 Huberman 跟这个领域的专家，来自哈佛的 David Sinclair 的一集访谈节目。</p>
<h3 id="衰老的本质"><a href="#衰老的本质" class="headerlink" title="衰老的本质"></a>衰老的本质</h3><p>Sinclair 认为，衰老是一种疾病，它本身导致了非常多通常意义上的疾病的出现，比如阿尔兹海默症，癌症等。我们可以通过科学的手段来“治疗”衰老，甚至逆转它。</p>
<p>从本质上来说，衰老是<strong>基因信息的损失</strong>，这分为两部分：</p>
<ul>
<li>DNA 本身的信息，比如细胞中的 DNA 结构会在辐射等情况下受到破坏。</li>
<li>控制哪些基因进行表达的信息受到了破坏，也就是所谓的表观基因组（epigenome）。这部分在衰老的因素中占了 80%。</li>
</ul>
<p>人体内有一个天然的“衰老时钟”，而且并不是以匀速走的。在年轻时我们的生长发育过程中，这个时钟走得更快。所以如果青春期发育比较迅速的人，一般来说整体的时钟走的比较快，寿命也会相对短，是不是有点吓人……而且，一般比较矮小的人，像侏儒很少会得心脏病，癌症，也会明显更长寿。不过不要紧张，前面提到了，基因本身的信息只占了衰老因素的 20%，<strong>控制基因表达这部分占了大多数</strong>。</p>
<p>这里有点意外的是 Sinclair 教授介绍的最重要的几个实验，都跟前面我们提到的 fasting 有关。比如一般老鼠的寿命大概是 2 年，他们实验室有一只叫 Yoda 的老鼠，活了足足 5 年。其主要的做法就是选取了侏儒基因，以及执行 fasting。</p>
<p>教授详细介绍了 <strong><u>fasting</u> 为何能提升动物&#x2F;人类 30% 以上的寿命</strong>：</p>
<ul>
<li>在低血糖水平时，身体会抑制哺乳动物雷帕霉素靶蛋白（mTOR），激活去乙酰化酶（sirtuin），形成一个非常良好的化学状态，清理旧蛋白质，提高胰岛素敏感度，提供更多能量，修复细胞等等。后面这个乙酰化酶是我们抵御衰老的一个重要武器。</li>
<li>当胰岛素水平低时，“长寿基因”会被激活，如 SIRT1 等。</li>
<li>fasting 会给细胞足够的“休息时间”。</li>
<li>血糖水平低，会让身体对胰岛素更敏感，更快吸收血糖，也对健康有益。</li>
<li>当你从来不感受饥饿时，你的衰老时钟也走的更快。</li>
<li>除了 24 小时周期 fasting 触发的 autophagic，还有更深层次的清理机制，会在禁食第二，三天启动。在老年老鼠上的实验表明，这种长时间的禁食可以让他们延长寿命 35%。不过这个实操难度对普通人来说有点大。</li>
</ul>
<p>Sinclair 也对比了一些上个世纪失败的研究，比如通过抗氧化剂来抵御衰老。现代长寿研究的核心思想是，如何<strong>通过一些机制手段来触发身体自身的衰老抵抗机制</strong>。</p>
<p>此外 Sinclair 也介绍了一些激动人心的前沿技术，例如**<u>通过基因治疗方法</u>，可以重启我们的 DNA 表达系统**。通过一次注射，可以让盲人恢复视力，这已经在老鼠身上得到了验证。或许几年后，我们可以像死侍那样实现身体各部分的逆转老化。</p>
<h3 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h3><p>这里列出一些 Sinclair 自己的实践方式，如果想要采纳还是要结合自身的情况来看。有意思的是这集节目下有个热门留言是这个教授竟然已经 52 岁了，完全看不出来……所以你懂的。</p>
<ul>
<li>不吃早饭，午饭也吃的比较少，<strong>酸奶或者橄榄油</strong>，晚饭吃蔬菜为主，加<strong>鱼和虾</strong>，基本不吃牛排。不吃糖，甜品，面包。基本达到了 2 小时进食窗口的高阶 fasting 状态。他偶尔也会尝试一整天都不吃东西，但比较难坚持。</li>
<li>每天摄入 1 克的白藜芦醇（resveratrol），1 克的 NMN（进而会转化为 NAD，which is sirtuin 的“燃料”），还有二甲双胍（metformin）。其中锻炼的日子可能会跳过一些补充品。他并不吃复合维生素。</li>
<li>以蔬菜为主食的好处：富含各种营养，维生素；包含异种激素（Xenohormesis），植物基于“压力”之下产生的物质，对长寿有益。后者也可以通过槲皮素（quercetin）来做膳食补充。</li>
<li>一般会隔一天进行有氧运动和力量训练。有氧运动能提升 NAD 水平。</li>
<li>根据家族病史来决定一些药物摄入，如他 29 岁就开始服用降胆固醇药物。</li>
<li>对于<strong>人造甜味剂</strong>，教授认为总体来说是安全的。他偶尔也会喝健怡可乐。</li>
</ul>
<p>对于这一系列实践，Sinclair 教授都进行了 10  多年的自身实验，并使用各种手段来监控身体数据。通过监控数据可以推测出一个人的“生理年龄”如何（不是光看脸），他自己在上述实践下，生理年龄在持续下降，现在已经达到了 30 岁左右的水平（实际年龄 52 岁）。另外，他认为每个人的身体情况不一样，医院约定俗成的生理指标范围也不一定适合每个人。<strong>未来这种健康数据的实时监控与个性化诊断会成为主流</strong>。他举了一些例子：</p>
<ul>
<li>监控血糖水平 HbA1c，观察 fasting 的影响等。</li>
<li>监控炎症指标 CRP，与心脏病等各种疾病的诱发相关。</li>
<li>监控 LDL，通过药物等进行控制。膳食胆固醇对血液胆固醇几乎没有影响，不需要戒红肉，黄油等。</li>
<li>补充铁元素可能加速衰老。医学指标需要个性化，低铁元素含量并不一定导致贫血。</li>
</ul>
<p>还有一些影响寿命的负面因素：</p>
<ul>
<li>肥胖症会加速衰老。</li>
<li>吸烟，会破坏基因表达，加速衰老。</li>
<li>X 光检查同理，没有必要时，避免接触。</li>
</ul>
<p>展望一下 longevity 研究的未来，还是挺激动人心的。现代科学每一年能让我们的平均寿命延长 1&#x2F;4 年，如果每一年能让我们的平均寿命延长超过 1 年，则达到了<strong>寿命“逃逸速度”</strong>（类比以 1000 英里每小时的速度往西飞行，太阳永远不会落下），实现了“永生”。著名的未来学家 Ray Kurzweil 预测，大约 12 年后（2034 年）就能实现，让我们拭目以待。</p>
<p>除了这集 podcast，也必须附上吴承霖大佬的万星项目 <a href="https://link.zhihu.com/?target=https://github.com/geekan/HowToLiveLonger">程序员延寿指南</a>。</p>
<h2 id="个人实践"><a href="#个人实践" class="headerlink" title="个人实践"></a>个人实践</h2><p>前面介绍的内容有点多，这篇文章篇幅也有些超了。最后来简单介绍下我个人目前采纳的一些行动和辅助工具。</p>
<p>睡眠方面暂时没有什么特别的措施，现在带娃基本上晚上睡眠质量也比较一般。只是会稍稍注意一下晚上 11 点后尽量<strong>不接触手机光源</strong>。<strong>早起接收光照</strong>这点，基本上就是早上遛狗或者开车通勤时间来接触，基本压力不大。如果比较讲究的同学，还可以下一个 <a href="https://link.zhihu.com/?target=https://mycircadianclock.org/">My Circadian Clock App</a> 来追踪一下生物钟，也是 Satchin Panda 等大佬参与开发的项目，值得信赖。</p>
<p>饮食方面，开始尝试 <strong>8 小时进食窗口</strong>的 fasting，目前感觉良好。中饭一般<strong>吃蔬菜为主的轻食</strong>，晚上就比较放飞自我，想吃啥吃啥。早上会看情况喝点盐水，茶或者  AG1 的补充剂。膳食补充剂目前基本只有复合维生素和 EPA 鱼油在使用，后面可以参考下 Huberman 的“配方”增加一些。Huberman 自己也在节目中表示<strong>对白藜芦醇和 NMN 还在观望状态</strong>，我查了些资料发现有争议的地方还不少，所以我个人建议先采纳广受认可和使用的一些补充剂，如 EPA 鱼油，二甲双胍等。个人目前考虑的补充剂列表：</p>
<ul>
<li><a href="https://link.zhihu.com/?target=https://www.thorne.com/products/dp/basic-nutrients-2-day">基础维生素</a>，常规补充剂。</li>
<li><a href="https://link.zhihu.com/?target=https://www.thorne.com/products/dp/super-epa-sp608nc">Omega-3 EPA</a>。</li>
<li><a href="https://link.zhihu.com/?target=https://athleticgreens.com/en">AG1</a>，超火的小绿粉，各种植物提取物 + 各种维生素矿物会，Fridman，Huberman 等大佬的节目里都有提到，就是贵了点。</li>
<li><a href="https://link.zhihu.com/?target=https://www.thorne.com/products/dp/betaine-hcl-pepsin-225-s">Betaine HCL &amp; Pepsin</a>，保护肠胃。</li>
<li><a href="https://link.zhihu.com/?target=https://www.thorne.com/products/dp/l-tyrosine">L-Tyrosine</a>，提升多巴胺，可能会买个尝尝鲜。</li>
<li><a href="https://link.zhihu.com/?target=https://zh.m.wikipedia.org/zh/%E4%BA%8C%E7%94%B2%E5%8F%8C%E8%83%8D">二甲双胍</a>，抗衰老“神药”。</li>
<li><a href="https://link.zhihu.com/?target=https://www.thorne.com/products/dp/resveracel">ResveraCel</a>，白藜芦醇，NR 等抗衰老组合。</li>
</ul>
<p>很多人都关心 fasting 可能引发胆结石，这里提供一些补充信息：</p>
<ul>
<li>从这篇 <a href="https://link.zhihu.com/?target=https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1419405/">Bloch, H. M. 等人的论文</a> 来看，fasting 过程中胆汁的饱和度有一个先上升后下降的过程，<a href="https://link.zhihu.com/?target=https://youtu.be/2lGuXBwudKw">Dr. Berg 也以此做了解释</a>，认为 fasting 加生酮饮食（摄入脂肪）对胆囊健康反而是有益的。</li>
<li>从这篇 <a href="https://link.zhihu.com/?target=https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1405175/">Sichieri, R. 等人的论文</a> 的结果来看，long overnight fasting 和节食会提升得胆结石的概率。不过减肥（减少脂肪）本身就会提升得胆结石的概率。</li>
<li>持续 24 小时以上的禁食相关的研究比较少（比较难执行），但从机理上来说长时间的禁食应该会增加得胆结石的概率。</li>
<li>饮食结构，自身状况对胆结石的形成也会有很大影响，例如高胆固醇，高胰岛素水平，高碳水饮食等。高纤维食物，健康的脂肪摄入，有助于降低得胆结石的概率。</li>
</ul>
<p>总体看下来，我个人感觉这块的实验上没有一个定论（就跟 <a href="https://link.zhihu.com/?target=https://www.coffeeandhealth.org/factsheet/gallstones-factsheet">咖啡是否会引发胆结石</a> 一样），但应该不是一个概率很大的问题，起码 Huberman 教授跟这个领域的另一位权威 Satchin Panda 教授都没有提到这块的问题。理想情况是执行 fasting 时持续对你的身体状况做医学指标的跟踪。其它就看个人选择了 :)</p>
<p>工作，学习，专注方面，主要看自律了。这方面我总体控制还可以，在了解了多巴胺的工作原理之后就更加有自信了，主要靠各种软件的<strong>专注模式来近似执行番茄时钟法</strong>，此外也采用了升降桌，大概有 30% 的时间<strong>站立办公</strong>。工作间歇会尝试一下 <strong>Yoga</strong> Nidra。此外晚上学习时段会用 iPad 的 Books  来<strong>记录一下阅读时间</strong>，基本上每天保持 30 分钟以上，持续坚持。后面考虑试试工作时喝<strong>马黛茶</strong>，以及夏天开始尝试<strong>冷水澡</strong>。</p>
<p>运动方面是这一年来改观最大的一项，依靠小米手环 favicon功能的督促，基本上做到了<strong>每周平均 3 次的跑步或者羽毛球活动</strong>，持续把 PAI 值保持在 200  左右。总体来说对于精神状态的改观还是很大的，肚子上的脂肪也减少了很多。唯一比较困扰的是一般下班后运动都要 9，10  点开始了，结束后会离入睡的时间比较近，有时候会对睡眠质量有所影响。</p>
<p>最后，Huberman  教授的 podcast  中还有很多<u><em><strong>其它内容</strong></em></u>，比如习惯养成，健身增肌，应对恐惧与创伤，情绪管理等，感兴趣的朋友可以进一步挖掘。本文以实验事实和原理假设的陈述为主，以上所有的行动方案都需要在咨询医师，专业人员的条件下，结合自身情况执行，注意自身安全，本人与 Huberman 都不负相关后果责任。</p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
  </entry>
  <entry>
    <title>数学与我</title>
    <url>/2022/07/07/%E6%95%B0%E5%AD%A6%E4%B8%8E%E6%88%91/</url>
    <content><![CDATA[<p>一个曾经的数学爱好者的自白(待填坑)</p>
<span id="more"></span>]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数理逻辑-一阶逻辑(模型论角度)-学习笔记</title>
    <url>/2023/12/11/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<p>我们必须知道，我们终将知道。</p>
<span id="more"></span>



<p><strong>ignoramus et ignorabimus</strong></p>
<h1 id="A-Mathematical-Introduction-to-Logic第二章-一阶逻辑-模型论角度-学习笔记"><a href="#A-Mathematical-Introduction-to-Logic第二章-一阶逻辑-模型论角度-学习笔记" class="headerlink" title="A Mathematical Introduction to Logic第二章-一阶逻辑(模型论角度)-学习笔记"></a>A Mathematical Introduction to Logic第二章-一阶逻辑(模型论角度)-学习笔记</h1><ul>
<li><p>公式显示失败了..有空换个博客模版</p>
</li>
<li><p>笔记来自于 Enderton (2001) A Mathematical Introduction to Logic</p>
</li>
</ul>
<h1 id="课本纠错"><a href="#课本纠错" class="headerlink" title="课本纠错"></a>课本纠错</h1><blockquote>
<p> <u>以下错误均已经与英文原版作对比</u></p>
</blockquote>
<p>P36. 最后一行 $\neg$ 应改为$\rightarrow$</p>
<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231121112116386.png"><span class="image-caption">image-20231121112116386</span></li>
</ul>
<p>P70. 同态定理 (a)  $h \circ s(t)$应改为  $\overline {h \circ s}(t)$</p>
<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231121112504911.png"><span class="image-caption">image-20231121112504911</span></li>
</ul>
<p>P84错误 ，$\forall x \varphi$应改为$\forall x \psi$</p>
<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231112204951151.png"><span class="image-caption">image-20231112204951151</span></li>
</ul>
<p>P85 错误，$\varphi$应改为$ \psi$</p>
<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231112205031189.png"><span class="image-caption">image-20231112205031189</span></li>
</ul>
<p>P86 错误，$\Gamma \vdash y \psi_{y}^{x}$  应改为  $\Gamma \vdash \forall y \psi_{y}^{x}$</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231112205102530.png"><span class="image-caption">image-20231112205102530</span></p>
<p>P97错误 “完备性定理的证明”应改为”可靠性定理的证明”</p>
<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231114114209539.png"><span class="image-caption">image-20231114114209539</span></li>
</ul>
<p>P106错误， $ \sigma$ 应改为 $\varGamma$</p>
<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231115174017090.png"><span class="image-caption">image-20231115174017090</span></li>
</ul>
<h1 id="一阶逻辑定义-x2F-重点总结"><a href="#一阶逻辑定义-x2F-重点总结" class="headerlink" title="一阶逻辑定义&#x2F;重点总结"></a>一阶逻辑定义&#x2F;重点总结</h1><p>一阶逻辑的意义：</p>
<ul>
<li>人们很容易想到直觉上正确的推论的例子，而这些推论不能充分反映在命题逻辑模型中。</li>
<li>本章介绍了一个能力更强的逻辑系统：一阶逻辑。事实上，当“数学家”找到一个证明时，几乎总是意味着一个可以反映在一阶逻辑中的证明</li>
</ul>
<h1 id="Section-2-1-First-Order-Languages"><a href="#Section-2-1-First-Order-Languages" class="headerlink" title="Section 2.1: First-Order Languages"></a>Section 2.1: First-Order Languages</h1><h2 id="语言符号整理"><a href="#语言符号整理" class="headerlink" title="语言符号整理:"></a>语言符号整理:</h2><table>
<thead>
<tr>
<th>逻辑符号logical symbols</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>连接符</td>
<td>$\neg$</td>
</tr>
<tr>
<td></td>
<td></td>
<td>$\rightarrow$</td>
</tr>
<tr>
<td></td>
<td>标点符号</td>
<td>(</td>
</tr>
<tr>
<td></td>
<td></td>
<td>)</td>
</tr>
<tr>
<td></td>
<td>变量</td>
<td>$v_n$</td>
</tr>
<tr>
<td><strong>参数</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>全称量词<strong>quantifier</strong> symbols</td>
<td>$\forall$</td>
</tr>
<tr>
<td></td>
<td>谓词符号<strong>predicate</strong> symbols</td>
<td>$P,Q$；作用于n个参数</td>
</tr>
<tr>
<td></td>
<td>常量<strong>constant</strong> symbols</td>
<td>$c$；不可变</td>
</tr>
<tr>
<td></td>
<td>函数符号<strong>function</strong> symbols</td>
<td></td>
</tr>
</tbody></table>
<p>一阶语言的不同之处在于</p>
<ul>
<li>(a) 是否存在相等符号（相等符号是逻辑符号而不是参数）</li>
<li>(b) 存在参数</li>
</ul>
<p><strong>表达式</strong>：符号的有限序列。表达式有几种特殊类型：</p>
<ul>
<li><em>项。</em>对于每个 n 位函数符号 f，我们定义了一个 n 位项构建操作$\mathcal{F}<em>{f}(\epsilon</em>{1},\ldots,\epsilon_{n})&#x3D;f\epsilon_{1}\ldots\epsilon_{n}$.。通过应用零次或多次 n 位项构建运算，从常量符号和变量中构建项。<ul>
<li>项通过对已构建的对象取函数，从<strong>常量和变量</strong>中归纳出对象。</li>
</ul>
</li>
<li><em>原子公式</em>。一个<strong>原子公式</strong>是形式为$Pt_{1}\ldots t_{n}$的表达式，其中 P 是一个 n 位谓词符号，每个$t_{i}$都是一个项。<ul>
<li>原子公式是公式中<strong>被赋予真值的最小部分</strong>，由项和谓词组成。</li>
<li>它们在一阶逻辑中扮演着类似于自然语言中句子的角色。</li>
</ul>
</li>
<li>合式公式。<strong>合式公式</strong>（wff）是一个表达式，可以通过应用零次或多次以下<strong>公式构建操作</strong>来从原子公式中构建：<ul>
<li>$\mathcal{E}_{\neg}(\gamma)&#x3D;(\neg\gamma)$</li>
<li>$\mathcal{E}_{\rightarrow}(\gamma,\delta)&#x3D;(\gamma\rightarrow\delta)$</li>
<li>$\mathcal{Q}<em>{i}(\gamma)&#x3D;\forall v</em>{i}\gamma$.</li>
</ul>
</li>
</ul>
<p><strong>自由出现</strong>：递归定义。在 合式公式wff 中，变量 x 被称为自由出现（x 是自由变量），当满足以下条件之一时： </p>
<p>​	(a) $\alpha$ 是原子公式并且 x 自由出现于 $\alpha$中 , </p>
<p>​	(b) $\alpha&#x3D;(\neg\beta)$ 并且x自由出现于 $\beta$, </p>
<p>​	(c) $\alpha&#x3D;(\beta\rightarrow\gamma)$ 并且“ x 自由出现于 $\beta$ 或者 x 自由出现于 $\gamma$”</p>
<p>​	(d) $\alpha&#x3D;\forall v_{i}\beta$ 并且 $x\neq v_{i}$ 并且 x 自由出现于 $\beta$.</p>
<ul>
<li><p>或者，我们定义 $h(\alpha)$ 其中$\alpha$是原子的，是其所有<strong>变量的集合</strong>，并将其扩展到在所有 合式公式wff 的集合上定义:</p>
<ul>
<li>$\overline{h}(\mathcal{E}_{\neg}(\alpha))&#x3D;\overline{h}(\alpha)$</li>
<li>$\overline{h}(\mathcal{E}_{\rightarrow}(\alpha,\beta))&#x3D;\overline{h}(\alpha)\cup\overline{h}(\beta)$</li>
<li>$\overline{h}(\mathcal{Q}<em>{i}(\alpha))&#x3D;\overline{h}(\alpha)-{v</em>{i}}$.</li>
</ul>
</li>
<li><p>$\alpha$  是句子当且仅当 $\overline{h}(\alpha)&#x3D;\emptyset$. 即没有自由出现的变量</p>
</li>
</ul>
<h2 id="转换-x2F-缩写习惯总结："><a href="#转换-x2F-缩写习惯总结：" class="headerlink" title="转换&#x2F;缩写习惯总结："></a>转换&#x2F;缩写习惯总结：</h2><ul>
<li>$(\alpha\vee\beta)$ 可写为 $((\neg\alpha)\rightarrow\beta)$.</li>
<li>$(\alpha\wedge\beta)$  可写为 $(\neg(\alpha\rightarrow(\neg\beta)))$.</li>
<li>$(\alpha\leftrightarrow\beta)$  可写为 $(\neg((\alpha\rightarrow\beta)\rightarrow(\neg(\beta\rightarrow\alpha))))$.</li>
<li>$\exists x\alpha$ 可写为$(\neg\forall x(\neg\alpha))$.</li>
<li>$t&#x3D;u$  可写为 $&#x3D;tu$ (对于其他一些两位谓词和函数符号也一样)</li>
<li>$t\neq u$  可写为 $(\neg&#x3D;tu)$ (对于其他一些两位谓词和函数符号也一样)</li>
<li>最外面的括号可以去掉</li>
<li>尽可能少用$\neg$, $\forall$, and $\exists$ 的缩写</li>
<li>向右的优先级： $\alpha\square\beta\square\gamma$ 被理解为 $(\alpha\square(\beta\square\gamma))$.<ul>
<li>为了便于阅读，可以将括号添加或更改为 []</li>
</ul>
</li>
</ul>
<h2 id="字母表"><a href="#字母表" class="headerlink" title="字母表"></a>字母表</h2><ul>
<li>变量：小写斜体字母 $v_{i}$, $u$, $v$, $x$, $y$, $z$.</li>
<li>谓词符号：大写斜体字母，以及特定符号，如 $\in$, $&lt;$, etc.</li>
<li>常量符号：小写斜体字母 $a$, $b$, $c$, $\ldots$, 以及特定符号，如 $0$, etc.</li>
<li>函数符号：小写斜体字母 $f$, $g$, $h$, and specific symbols such as $\mathbb{S}$, $+$, etc.</li>
<li>项：小写斜体字母 $t$, $u$.</li>
<li>公式：小写希腊字母 $\alpha$, $\beta$, $\gamma$, $\ldots$</li>
<li>句子：小写希腊字母  $\sigma$, $\tau$.</li>
<li>公式集：大写希腊字母 $\Gamma$</li>
<li>结构：大写德语（花体）字母 $\mathfrak{A}$</li>
</ul>
<h1 id="Section-2-2-Truth-and-Models-真值与模型"><a href="#Section-2-2-Truth-and-Models-真值与模型" class="headerlink" title="Section 2.2: Truth and Models 真值与模型"></a>Section 2.2: Truth and Models 真值与模型</h1><p><strong>语言</strong>：</p>
<ul>
<li>语言是一些有实际用处的参数集合，通常可以用等号来讨论．</li>
</ul>
<p><em><strong>结构</strong></em> ：</p>
<ul>
<li>对于给定的一阶语言，<strong><em>结构</em>  $ \mathfrak{A}$</strong> 是<strong>参数集合上的一个函数</strong>，是一阶语言到自然语言的翻译<ul>
<li>例子; $(\mathbb{C};0,1,+,\cdot)$</li>
</ul>
</li>
</ul>
<ol>
<li>全称量词 $\forall$ 对应的所有元素$|\mathfrak{A}|$ 叫做 $\mathfrak{A}$ 的论域.</li>
<li>每个 n 位谓词符号 P 都在 $|\mathfrak{A}|$上有一个 n 元关系  $P^{\mathfrak{A}}$</li>
<li>每个常数符号 c 都在 $|\mathfrak{A}|$上有成员 $c^{\mathfrak{A}}$ </li>
<li>每个 n 位函数符号$f$  都在 $|\mathfrak{A}|$上有一个 n次运算 $f^{\mathfrak{A}}$ .</li>
</ol>
<p><em><strong>满足</strong></em>：设 $\phi$ 为合式公式, 并且 $s:V\rightarrow\mathfrak{A}$,  $V$ 是所有变量的集合. 那么 $\mathfrak{A}$ 用$s$<strong>满足</strong>$\phi$, （$\vDash_{\mathfrak{A}}\phi[s]$）, 当且仅当</p>
<ul>
<li><p>项满足的定义：首先扩展 $s$ 到 $\overline{s}$ ，定义如下</p>
<ul>
<li>a）对所有变量$x$, $\overline{s}(x)&#x3D;s(x)$</li>
<li>b)  对所有常量 $\overline{s}(c)&#x3D;c^{\mathfrak{A}}$, </li>
<li>c) 对所有项 $\overline{s}(ft_{1}\ldots t_{n})&#x3D;f^{\mathfrak{A}}(\overline{s}(t_{1}),\ldots,\overline{s}(t_{n}))$.</li>
</ul>
</li>
<li><p>原子公式的满足定义：</p>
<ul>
<li>a) $\vDash_{\mathfrak{A}}&#x3D;t_{1}t_{2}[s]$ iff $\overline{s}(t_{1})&#x3D;\overline{s}(t_{2})$ </li>
<li>b) $\vDash_{\mathfrak{A}}Pt_{1}\ldots t_{n}[s]$ iff $&lt;\overline{s}(t_{1}),\ldots,\overline{s}(t_{n})&gt;\in P^{\mathfrak{A}}$.</li>
</ul>
</li>
<li><p>最后，我们将满足的概念扩展到所有合式公式: </p>
<ul>
<li><p>a) $\vDash_{\mathfrak{A}}\neg\phi[s]$ iff $\not\vDash_{\mathfrak{A}}\phi[s]$, </p>
</li>
<li><p>b) $\vDash_{\mathfrak{A}}(\phi\rightarrow\psi)[s]$ iff $\not\vDash_{\mathfrak{A}}\phi[s]$ or $\vDash_{\mathfrak{A}}\psi[s]$, </p>
</li>
<li><p>c) $\vDash_{\mathfrak{A}}\forall x\phi[s]$ iff 对任意 $d\in|\mathfrak{A}|$, $\vDash_{\mathfrak{A}}\phi[s(x|d)]$ </p>
<ul>
<li>（其中 $s(x|d)$在除 $ s(x| d)(x)&#x3D;d$ 之外的所有地方都是 s）</li>
</ul>
</li>
<li><p>另一种方法是，给定 $\mathfrak{A}$, 递归地定义函数 $\overline{h}(\phi)$ 为函数集 $s$ ，使得 $\mathfrak{A}$ 用$s $满足$\phi$</p>
</li>
</ul>
</li>
</ul>
<p>假设 $s$ 和 $s’$在 $\phi$ 中自由出现的所有变量上有相同的映射，则 $\vDash_{\mathfrak{A}}\phi[s]$ iff $\vDash_{\mathfrak{A}}\phi[s’]$.</p>
<ul>
<li>类似地，如果结构$\mathfrak{A}$ 和 $\mathfrak{B}$在 $\phi$ 中出现的所有参数上一致，那么对任意$s$有   $\vDash_{\mathfrak{A}}\phi[s]$  iff   $\vDash_{\mathfrak{B}}\phi[s]$</li>
</ul>
<p>对一个句子 $\sigma$ ，要么 $\vDash_{\mathfrak{A}}\sigma[s]$ ,要么 $\not\vDash_{\mathfrak{A}}\sigma[s]$。$s$是任意的函数。</p>
<p><em><strong>模型</strong></em>：$\mathfrak{A}$  是句子$\sigma$<strong>的模型</strong>：当且仅当 $\sigma$ 在 结构$\mathfrak{A}$中是真的, </p>
<ul>
<li>$\vDash_{\mathfrak{A}}\sigma$, 意味着对任意$s$ $\vDash_{\mathfrak{A}}\sigma[s]$ . </li>
<li>$\mathfrak{A}$ 是一组句子的模型当且仅当它是该集合中每个句子的模型。</li>
</ul>
<h2 id="Logical-Implication-逻辑蕴涵"><a href="#Logical-Implication-逻辑蕴涵" class="headerlink" title="Logical Implication 逻辑蕴涵"></a>Logical Implication 逻辑蕴涵</h2><p><em><strong>逻辑蕴涵</strong></em>：一组合式公式 $\Gamma$ <strong>逻辑蕴涵</strong> 一个合式公式 $\phi$, 表示为$\Gamma\vDash\phi$, 当且仅当对任意结构 $\mathfrak{A}$ 中的所有 $s:V\rightarrow|\mathfrak{A}|$，有 $\vDash_{\mathfrak{A}}\Gamma[s]$ 蕴含$\vDash_{\mathfrak{A}}\phi[s]$</p>
<blockquote>
<p> 蕴含：（满足前者时，后者也满足）</p>
</blockquote>
<ul>
<li>合式公式 $\phi$ 和 $\psi$  <strong>逻辑等价</strong> 当且仅当 $\phi\vDash\psi$ and $\psi\vDash\phi$.<ul>
<li>$\Gamma;\phi\vDash\psi$ iff $\Gamma\vDash(\phi\rightarrow\psi)$.</li>
</ul>
</li>
<li>合式公式 $\phi$ 被称作 <strong>恒真的</strong>, ($\vDash\phi$), 当且仅当$\emptyset\vDash\phi$.<ul>
<li>$\phi$ 和 $\psi$ 逻辑等价 iff $(\phi\leftrightarrow\psi)$ 恒真.</li>
<li>$\phi$ 恒真 iff $\forall x\phi$ 恒真.</li>
</ul>
</li>
</ul>
<p>对句子而言:  $\Sigma\vDash\tau$ iff  $\Sigma$ 的每个模型也是 $\tau$的模型. </p>
<ul>
<li>$\tau$ 恒真 iff 它在每个模型中都被满足.</li>
</ul>
<h2 id="Homomorphisms-同态"><a href="#Homomorphisms-同态" class="headerlink" title="Homomorphisms 同态"></a>Homomorphisms 同态</h2><p><strong>同态</strong>：</p>
<ul>
<li>$h:|\mathfrak{A}|\rightarrow|\mathfrak{B}|$ 是 $\mathfrak{A}$ 到 $\mathfrak{B}$ 的<strong>同态映射</strong>，当且仅当它在谓词关系和函数（包括常数）方面保持不变。</li>
</ul>
<p><strong>同构</strong>：</p>
<ul>
<li><p>如果 $h$ 是 $\mathfrak{A}$ 到 $\mathfrak{B}$ 的<strong>同构（同构嵌入）</strong>：那么它是一对一的同态映射。</p>
</li>
<li><p>$\mathfrak{A}$ 和 $\mathfrak{B}$ 被称为<strong>同构</strong>，记作 $\mathfrak{A}\cong\mathfrak{B}$，当且仅当存在 $\mathfrak{A}$ 到 $\mathfrak{B}$ 的同构映射。</p>
</li>
</ul>
<p><strong>同态定理。</strong> 如果 $h$ 是 $\mathfrak{A}$ 到 $\mathfrak{B}$ 的同态映射，并且 $s:V\rightarrow|\mathfrak{A}|$，那么</p>
<ul>
<li>(a) 对于任何项 $t$，$\overline{h\circ s}(t)&#x3D;h(\overline{s}(t))$。</li>
<li>(b) 对于任何<strong>无全称量词和等式</strong>的公式 $\alpha$，$\vDash_{\mathfrak{A}}\alpha[s]$ 当且仅当 $\vDash_{\mathfrak{B}}\alpha[h\circ s]$。</li>
<li>(c)  在 (b) 中，如果 $h$ 是一对一的（同构），则 $\alpha$ 可能包含等式符号，如果 $h$ 是满射（同态），则可能包含量词符号。</li>
</ul>
<p><strong>子结构</strong>：$\mathfrak{A}$ 是 $\mathfrak{B}$ 的子结构，或者说 $\mathfrak{B}$ 是 $\mathfrak{A}$ 的<strong>扩充</strong>，当且仅当 $|\mathfrak{A}|\subseteq|\mathfrak{B}|$，并且从 $|\mathfrak{A}|$ 到 $|\mathfrak{B}|$ 的恒等映射是同构的。</p>
<ul>
<li>如果 a) 对于每个谓词 $P$，$P^{\mathfrak{A}}$ 是 $P^{\mathfrak{B}}$ 对 $|\mathfrak{A}|$ 的限制，b) 对于每个常数 $c$，$c^{\mathfrak{A}}&#x3D;c^{\mathfrak{B}}$，并且 c) 对于每个函数 $f$，$f^{\mathfrak{A}}$ 是 $f^{\mathfrak{B}}$ 对 $|\mathfrak{A}|$ 的限制，则恒等映射是同构的。	</li>
<li>对于每个结构 $\mathfrak{A}$ 和函数 $h$，使得 $\mbox{ran}h&#x3D;|\mathfrak{A}|$，存在一个结构 $\mathfrak{B}$，使得 $h$ 是 $\mathfrak{B}$ 到 $\mathfrak{A}$ 的同态映射。</li>
<li>对于每个结构 $\mathfrak{A}$ 和一对一函数 $h$，使得 $\mbox{dom}h&#x3D;|\mathfrak{A}|$，存在唯一的结构 $\mathfrak{B}$，使得 $h$ 是 $\mathfrak{A}$ 到 $\mathfrak{B}$ 的同构映射。</li>
<li>如果 $h$ 是 $\mathfrak{A}$ 到 $\mathfrak{B}$ 的同构，则存在一个结构 $\mathfrak{C}$，使得 $\mathfrak{A}$ 是 $\mathfrak{C}$ 的子结构，并且 $\mathfrak{C}$ 同构于 $\mathfrak{B}$。</li>
</ul>
<p><strong>自同构</strong>：$\mathfrak{A}$ 到 $\mathfrak{A}$ 的同构映射被称为自同构。</p>
<ul>
<li>恒等映射是自同构的。如果还有其他自同构，则 $\mathfrak{A}$ 被称为<strong>固化的</strong>。</li>
<li>如果 $R$ 是 $\mathfrak{A}$ 中可在 $\mathfrak{A}$ 中定义的 $n$ 元关系，则自同构会保持它。<ul>
<li>一些关系在结构中不可定义的例子：$\mathbb{N}$ 在 $(\mathbb{R},&lt;)$ 中是不可定义的，$h(x)&#x3D;x&#x2F;2$ ；长度在向量空间中通过加法和标量乘法是不可定义的，$h(v)&#x3D;2v$。</li>
</ul>
</li>
</ul>
<h2 id="Elementarily-equivalent-structures-初等等价"><a href="#Elementarily-equivalent-structures-初等等价" class="headerlink" title="Elementarily equivalent structures 初等等价"></a>Elementarily equivalent structures 初等等价</h2><p>$\mathfrak{A}$ 和 $\mathfrak{B}$ 是<strong>初等等价的</strong>，$\mathfrak{A}\equiv\mathfrak{B}$，当且仅当对于任何句子 $\sigma$，$\vDash_{\mathfrak{A}}\sigma$ 当且仅当 $\vDash_{\mathfrak{B}}\sigma$。</p>
<ul>
<li>同构的结构是初等等价的：$\mathfrak{A}\cong\mathfrak{B}$ 意味着 $\mathfrak{A}\equiv\mathfrak{B}$。<ul>
<li>如果 $\mathfrak{A}$ 是有限的，$\mathfrak{A}\equiv\mathfrak{B}$ 意味着 $\mathfrak{A}\cong\mathfrak{B}$。</li>
<li>反方向不一定成立：$(\mathbb{R};&lt;<em>{R})$ 和 $(\mathbb{Q};&lt;</em>{Q})$ 是初等等价的但不同构。</li>
</ul>
</li>
<li>$(\mathbb{N};&lt;<em>{N})$ 和 $(\mathbb{R};&lt;</em>{R})$ 不是初等等价的，但在 $(\mathbb{R};&lt;<em>{R})$ 中对每个 $\exists</em>{2}$ 句子为真的 $\sigma$ 也在 $(\mathbb{N};&lt;_{N})$ 中为真。</li>
</ul>
<p>初等等价类</p>
<ul>
<li>结构 $\mathfrak{A}$ 的<strong>初等等价类</strong>是与 $\mathfrak{A}$ 初等等价的所有结构的类。</li>
</ul>
<h2 id="结构中的可定义性"><a href="#结构中的可定义性" class="headerlink" title="结构中的可定义性"></a>结构中的可定义性</h2><p>可定义的：</p>
<ul>
<li><p>如果存在定义（区分）关系的一个公式 $\phi$ ，则 $|\mathfrak{A}|$ 上的 $k$ 元关系是<strong>在 $\mathfrak{A}$ 中可定义的</strong>。</p>
</li>
<li><p>例子：</p>
<ul>
<li>在 $\mathfrak{N}&#x3D;(\mathbb{N};&lt;,+,\cdot)$ 中，所有可判定的关系都是可定义的，但还有许多其他关系。<ul>
<li>素数集、序关系是可定义的</li>
</ul>
</li>
<li>在 $\mathfrak{R}&#x3D;(\mathbb{R};&lt;,+,\cdot)$ 中，集合是可定义的，当且仅当它是具有端点的区间的有限并集、</li>
</ul>
</li>
</ul>
<h2 id="结构类的可定义性"><a href="#结构类的可定义性" class="headerlink" title="结构类的可定义性"></a>结构类的可定义性</h2><hr>
<p>对于一组句子 $\Sigma$，$\mbox{Mod}\Sigma$ 是 $\Sigma$ 的所有模型的类。</p>
<p>对于语言的结构类 $\mathcal{K}$，如果对于某个句子 $\tau$， $\mathcal{K}&#x3D;\mbox{Mod}\tau$ ，则称其为<strong>初等类（$EC$）</strong>。</p>
<p>对于语言的结构类 $\mathcal{K}$，如果对于某个句子集 $\Sigma$， $\mathcal{K}&#x3D;\mbox{Mod}\Sigma$ ，则称其为<strong>广义初等类（$EC{}_{\Delta}$）</strong>。</p>
<h1 id="Section-2-3-A-Parsing-Algorithm解析算法"><a href="#Section-2-3-A-Parsing-Algorithm解析算法" class="headerlink" title="Section 2.3:  A Parsing Algorithm解析算法"></a>Section 2.3:  A Parsing Algorithm解析算法</h1><p>对于递归的论证和定义，有必要论证分解项和合式公式的唯一性。</p>
<h2 id="Terms-项"><a href="#Terms-项" class="headerlink" title="Terms 项"></a>Terms 项</h2><p>对于变量、常量和函数符号的字符串，我们定义一个函数 $K$ 如下：</p>
<ul>
<li><p>$K(x)&#x3D;1$（$x$本身就是一个项，因此它在字符串中的出现增加了一个完整的项）。</p>
</li>
<li><p>$K(c)&#x3D;1$（常量也是如此）。</p>
</li>
<li><p>$K(f)&#x3D;1-n$，其中 $f$ 是一个 $n$ 元函数符号（函数符号意味着一旦找到字符串中的所有 $n$ 个项（$f$ 的参数），就会有一个完整的项）。</p>
</li>
<li><p>$K(s_{1}\ldots s_{n})&#x3D;K(s_{1})+\ldots+K(s_{n})$。</p>
</li>
</ul>
<p>对于项 $t$，$K(t)&#x3D;1$。 对于项 $t$ 的任何终端片段 $t_{1}$，$t_{1}$ 是项的连接，特别是 $K(t_{1})\ge1$。 对于项 $t$ 的任何适当的初始片段 $t_{0}$，$K(t_{0})\le0$，特别是 $t_{0}$ 不是项。</p>
<h3 id="项解析算法"><a href="#项解析算法" class="headerlink" title="项解析算法"></a>项解析算法</h3><p>略。唯一分解算法</p>
<p><strong>（项的唯一可读性）</strong> 项的集合是由变量和常量符号的集合通过 $\mathcal{F}_{f}$ 操作自由生成的。</p>
<h2 id="Formulas-合式公式"><a href="#Formulas-合式公式" class="headerlink" title="Formulas 合式公式"></a>Formulas 合式公式</h2><p>我们可以进一步为其他符号定义 $K$：</p>
<ul>
<li>$K(()&#x3D;-1$。</li>
<li>$K())&#x3D;1$。</li>
<li>$K(\forall)&#x3D;-1$。</li>
<li>$K(\neg)&#x3D;0$。</li>
<li>$K(\rightarrow)&#x3D;-1$。</li>
<li>$K(P)&#x3D;1-n$，其中 $P$ 是一个 $n$ 元谓词符号。</li>
<li>$K(&#x3D;)&#x3D;-1$。</li>
</ul>
<p>对于 wff $\alpha$，$K(\alpha)&#x3D;1$。 对于 wff $\alpha$ 的任何适当的初始片段 $\alpha_{0}$，$K(\alpha_{0})\le0$，特别是 $\alpha_{0}$ 不是 wff。</p>
<h3 id="合式公式解析算法"><a href="#合式公式解析算法" class="headerlink" title="合式公式解析算法"></a>合式公式解析算法</h3><p>略。唯一分解算法</p>
<p><strong>（公式的唯一可读性）</strong> 从原子公式的集合通过操作 $\mathcal{E}<em>{\neg}$、$\mathcal{E}</em>{\rightarrow}$ 和 $\mathcal{Q}_{i}$，其中 $i&#x3D;1,2,\ldots$ 自由生成的 wff 集合。</p>
<h1 id="Section-2-4-A-Deductive-Calculus-演绎计算"><a href="#Section-2-4-A-Deductive-Calculus-演绎计算" class="headerlink" title="Section 2.4: A Deductive Calculus 演绎计算"></a>Section 2.4: A Deductive Calculus 演绎计算</h1><p>此章节有利于重新建立对推理的数学直觉！！！</p>
<blockquote>
<p>假设 $\Sigma\vDash\tau$。 </p>
<ul>
<li><p>证明这一事实需要什么证明方法？</p>
</li>
<li><p>是否一定存在证明？</p>
</li>
</ul>
</blockquote>
<p>什么是证明？</p>
<ul>
<li><strong>有限性。</strong>这是由于一阶逻辑的紧致性定理，可以保证只需要 $\Sigma$ 的一个有限子集来证明 $\Sigma\vDash\tau$。</li>
<li><strong>可验证性。</strong>证明的每一步都应该是可以验证的，这意味着可以从空集假设（$\Sigma&#x3D;\emptyset$）中可验证地推导出来。<ul>
<li>这将意味着所有恒真的集合是可以能行可枚举的。这是由于可枚举性定理在合理的假设下证明了能行可枚举性。</li>
</ul>
</li>
</ul>
<p>证明的上限和局限：</p>
<ul>
<li><strong>紧致性定理和可枚举性定理</strong>意味着<strong>对于每个 $\Sigma\vDash\tau$ 都存在一个可以在有限步内找到的有限证明。</strong></li>
</ul>
<ul>
<li><strong>哥德尔的不完备定理</strong>是关于数理逻辑中的形式系统的性质的结果。第一不完备定理说明，对于足够强大的自包含系统，总存在一个在该系统内无法证明或证伪的陈述。</li>
<li>紧致性和可枚举性定理是积极的性质，而哥德尔不完备定理揭示了系统的局限性。</li>
</ul>
<h2 id="Deductions-演绎"><a href="#Deductions-演绎" class="headerlink" title="Deductions 演绎"></a>Deductions 演绎</h2><p>给 合式公式 $\phi$，**$\phi$的概化**是一个公式 $\forall x_{1}\ldots\forall x_{n}\phi$，其中 $n\ge0$，且变量为 $x_{1},\ldots,x_{n}$。</p>
<p><strong>逻辑公理</strong>：所有逻辑公理它们都是以下公理的所有可能的_概化_。</p>
<ol>
<li><p>永真式（重言式）。</p>
<ul>
<li><p><strong>基本公式</strong> 要么是一个原子公式，要么是形式为 $\forall x\alpha$ 的公式。</p>
</li>
<li><p><strong>非基本公式</strong>是任何其他公式（由使用 $\neg$ 和 $\rightarrow$ 构建的不同于主要公式的任何其他公式）。</p>
</li>
<li><p>给定任何合式公式，它由使用 $\mathcal{E}<em>{\neg}$ 和 $\mathcal{E}</em>{\rightarrow}$ 构建的基本公式构成</p>
<ul>
<li><p>因此，可以将其视为命题逻辑的句子，其中所有基本公式都被视为命题符号。当它在命题逻辑中是永真式时，它在一阶逻辑中也是<strong>永真式</strong>。</p>
</li>
<li><p>如果 $\Gamma$ 重言蕴含 $\phi$，则 $\Gamma$ 逻辑蕴含 $\phi$，但反之未必成立。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>$\forall x\alpha\rightarrow\alpha_{t}^{x}$，其中 $t$ 在 $\alpha$ 中可以替代 $x$。（难点）</p>
<p>$\alpha_{t}^{x}$的定义如下：</p>
<ul>
<li>a）如果 $\alpha$ 是原子的，则 $t$ 替代每个 $x$，</li>
<li>b）($\neg\alpha$)$<em>{t}^{x}$&#x3D;($\neg\alpha$)$</em>{t}^{x}$，</li>
<li>c）($\alpha\rightarrow\beta$)$<em>{t}^{x}$&#x3D;($\alpha</em>{t}^{x}\rightarrow\beta_{t}^{x}$)，</li>
<li>d）($\forall x\alpha$)$_{t}^{x}$&#x3D;$\forall x\alpha$，$y&#x3D;x$</li>
<li>e）($\forall y\alpha$)$<em>{t}^{x}$&#x3D;$\forall y\alpha</em>{t}^{x}$，其中 $y\neq x$。</li>
</ul>
<p> 合式公式$\alpha$ 中**$x$可以被$t$替换**当且仅当：（否则替换后可能不再满足）</p>
<ul>
<li>a）如果 $\alpha$ 是原子公式，无量词，不受限制，</li>
<li>b）如果 $\alpha$&#x3D;($\neg\beta$) 并且 $t$ 在 $\beta$ 中可以替代 $x$，</li>
<li>c）$\alpha$&#x3D;($\beta\rightarrow\gamma$) 并且 $t$ 在 $\beta$ 和 $\gamma$ 中可以替代 $x$，</li>
<li>d）如果 $\alpha$&#x3D;($\forall y\beta$) 并且（ [ $x$ 在 $\alpha$ 中没有自由出现 ] 或 [ $y$ 在 $t$ 中没有出现且 $t$ 在 $\beta$ 中可以替代 $x$ ]）。</li>
</ul>
</li>
</ol>
<blockquote>
<p>注意：$x$ 总是可以替代 $x$，不包含在 $\alpha$ 中的任何变量的 $t$ 总是可以替代 $\alpha$ 中的任何 $x$。</p>
<p>对于任何 $\alpha$，$t$ 和 $x$，总是存在 $\alpha’$ 等效于 $\alpha$，使得 $t$ 可以替代 $\alpha’$ 中的 $x$（参考下面的字母变换式)</p>
<ul>
<li>举例：在一些 $\forall y\beta$ 的情况下，其中 $y\neq x$，$x$ 在 $\beta$ 中是自由的，$t$ 可以在 $\beta$ 中替代 $x$ ，但 $y$ 出现在 $t$ 中。在这种情况下，我们将其重写为 $\forall z\beta_{z}^{y}$）。</li>
</ul>
</blockquote>
<ol start="3">
<li>$\forall x(\alpha\rightarrow\beta)\rightarrow(\forall x\alpha\rightarrow\forall x\beta)$。</li>
<li>$\alpha\rightarrow\forall x\alpha$，其中 $x$ 在 $\alpha$ 中没有自由出现。</li>
<li>（如果语言有 $&#x3D;$ ）$x&#x3D;x$。</li>
<li>（如果语言有 $&#x3D;$ ）$x&#x3D;y\rightarrow\alpha\rightarrow\alpha’$，其中 $\alpha$ 是原子的，$\alpha’$ 是通过将 $\alpha$ 中的零个或更多但不一定是全部的地方替换为 $y$ 而得到的。</li>
</ol>
<h2 id="Rules-of-Inference-推理规则"><a href="#Rules-of-Inference-推理规则" class="headerlink" title="Rules of Inference 推理规则"></a><strong>Rules of Inference 推理规则</strong></h2><ol>
<li><strong>假言推理</strong>：从 $\alpha$，$\alpha\rightarrow\beta$ 推导出 $\beta$。</li>
</ol>
<p>给定公式集 $\Gamma$（以及逻辑公理集 $\Lambda$，参考上面六条）。如果 $\phi$ 可以通过使用推理规则（有限次数）从 $\Gamma\cup\Lambda$ 得到，则 $\phi$ 是**$\Gamma$的定理<strong>（$\phi$是</strong>从$\Gamma$推导出的<strong>），表示为 $\Gamma\vdash\phi$。</strong>从$\Gamma$推导出$\phi$**的描述说明了如何从 $\Gamma$（和 $\Lambda$）中获得 $\phi$，即它是一系列有限的公式 &lt;$\alpha_{0}$，$\ldots$，$\alpha_{n}$&gt;，满足</p>
<p>​		a) $\alpha_{n}$&#x3D; $\phi$，</p>
<p>​		b) 对于 $k\le n$，$\alpha_{k}$ 要么在 $\Gamma\cup\Lambda$ 中，要么由一些 $\alpha_{i}$ 和 $\alpha_{j}$&#x3D;($\alpha_{i}\rightarrow\alpha_{k}$) 的假言三段论得到，其中 $i,j&lt;k$。</p>
<ul>
<li>如果 $\Gamma\vdash\alpha$，则 $\Gamma\cup\Lambda$ 逻辑蕴含 $\alpha$。</li>
<li>如果 $\alpha$ 重言蕴含 $\beta$，那么 $\alpha$ 逻辑蕴含 $\beta$。</li>
</ul>
<h3 id="其他推理规则"><a href="#其他推理规则" class="headerlink" title="其他推理规则"></a>其他推理规则</h3><p><strong>（概化定理）</strong> 如果 $\Gamma\vdash\alpha$，并且 $x$ 不在 $\Gamma$ 的任何合式公式wff中自由出现，则 $\Gamma\vdash\forall x\alpha$。</p>
<ul>
<li><strong>（常量的概化）</strong> 如果 $\Gamma\vdash\alpha$，并且常量符号 $c$ 不在 $\Gamma$ 的任何 wff 中出现，则存在一个变量 $x$ 不在 $\alpha$ 中出现，使得 $\Gamma\vdash\forall x\alpha_{x}^{c}$（以及从 $\Gamma$ 推导出 $\forall x\alpha_{x}^{c}$ 而不使用 $c$）。<ul>
<li>如果 $\Gamma\vdash\alpha_{c}^{x}$，其中常量符号 $c$ 在 $\Gamma$ 的任何 wff 中或 $\alpha$ 中都没有出现，则 $\Gamma\vdash\forall x\alpha$（从 $\Gamma$ 推导出 $\forall x\alpha$ 而不使用 $c$）。</li>
<li><strong>（规则EI ： 存在某个实例）</strong> 如果 $\Gamma$;$\alpha_{c}^{x}\vdash\beta$，其中常量符号 $c$ 在 $\Gamma$ 的任何 wff 或 $\alpha$ 中都没有出现，则 $\Gamma$;$\exists x\alpha\vdash\beta$（从 $\Gamma$;$\exists x\alpha$ 推导出 $\beta$ 而不使用 $c$）。</li>
</ul>
</li>
</ul>
<p><strong>（规则T）</strong> 如果 $\Gamma\vdash\alpha_{i}$，$i$&#x3D;1,$\ldots$,$n$，并且{$\alpha_{1}$，$,\ldots$，$\alpha_{n}$} 逻辑蕴含 $\beta$，那么 $\Gamma\vdash\beta$。</p>
<p><strong>（演绎定理）</strong> 如果 $\Gamma$;$\alpha\vdash\beta$，那么 $\Gamma\vdash(\alpha\rightarrow\beta)$。</p>
<p><strong>（反证法）</strong> 如果 $\Gamma$;$\alpha\vdash\neg\beta$，那么 $\Gamma$;$\beta\vdash\neg\alpha$。</p>
<p>  <strong>(不和谐)</strong> 一组 wffs $\Gamma$ <strong>不和谐</strong> 当且仅当对于某个 wff $\phi$，$\Gamma\vdash${$\phi$，$\neg\phi$}。</p>
<ul>
<li>最大和谐集：对于每个和谐的 $\Gamma$，都存在和谐的 $\Delta\supseteq\Gamma$，使得对于每个 wff $\alpha$，要么 $\alpha\in\Delta$ 要么 ($\neg\alpha$)$\in\Delta$。</li>
</ul>
<p><strong>（归谬法）</strong> 如果 $\Gamma$;$\alpha$ 不和谐 ，则 $\Gamma\vdash\neg\alpha$。</p>
<p><strong>（再替换引理）</strong> 如果 $y$ 在 $\alpha$ 中没有出现，那么 $x$  在 $\alpha_{y}^{x}$ 中可以替代 $y$，且 ($\alpha_{y}^{x}$)$_{x}^{y}$&#x3D;$\alpha$。</p>
<p><strong>（字母变换式的存在性）</strong> 对于 wff $\alpha$，项 $t$ 和变量 $x$，总存在 wff $\alpha’$，满足 </p>
<p>​	a) $\alpha’$ 仅在量化变量的选择上与 $\alpha$ 不同，</p>
<p>​	b) $\alpha’$ 可以从 $\alpha$ 推导出来，反之亦然，</p>
<p>​	c) $t$ 可以替代 $\alpha’$ 中的 $x$。</p>
<ul>
<li><p>定理中描述的公式 $\alpha’$ 称为 $\alpha$ 的<strong>字母变换式</strong>。</p>
<p>**(等式的规则)**：</p>
</li>
</ul>
<ul>
<li>Eq1：$\vdash\forall xx&#x3D;x$（自反性）。</li>
<li>Eq2：$\vdash\forall x\forall y(x&#x3D;y\rightarrow y&#x3D;x)$（对称性）。</li>
<li>Eq3：$\vdash\forall x\forall y\forall z(x&#x3D;y\rightarrow y&#x3D;z\rightarrow x&#x3D;z)$（传递性）。</li>
<li>Eq4：$\vdash\forall x_{1}\forall x_{2}\forall y_{1}\forall y_{2}(x_{1}&#x3D;y_{1}\rightarrow x_{2}&#x3D;y_{2}\rightarrow Px_{1}x_{2}\rightarrow Py_{1}y_{2})$（对于 $n$ 元谓词符号也是类似的）。</li>
<li>Eq5：$\vdash\forall x_{1}\forall x_{2}\forall y_{1}\forall y_{2}(x_{1}&#x3D;y_{1}\rightarrow x_{2}&#x3D;y_{2}\rightarrow fx_{1}x_{2}&#x3D;fy_{1}y_{2})$（对于 $n$ 元函数符号也是类似的）。</li>
</ul>
<h2 id="推理策略"><a href="#推理策略" class="headerlink" title="推理策略"></a>推理策略</h2><p>假设我们想要推导 $\Gamma\vdash\phi$，一些逆向思考的方式：</p>
<ol>
<li>如果 $\phi$&#x3D;($\alpha\rightarrow\beta$)，证明 $\Gamma$;$\alpha\vdash\beta$ 就足够了（演绎定理）。</li>
<li>如果 $\phi$&#x3D;$\forall x\alpha$，<ol>
<li>如果 $x$ 在 $\Gamma$ 中不自由出现，证明 $\Gamma\vdash\alpha$ 就足够了（概化定理）。</li>
<li>如果 $x$ 在 $\Gamma$ 中自由出现，使用再替换引理，证明 $\Gamma\vdash\alpha_{y}^{x}$ 就足够了。</li>
</ol>
</li>
<li>如果 $\phi$&#x3D;($\neg\alpha$)，<ol>
<li>如果 $\alpha$&#x3D;($\beta\rightarrow\gamma$)，证明 $\Gamma\vdash${$\beta$，$\neg\gamma$} 就足够了（并且总是可能的）。</li>
<li>如果 $\alpha$&#x3D;$\neg\beta$，证明 $\Gamma\vdash\beta$ 就足够了。</li>
<li>如果 $\alpha$&#x3D;$\forall x\beta$，则需要证明 $\Gamma\vdash\neg\beta_{t}^{x}$，其中 $t$ 可以在 $\beta$ 中替代 $x$ ，但归谬法不总是成立的。</li>
</ol>
</li>
</ol>
<h1 id="Section-2-5-Soundness-and-Completeness-Theorems-可靠性和完备性定理"><a href="#Section-2-5-Soundness-and-Completeness-Theorems-可靠性和完备性定理" class="headerlink" title="Section 2.5: Soundness and Completeness Theorems 可靠性和完备性定理"></a>Section 2.5: Soundness and Completeness Theorems 可靠性和完备性定理</h1><h2 id="Soundness-可靠性"><a href="#Soundness-可靠性" class="headerlink" title="Soundness 可靠性"></a><strong>Soundness 可靠性</strong></h2><p>每个逻辑公理A1-A6都是恒真的。</p>
<ul>
<li>证明见书习题</li>
</ul>
<p>一组合式公式集合 $\Gamma$ 被称为<strong>可满足的</strong>，当且仅当存在 $\mathfrak{A}$ 和 $s:V\rightarrow|\mathfrak{A}|$，使得 $\mathfrak{A}$ 用 $s$ 满足 $\Gamma$ 中的每个成员。</p>
<p><strong>(可靠性定理)</strong> 如果 $\Gamma\vdash\phi$，那么 $\Gamma\vDash\phi$。</p>
<ul>
<li>另一种表述：如果 $\Gamma$ 是可满足的，则 $\Gamma$ 是和谐的。</li>
<li>如果 $\vdash\phi\leftrightarrow\psi$ （等价于$\phi\vdash\psi$ 且 $\psi\vdash\phi$），那么 $\phi$ 和 $\psi$ 是逻辑等价的。<ul>
<li>字母变换式是逻辑等价的。</li>
</ul>
</li>
</ul>
<h2 id="Completeness-完备性"><a href="#Completeness-完备性" class="headerlink" title="Completeness  完备性"></a><strong>Completeness  完备性</strong></h2><p><strong>(完备性定理; Gödel, 1930)</strong> 如果 $\Gamma\vDash\phi$，那么 $\Gamma\vdash\phi$。</p>
<ul>
<li>另一种表述：如果 $\Gamma$ 是和谐的，则 $\Gamma$ 是可满足的。</li>
<li>证明概述（没完全懂，待看）：<ul>
<li>假设 $\Gamma$ 是和谐的。首先，我们通过添加无穷多个常数符号 $c_{\alpha}$ 扩展语言，并通过添加合式公式$\neg\forall x\phi\rightarrow\neg\phi_{c_{\alpha(\phi,x)}}^{x}$ 来扩展 $\Gamma$，其中 $x$ 是使用常数符号 $c_{\alpha(\phi,x)}$ 的 $\alpha(\phi,x)\neq\alpha(\psi,y)$，且 $c_{\alpha(\phi,x)}$ 不出现在 $\phi$ 中。生成的集合 $\Gamma’$ 是和谐的。此外，我们将 $\Gamma’$ 扩展为和谐的 $\Delta$，使得对于每个 $\phi$，要么 $\phi\in\Delta$ 要么 $\neg\phi\in\Delta$（在不可数的情况下也有$\Delta$ 是封闭的：$\Delta\vdash\phi$ 当且仅当 $\phi\in\Delta$）。</li>
<li>其次，我们定义 a) 新的二元关系 $E$（而不是 $&#x3D;$）；b) 一个结构 $\mathfrak{A}$ 其中 $|\mathfrak{A}|$ 是所有项（扩展语言的）的集合，$E^{\mathfrak{A}}&#x3D;{&lt;u,t&gt;|u&#x3D;t\in\Delta}$，$P^{\mathfrak{A}}&#x3D;{&lt;t_{1},\ldots,t_{n}&gt;|Pt_{1}\ldots t_{n}\in\Delta}$，$c^{\mathfrak{A}}&#x3D;c$；$f^{\mathfrak{A}}(t_{1},\ldots,t_{n})&#x3D;ft_{1}\ldots t_{n}$，和 c) 一个函数 $s:V\rightarrow|\mathfrak{A}|$ 通过 $s(x)&#x3D;x$（$\overline{s}(t)&#x3D;t$）。<ul>
<li>设 $\phi^{<em>}$ 是将 $&#x3D;$ 替换为 $E$ 的 $\phi$，$\phi\in\Delta$ 当且仅当 $\vDash_{\mathfrak{A}}\phi^{</em>}[s]$，</li>
</ul>
</li>
<li>第三，我们注意到 $E^{\mathfrak{A}}$ 是 $\mathfrak{A}$ 的同余关系（一个等价关系，使得 $P^{\mathfrak{A}}$ 和 $f^{\mathfrak{A}}$ 与 $E^{\mathfrak{A}}$ 兼容），因此商结构 $\mathfrak{A}&#x2F;E$ 具有以下性质：a) $h(t)&#x3D;[t]$ 是 $\mathfrak{A}$ 到 $\mathfrak{A}&#x2F;E$ 的同态映射，其中 $[t]&#x3D;{u\in|\mathfrak{A}|&lt;u,t&gt;\in E^{\mathfrak{A}}}$，b) $E^{\mathfrak{A}&#x2F;E}$ 是 $|\mathfrak{A}&#x2F;E|$ 上的相等关系，c) $\phi\in\Delta$ 当且仅当 $\vDash_{\mathfrak{A}&#x2F;E}\phi[h\circ s]$。将 $\mathfrak{A}&#x2F;E$ 限制为原始语言后，可以用 $h\circ s$ 满足 $\Gamma$ 中的每个成员。 因此$\Gamma$是可满足的</li>
</ul>
</li>
</ul>
<p><strong>(紧致性定理)</strong> 如果 $\Gamma\vDash\phi$，那么对于某个有限的 $\Gamma_{0}\subseteq\Gamma$，$\Gamma_{0}\vDash\phi$。</p>
<ul>
<li>$\Gamma$ 是可满足的当且仅当 $\Gamma_{0}\subseteq\Gamma$ 中的每个有限子集都是可满足的。$\Sigma$ 有一个模型当且仅当 $\Sigma_{0}\subseteq\Sigma$ 中的每个有限子集都有一个模型。</li>
<li>不相交的 $EC_{\Delta}$ 类可以通过一个 $EC$ 类分离：如果对于两个句子集，$\text{Mod}\Sigma_{1}\cup\Sigma_{2}&#x3D;\emptyset$，那么存在一个句子 $\tau$，使得 $\text{Mod}\Sigma_{1}\subseteq\text{Mod}\tau$ 且 $\text{Mod}\Sigma_{2}\subseteq\text{Mod}\neg\tau$。<ul>
<li>例子：对于 $\mathfrak{A}&#x3D;(\mathbb{Z};P^{\mathfrak{A}})$： $&lt;a,b&gt;\in P^{\mathfrak{A}}$ 当且仅当 $|a-b|&#x3D;1$，这个谓词关系存在一个分离结构$EC$ 类。</li>
</ul>
</li>
</ul>
<h2 id="Decidability-可判定性"><a href="#Decidability-可判定性" class="headerlink" title="Decidability 可判定性"></a>Decidability <strong>可判定性</strong></h2><p>*定义表达式集合卫是可判定的当且仅当对于给定的表达式α,存在能行的过程来判定α是否属于$\Gamma$</p>
<ul>
<li>可判定的:是或否</li>
</ul>
<p><strong>(可枚举性定理)</strong> 对于一个合理的语言，可以有效枚举合式公式的集合。</p>
<p>合理语言：</p>
<ul>
<li>合理语言参数的集合可以<strong>能行枚举</strong>，并且关系 ${&lt;P,n&gt;|P\text{是}n\text{-位谓词符号}}$ 和 ${&lt;f,n&gt;|f\text{ 是 }n\text{-位函数符号}}$ 是可判定的</li>
</ul>
<p>有限语言</p>
<ul>
<li><p>一个<strong>有限语言</strong>是只有有限多个参数的语言。有限语言是合理的。</p>
</li>
<li><p>一个合理的语言必须是可数的。</p>
</li>
</ul>
<p>推论：</p>
<ul>
<li><p>如果 $\Gamma$ 是可判定的且语言是合理的，则 $\text{Th}\Gamma$ 和 ${\phi|\Gamma\vDash\phi}$ 可以被有效枚举。</p>
</li>
<li><p>如果 $\Gamma$ 是可判定的、语言是合理的，并且对于每个句子 $\sigma$，要么$\Gamma\vDash\sigma$ 要么 $\Gamma\vDash\neg\sigma$，那么 ${\sigma|\Gamma\vDash\sigma}$ 是可判定的。</p>
</li>
</ul>
<h1 id="Section-2-6-Models-of-Theories-理论的模型"><a href="#Section-2-6-Models-of-Theories-理论的模型" class="headerlink" title="Section 2.6: Models of Theories 理论的模型"></a>Section 2.6: Models of Theories 理论的模型</h1><h2 id="Finite-Models-有限模型"><a href="#Finite-Models-有限模型" class="headerlink" title="Finite Models 有限模型"></a><strong>Finite Models 有限模型</strong></h2><p>一个句子是<strong>有限恒真的</strong>，当且仅当它在每个有限模型中都为真。</p>
<ul>
<li>有限恒真句子的否定仅在无限模型中为真</li>
<li>反之亦然，如果一个句子仅在无限模型中为真，则其否定是有限恒真的。</li>
</ul>
<p>如果一组句子有任意大的有限模型，那么它有一个无限模型。</p>
<ul>
<li><p>如果一个句子在理论 $T$ 的所有无限模型中都为真，则对于某个 $n\in\mathbb{N}$，它在大小为 $\ge n$ 的 $T$ 的所有模型中也为真。</p>
<ul>
<li>推广性质。对阿列夫数也成立</li>
</ul>
</li>
<li><p>所有有限模型的类不是 $EC_{\Delta}$。所有无限模型的类是 $EC_{\Delta}$。</p>
</li>
</ul>
<h2 id="Size-of-Models-模型的大小"><a href="#Size-of-Models-模型的大小" class="headerlink" title="Size of Models 模型的大小"></a><strong>Size of Models 模型的大小</strong></h2><p>假设语言的基数是 $\lambda$。</p>
<p><strong>(Löwenheim–Skolem, 1915, 1920)</strong> 如果 $\Gamma$ 是可满足的，则 $\Gamma$ 可在基数 $\le\lambda$ 的某个结构中满足。如果 $\Sigma$ 有一个模型，则 $\Sigma$ 有一个基数 $\le\lambda$ 的模型。</p>
<p><strong>(LST，即Löwenheim–Skolem-Tarski)</strong> 如果 $\Gamma$ 在无限结构中是可满足的，则对于每个 $\kappa\ge\lambda$，$\Gamma$ 在基数 $\kappa$ 的某个结构中是可满足的。如果 $\Sigma$ 有一个无限模型，则对于每个 $\kappa\ge\lambda$，$\Sigma$ 在基数 $\kappa$ 的某个模型中是可满足的。</p>
<ul>
<li>对于基数 $\lambda$ 的语言，对于任意结构 $\mathfrak{A}$，存在一个在基数 $\le\lambda$ 的初等等价结构 $\mathfrak{B}$。如果 $\mathfrak{A}$ 是无限的，则对于每个 $\kappa\ge\lambda$，存在基数为 $\kappa$ 的初等等价结构 $\mathfrak{B}$。<ul>
<li>例如，代数实数集合在初等等价于 $(\mathbb{R};0,1,+,\cdot)$。</li>
<li>即使 $\mathfrak{A}$ 和 $\mathfrak{B}$ 具有相同的基数，$\mathfrak{B}$ 也不必与 $\mathfrak{A}$ 同构：例如，对于 $(\mathbb{N};0,S,&lt;,+,\cdot)$，存在一个在初等等价的可数结构，但不同构。</li>
</ul>
</li>
<li><strong>Skolem悖论</strong>。对于集合论的公理集 $A_{ST}$，存在一个可数模型 $\mathfrak{G}$。但将$\mathfrak{G}$ 定义为一个断言存在不可数多个集合的句子的模型。<ul>
<li>悖论的解决：在 $\mathfrak{G}$ 内部观察，从 $\mathbb{N}$ 到域 $|\mathfrak{G}|$ 的函数不存在，但这并不意味着 $\mathfrak{G}$ 外部不存在这样的函数。</li>
</ul>
</li>
</ul>
<h2 id="Theories-理论"><a href="#Theories-理论" class="headerlink" title="Theories 理论"></a><strong>Theories 理论</strong></h2><hr>
<p><strong>理论</strong>：</p>
<ul>
<li><strong>理论</strong> $T$是句子集（和语言同级），是一组在逻辑蕴涵下封闭的句子：$T\vDash\sigma\Rightarrow\sigma\in T$。<ul>
<li>结构$\mathfrak{A}$的<strong>理论</strong>，$\text{Th}\mathfrak{A}$，是在$\mathfrak{A}$中<strong>为真的句子集。</strong></li>
<li>一类结构$\mathcal{K}$的<strong>理论</strong>，$\text{Th}\mathcal{K}$，是在$\mathcal{K}$中<strong>每个结构中为真的句子集</strong>。</li>
</ul>
</li>
</ul>
<p>$\mbox{Th}\mathcal{K}$ 是一个理论。</p>
<p><strong>证明step 1:</strong> 如果 $\mbox{Th}\mathcal{K}\vDash\sigma$，那么 $\sigma$ 在 $\mbox{Th}\mathcal{K}$ 的所有模型中都为真，但每个结构 $\mathfrak{A}\in\mbox{Th}\mathcal{K}$ 都是 $\mbox{Th}\mathcal{K}$ 的模型。</p>
<p><strong>证明step 2:</strong> 我们可以将 $\mbox{Th}\mathcal{K}$ 看作 $\cap_{\mathfrak{A}\in\mathcal{K}}\mbox{Th}\mathfrak{A}$。$\mathfrak{A}$ 是 $\mbox{Th}\mathfrak{A}$ 的模型，因此 $\mathfrak{A}$ 也是 $\mbox{Th}\mathcal{K}$ 的模型，因此，如果 $\mbox{Th}\mathcal{K}\vDash\sigma$，那么 $\sigma$ 在 $\mathfrak{A}$ 中为真（对于所有 $\mathfrak{A}\in\mathcal{K}$）。</p>
<p><strong>推论集</strong>：</p>
<ul>
<li>$\mbox{Cn}$ $\Sigma$ $&#x3D; \mbox{Th}\mbox{Mod}\Sigma &#x3D; {\sigma|\Sigma\vDash\sigma}$ , $\Sigma$被称为<strong>推论集</strong></li>
</ul>
<p><strong>理论的完备性</strong>：</p>
<ul>
<li>一个理论 $T$ 是完备的：当且仅当对于每个句子 $\sigma$，要么 $T\vDash\sigma$ 要么 $T\vDash\neg\sigma$，</li>
</ul>
<blockquote>
<p>等价表示：要么 $\sigma\in T$ 要么 $\neg\sigma\in T$，这时 $T$ 被称为<strong>完备</strong>。</p>
</blockquote>
<ul>
<li>对于每个结构 $\mathfrak{A}$，$\mbox{Th}\mathfrak{A}$ 是完备的。</li>
<li>对于每个结构类 $\mathcal{K}$，$\mbox{Th}\mathcal{K}$ 是完备的当且仅当对于每个 $\mathfrak{A},\mathfrak{B}\in\mathcal{K}$，$\mathfrak{A}\equiv\mathfrak{B}$。</li>
<li>如果一个理论 $T$ 是完备的并且可满足的，那么每个严格更大的理论都不可满足，而每个严格更小的理论都不完备。</li>
<li>例子：<ul>
<li><p>域的理论不是完备的：$1+1&#x3D;0$ 在某些域中为真，而在其他域中为假。</p>
</li>
<li><p>特征为0的代数闭域的理论是完备的。</p>
</li>
<li><p>复数域的理论 $(\mathbb{C};0,1,+,\cdot)$ 是完备的。</p>
</li>
</ul>
</li>
</ul>
<p><strong>范畴</strong>：</p>
<ul>
<li><p>一组句子 $\Sigma$ 被称为<strong>范畴</strong>，当且仅当 $\Sigma$ 的任意两个模型是同构的。</p>
</li>
<li><p>一个理论 $T$ 是**$\lambda$-范畴**，当且仅当 $T$ 的所有基数为 $\lambda$ 的无限模型是同构的。</p>
<ul>
<li>根据LST，$\Sigma$ 是1-范畴当且仅当 $\Sigma$ 没有无限模型。</li>
</ul>
</li>
</ul>
<p><strong>公理化</strong>：</p>
<ul>
<li>一个理论 $T$ 是<strong>公理化的</strong>，当且仅当存在一个<strong>可判定</strong>的句子（公理）集 $\Sigma$，使得 $T&#x3D;\mbox{Cn}\Sigma&#x3D;\mbox{Th}\mbox{Mod}\Sigma$。</li>
<li>一个理论 $T$ 是<strong>有限公理化的</strong>，当且仅当存在一个<strong>有限</strong>句子（公理）集 $\Sigma$，使得 $T&#x3D;\mbox{Cn}\Sigma&#x3D;\mbox{Th}\mbox{Mod}\Sigma$。<ul>
<li>跟推论集的定义很像</li>
</ul>
</li>
</ul>
<p>如果 $\mbox{Cn}\Sigma$ 是有限公理化的，则存在 $\Sigma$ 的有限子集 $\Sigma_{0}\subseteq\Sigma$，使得 $\mbox{Cn}\Sigma_{0}&#x3D;\mbox{Cn}\Sigma$。</p>
<ul>
<li>例子（不是数学系的，域还没完全理解…）：<ul>
<li>域的理论是（有限）公理化的：如果 $\Phi$ 是域公理的（有限）集合，则域的类是 $\mbox{Mod}\Phi$，域的理论是 $\mbox{Th}\mbox{Mod}\Phi$。</li>
<li>特征为0的域的理论是公理化的：其公理 $\Phi_{0}$ 由 $\Phi$ 和对于每个 $n$ 都有 $1+\ldots+1_{n}\neq0$ 组成。</li>
<li>特征为0的代数闭域的理论是公理化的：其公理包括 $\Phi_{0}$ 和 $\forall x_{0}\ldots\forall x_{n}x_{n}\neq0\rightarrow\exists xx_{n}\cdot\underbrace{x\cdot\ldots\cdot x}<em>{n}+\ldots+x</em>{1}\cdot x+x_{0}&#x3D;0$</li>
</ul>
</li>
</ul>
<h2 id="Decidability-可判定性-1"><a href="#Decidability-可判定性-1" class="headerlink" title="Decidability 可判定性"></a>Decidability 可判定性</h2><hr>
<ul>
<li>对于<strong>有限语言</strong>，如果 $\mathfrak{A}$ 是<strong>有限的</strong>，则 <strong>$\mbox{Th}\mathfrak{A}$ 是可判定的。</strong></li>
<li>对于<strong>有限语言</strong>，${\sigma|\sigma$ 有一个<strong>有限模型$}$</strong> 是<strong>能行可枚举</strong>的。</li>
</ul>
<p>重新表述可判定性：</p>
<ul>
<li>如果 $\Gamma$ 是<strong>可判定的</strong>，语言是<strong>合理</strong>的，则 $\mbox{Th}\Gamma$ 和 ${\phi|\Gamma\vDash\phi}$ 是<strong>能行可枚举</strong>的。<ul>
<li>合理语言中的<strong>可公理化的理论</strong>是能行可枚举的。<ul>
<li>可公理化理论是可判定的</li>
</ul>
</li>
<li>反之亦然。在合理语言中是能行可枚举的理论是可公理化的。</li>
</ul>
</li>
<li>如果 $\Gamma$ 是<strong>可判定的</strong>，语言是<strong>合理</strong>的 (对于每个句子 $\sigma$，$\Gamma\vDash\sigma$ 或 $\Gamma\vDash\neg\sigma$) ，则 ${\sigma|\Gamma\vDash\sigma}$ 是可判定的。<ul>
<li>合理语言中的<strong>完备的  可公理化的 理论</strong>是可判定的。</li>
</ul>
</li>
<li>例子：<ul>
<li>集合论（如果一致）是不可判定的，因此也不是完备的。</li>
<li>数论是完备的，但是不可判定（甚至不是能行可枚举的），因此也不可公理化。</li>
<li>特征为0的代数闭域的理论是可判定的。<ul>
<li>复数域的理论 $(\mathbb{C};0,1,+,\cdot)$ 是可判定的。</li>
</ul>
</li>
<li>实数域的理论 $(\mathbb{R};0,1,+,\cdot)$ 也是可判定的</li>
<li>无端点的稠密线性序理论是可判定的。</li>
</ul>
</li>
</ul>
<h2 id="Prenex-Normal-Form-前束范式"><a href="#Prenex-Normal-Form-前束范式" class="headerlink" title="Prenex Normal Form 前束范式"></a>Prenex Normal Form 前束范式</h2><hr>
<p><strong>前束范式</strong> 是形式为 $Q_{1}x_{1}\ldots Q_{n}x_{n}\alpha$ 的公式，其中 $Q_{i}\in{\forall,\exists}$，$\alpha$ 是不含量词的公式。</p>
<p><strong>(前束范式定理)</strong> 对于每个合式公式$\phi$，都存在一个逻辑等价的前束范式。</p>
<h1 id="Section-2-7-Theories之间的解释"><a href="#Section-2-7-Theories之间的解释" class="headerlink" title="Section 2.7: Theories之间的解释"></a>Section 2.7: Theories之间的解释</h1><h2 id="符号表示"><a href="#符号表示" class="headerlink" title="符号表示"></a>符号表示</h2><p>对于给定的公式$\varphi$，通过$\varphi(t_{1},…,t_{k})$表示$((\psi_{t_{1}}^{v_{1}})…)<em>{t</em>{k}}^{v_{k}}$，其中$\psi$是$\varphi$的字母变体（参见第2.4节），使得所有$t_{i}$都可以替代$v_{i}$。</p>
<h2 id="语言的解释"><a href="#语言的解释" class="headerlink" title="语言的解释"></a>语言的解释</h2><p>解释是将$L$翻译为$L’$和$T’$的一种方式。我们需要将$L$的每个参数翻译成$L’$的语言，还需要考虑一个特定的理论$T’$，因为我们必须确保，例如，$\forall$的翻译指定一个非空集合，并且函数符号$f$的翻译确实指定了一个函数，即$T’$中存在一个句子，说明我们的翻译确实是一个函数（在$T’$的每个模型中都如此）。</p>
<p>一个**$L$到$T’$的解释$\pi$*<em>是一个函数，它为$L$的每个参数</em>分配一个$L’$的公式$\pi_{*}$，使得以下要求成立（$free(\varphi)$是$\varphi$的自由变量集）：</p>
<ol>
<li>$free(\pi_{\forall}) \subseteq {v_{1}}$，且$T’ \models \exists v_{1}\pi_{\forall}$。</li>
<li>对于$n$元谓词符号$P$，$free(\pi_{P}) \subseteq {v_{1},…,v_{n}}$。</li>
<li>对于$n$元函数符号$f$，$free(\pi_{f}) \subseteq {v_{1},…,v_{n},v_{n+1}}$，且$T’ \models \forall v_{1}…\forall v_{n}(\pi_{\forall} \rightarrow \pi_{\forall}(v_{2}) \rightarrow … \rightarrow \pi_{\forall}(v_{n}) \rightarrow \exists x(\pi_{\forall}(x)\land\forall v_{n+1}(\pi_{f}\leftrightarrow v_{n+1}&#x3D;x)))$。</li>
<li>对于常量符号$c$，$free(\pi_{c}) \subseteq {v_{1}}$，且$T’ \models \exists x(\pi_{\forall}(x)\land\forall v_{1}(\pi_{c}\leftrightarrow v_{1}&#x3D;x))$。</li>
</ol>
<p>其中：</p>
<ul>
<li>1表示对于$T’$的任何模型$B$，$\pi_{\forall}$定义了$|^{π}B|$的非空子集（我们对$L$的解释中的宇宙）和该子集上的所有$L$的参数，即$^{π}B$是$L$的结构，使得对于$L$的每个公式$\varphi$，我们可以验证它是否在$^{π}B$中的一些$s$：$V\to|^{π}B|$上为真。</li>
<li>2表示$\pi_{P}$定义了一个$n$元关系（可以进一步限制到1中定义的宇宙中）。</li>
<li>3表示对于$T’$的任何模型$B$，$\pi_{f}$定义了一个$(n+1)$元关系，使得在1中定义的宇宙中它的限制是一个函数（最后一个元素根据其他所有元素唯一定义）。</li>
<li>4表示$\pi_{c}$定义了一个$L$的常量，它是在1中定义的宇宙中的元素。</li>
</ul>
<h2 id="L-到-T’-解释的正当性"><a href="#L-到-T’-解释的正当性" class="headerlink" title="$L$到$T’$解释的正当性"></a>$L$到$T’$解释的正当性</h2><p>现在我们需要证明任何$L$到$T’$解释的正当性。我们的证明将依赖于两个关键事实：</p>
<ol>
<li>对于$L$的每个$\varphi$，$T’ \models \exists v_{1}…\exists v_{k}\pi_{\forall}(v_{1})\land…\land\pi_{\forall}(v_{k}) \rightarrow \pi_{\forall}(\varphi)$。这是因为$L$的每个$\varphi$都是$L$的参数的组合，这一事实在$\pi_{\forall}$的限制下成立。</li>
<li>对于$L$的每个$\varphi$，$T’ \models \pi_{\forall}(\varphi) \rightarrow \exists v_{1}…\exists v_{k}\pi_{\forall}(v_{1})\land…\land\pi_{\forall}(v_{k})$。这是因为$\pi_{\forall}(\varphi)$是在$L’$中的一个公式，它的参数是$\pi_{\forall}$的限制下的元素，这一事实在$T’$的每个模型下成立。</li>
</ol>
<p>有了这两个事实，我们可以证明对于任何$L$的公式$\phi$，$T’ \models \pi_{\forall}(\phi)$。证明是通过对$\phi$的结构进行归纳的，基本情况是原子公式，归纳步骤涵盖了复合公式，包括$\forall$、$\exists$、$\rightarrow$、$\neg$等。对于每一种情况，我们使用1和2，或者2和1，以及归纳假设，来推导所需的结论。</p>
<h2 id="T’-的强度"><a href="#T’-的强度" class="headerlink" title="$T’$的强度"></a>$T’$的强度</h2><p>最终，我们证明了$T \subseteq \pi^{-1}(T’)$，这意味着$L$中的理论$T$的任何模型都可以被嵌入到$L’$中的理论$T’$的模型中。这意味着$T’$至少与$T$一样强大，如果我们认为$T$是强大的，那么我们也可以认为$T’$是强大的。这种证明方法为我们提供了一种比较不同理论之间强度的方式，通过研究它们之间的解释关系。</p>
<p>跳过可消去部分。</p>
<h1 id="Section-2-8-跳过"><a href="#Section-2-8-跳过" class="headerlink" title="Section 2.8 跳过"></a>Section 2.8 跳过</h1><h1 id="Section-3-1"><a href="#Section-3-1" class="headerlink" title="Section 3.1"></a>Section 3.1</h1><p>我们选择数论(而不选择其他理论，比如群论)进行学习是因为:</p>
<ul>
<li>我们能证明数论的某个子理论是一个不可判定的句子集．</li>
<li>我们也能得到，任何一个可满足的理论如果包含数论(例如，完全数论或者集合论)的这个子理论，那么这个理论一定是不可判定的.</li>
<li>特别地，这样的一个理论不可能既是完全的又是可公理化的.</li>
</ul>
<p>为了证明我们所找到的数论的子理论是不可判定的，我们还将证明这个子理论足以表示数字序列、数字序列与数之间的编码运算以及判定过程等．在最后一部分内容中，我们将利用对角线法证明我们所选择的子理论是不可判定的.</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title>用随机梯度下降来优化人生</title>
    <url>/2023/12/12/%E7%94%A8%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%9D%A5%E4%BC%98%E5%8C%96%E4%BA%BA%E7%94%9F/</url>
    <content><![CDATA[<p>Optimize life</p>
<span id="more"></span>

<h1 id="用随机梯度下降来优化人生"><a href="#用随机梯度下降来优化人生" class="headerlink" title="用随机梯度下降来优化人生"></a>用随机梯度下降来优化人生</h1><blockquote>
<p>转自 <a href="https://space.bilibili.com/1567748478">李沐</a></p>
</blockquote>
<p><strong>要有目标</strong>。你需要有目标。短的也好，长的也好。认真定下的也好，别人那里捡的也好。就跟随机梯度下降需要有个目标函数一样。</p>
<p><strong>目标要大</strong>。不管是人生目标还是目标函数，你最好不要知道最后可以走到哪里。如果你知道，那么你的目标就太简单了，可能是个凸函数。你可以在一开始的时候给自己一些小目标，例如期末考个80分，训练一个线性模型。但接下来得有更大的目标，财富自由也好，100亿参数的变形金刚也好，得足够一颗赛艇。</p>
<p><strong>坚持走</strong>。不管你的目标多复杂，随机梯度下降都是最简单的。每一次你找一个大概还行的方向（梯度），然后迈一步（下降）。两个核心要素是方向和步子的长短。但最重要的是你得一直走下去，能多走几步就多走几步。</p>
<p><strong>痛苦的卷</strong>。每一步里你都在试图改变你自己或者你的模型参数。改变带来痛苦。但没有改变就没有进步。你过得很痛苦不代表在朝着目标走，因为你可能走反了。但过得很舒服那一定在原地踏步。需要时刻跟自己作对。</p>
<p><strong>可以躺平</strong>。你用你内心的激情来迈步子。步子太小走不动，步子太长容易过早消耗掉了激情。周期性的调大调小步长效果挺好。所以你可以时不时休息休息。</p>
<p><strong>四处看看</strong>。每一步走的方向是你对世界的认识。如果你探索的世界不怎么变化，那么要么你的目标太简单，要么你困在你的舒适区了。随机梯度下降的第一个词是随机，就是你需要四处走走，看过很多地方，做些错误的决定，这样你可以在前期迈过一些不是很好的舒适区。</p>
<p><strong>快也是慢</strong>。你没有必要特意去追求找到最好的方向和最合适的步子。你身边当然会有幸运之子，他们每一步都在别人前面。但经验告诉我们，随机梯度下降前期进度太快，后期可能乏力。就是说你过早的找到一个舒适区，忘了世界有多大。所以你不要急，前面徘徊一段时间不是坏事。成名无需太早。</p>
<p><strong>赢在起点</strong>。起点当然重要。如果你在终点附近起步，可以少走很多路。而且终点附近的路都比较平，走着舒服。当你发现别人不如你的时候，看看自己站在哪里。可能你就是运气很好，赢在了起跑线。如果你跟别人在同一起跑线，不见得你能做更好。</p>
<p><strong>很远也能到达</strong>。如果你是在随机起点，那么做好准备前面的路会非常不平坦。越远离终点，越人迹罕见。四处都是悬崖。但随机梯度下降告诉我们，不管起点在哪里，最后得到的解都差不多。当然这个前提是你得一直按照梯度的方向走下去。如果中间梯度炸掉了，那么你随机一个起点，调整步子节奏，重新来。</p>
<p><strong>独一无二</strong>。也许大家有着差不多的目标，在差不多的时间毕业买房结婚生娃。但每一步里，每个人内心中看到的世界都不一样，导致走的路不一样。你如果跑多次随机梯度下降，在各个时间点的目标函数值可能都差不多，但每次的参数千差万别。不会有人关心你每次训练出来的模型里面参数具体是什么值，除了你自己。</p>
<p><strong>简单最好</strong> 。当然有比随机梯度下降更复杂的算法。他们想每一步看想更远更准，想步子迈最大。但如果你的目标很复杂，简单的随机梯度下降反而效果最好。深度学习里大家都用它。关注当前，每次抬头瞄一眼世界，快速做个决定，然后迈一小步。小步快跑。只要你有目标，不要停，就能到达。</p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
  </entry>
  <entry>
    <title>通俗理解网络协议</title>
    <url>/2023/01/05/%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>通俗理解网络协议</p>
<span id="more"></span>



<h2 id="1-五层模型"><a href="#1-五层模型" class="headerlink" title="1.五层模型"></a>1.五层模型</h2><h3 id="1-1-实体层-物理层"><a href="#1-1-实体层-物理层" class="headerlink" title="1.1.实体层(物理层)"></a>1.1.实体层(物理层)</h3><p>把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。</p>
<h3 id="1-2-链接层-数据链路层"><a href="#1-2-链接层-数据链路层" class="headerlink" title="1.2.链接层(数据链路层)"></a>1.2.链接层(数据链路层)</h3><ul>
<li>定义<ul>
<li>单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？</li>
<li>这就是”链接层”的功能，它在”实体层”的上方，确定了0和1的分组方式。</li>
</ul>
</li>
<li>以太网协议<ul>
<li>逐渐地，一种叫做”以太网”（Ethernet）的协议，占据了主导地位。</li>
<li>以太网规定，一组电信号构成一个数据包，叫做**”帧”（Frame）<strong>。每一帧分成两个部分：</strong>标头（Head）和数据（Data）**。</li>
<li>“标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。<ul>
<li>“标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</li>
</ul>
</li>
</ul>
</li>
<li>MAC地址<ul>
<li>以太网规定，连入网络的所有设备，都必须具有”网卡”接口。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。</li>
<li>每块网卡出厂的时候，都有一个<strong>全世界独一无二</strong>的MAC地址，长度是48个二进制位，通常用<strong>12个十六进制数</strong>表示。</li>
</ul>
</li>
<li>广播<ul>
<li>一块网卡怎么会知道另一块网卡的MAC地址？<br> 回答是有一种ARP协议，可以解决这个问题。</li>
<li>就算有了MAC地址，系统怎样才能把数据包准确送到接收方？<br> 回答是以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。这就是<strong>广播</strong>。</li>
</ul>
</li>
</ul>
<h3 id="1-3-网络层"><a href="#1-3-网络层" class="headerlink" title="1.3.网络层"></a>1.3.网络层</h3><p>以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是不合理的，否则互联网上每一台计算机都会收到所有包，那会引起效率灾难。</p>
<p>这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。</p>
<p> 于是，”网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，<strong>MAC地址是绑定在网卡上的，网络地址则是管理员分配的</strong>，它们只是随机组合在一起。</p>
<p> 网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是<strong>先处理网络地址，然后再处理MAC地址。</strong></p>
<ul>
<li><p>IP协议（v4)</p>
<ul>
<li>互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。</li>
<li>怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数”子网掩码”（subnet mask）。所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址</li>
<li>总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</li>
</ul>
</li>
<li><p>IP数据包</p>
<ul>
<li>根据IP协议发送的数据，就叫做IP数据包。我们可以把IP数据包直接放进以太网数据包的”数据”部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。</li>
<li><img src="http://www.52im.net/data/attachment/forum/201811/01/151007ibebhdrudjqof1qp.jpg"><span class="image-caption">网络编程懒人入门(一)：快速理解网络通信协议（上篇）_10.jpg</span></li>
<li>IP数据包的”标头”部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的”数据”部分，最长为65,515字节。前面说过，以太网数据包的”数据”部分，最长只有1500字节。因此，<strong>如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了</strong></li>
</ul>
</li>
<li><p>ARP协议</p>
<ul>
<li><p>因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。 所以，我们需要一种机制，能够从IP地址得到MAC地址。</p>
</li>
<li><p><strong>1）第一种情况：</strong>如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），<strong>让网关去处理</strong>；</p>
<p><strong>2）第二种情况：</strong>如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。<strong>它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，</strong>向对方报告自己的MAC地址，否则就丢弃这个包。</p>
</li>
<li><p><strong>1号电脑把数据包发到网关A，必须知道网关A的MAC地址。所以，数据包的目标地址，实际上分成两种情况：</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>数据包地址</strong></th>
</tr>
</thead>
<tbody><tr>
<td>同一个子网络</td>
<td>对方的MAC地址，对方的IP地址</td>
</tr>
<tr>
<td>非同一个子网络</td>
<td>网关的MAC地址，对方的IP地址</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="1-4-传输层"><a href="#1-4-传输层" class="headerlink" title="1.4.传输层"></a>1.4.传输层</h3><ul>
<li><p>目的</p>
<ul>
<li>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。 接下来的问题是，同一台主机上有许多程序都需要用到网络。</li>
<li>也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。<strong>每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</strong></li>
<li>端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，<strong>用户只能选用大于1023的端口</strong>。不管是浏览网页还是在线聊天，<strong>应用程序会随机选用一个端口</strong>，然后与服务器的相应端口联系。</li>
<li><strong>“传输层”的功能，就是建立”端口到端口”的通信。</strong>相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，<strong>Unix系统就把主机+端口，叫做”套接字”（socket）</strong>。有了它，就可以进行网络应用程序开发了。</li>
</ul>
</li>
<li><p>UDP协议</p>
<ul>
<li>“标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的”数据”部分，而前面说过，IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样：</li>
<li><img src="http://www.52im.net/data/attachment/forum/201811/01/153041d3j4w47j4b3t4ddj.jpg"><span class="image-caption">网络编程懒人入门(二)：快速理解网络通信协议（下篇）_1.jpg</span></li>
<li>“标头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</li>
</ul>
</li>
<li><p>TCP协议</p>
<ul>
<li><strong>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差</strong>，一旦数据包发出，无法知道对方是否收到。为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。因此，TCP协议能够确保数据不会遗失。它的缺点是<strong>过程复杂、实现困难、消耗较多的资源</strong>。 </li>
<li>TCP数据包和UDP数据包一样，都是内嵌在IP数据包的”数据”部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，<strong>通常TCP数据包的长度不会超过IP数据包的长度</strong>，以确保单个TCP数据包不必再分割。</li>
</ul>
</li>
</ul>
<h3 id="1-5应用层"><a href="#1-5应用层" class="headerlink" title="1.5应用层"></a>1.5应用层</h3><h3 id="1-6-用户角度实例"><a href="#1-6-用户角度实例" class="headerlink" title="1.6.用户角度实例"></a>1.6.用户角度实例</h3><p><strong>通常你必须做一些设置。有时，管理员（或者ISP）会告诉你下面四个参数，你把它们填入操作系统，计算机就能连上网了：</strong></p>
<ul>
<li><p>基本设置</p>
<ul>
<li>本机的IP地址；</li>
<li>子网掩码；</li>
<li>网关的IP地址；</li>
<li>DNS的IP地址。</li>
</ul>
</li>
<li><p>如果一台电脑的IP地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用”<strong>动态</strong>IP地址上网”。</p>
<ul>
<li>所谓”动态IP地址”，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做DHCP协议。</li>
</ul>
</li>
<li><p>DHCP协议</p>
<ul>
<li><p>这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做”DHCP服务器”。新的计算机加入网络，必须向”DHCP服务器”发送一个”DHCP请求”数据包，申请IP地址和相关的网络参数。</p>
</li>
<li><p><strong>首先，它是一种应用层协议，建立在UDP协议之上，所以整个数据包是这样的：</strong></p>
<p><img src="http://www.52im.net/data/attachment/forum/201811/01/153032wppxuuvdmupaqiy6.jpg"><span class="image-caption">网络编程懒人入门(二)：快速理解网络通信协议（下篇）_5.jpg</span></p>
<ul>
<li><strong>1）最前面的”以太网标头”：</strong>设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。</li>
<li><strong>2）后面的”IP标头”：</strong>设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。</li>
<li><strong>3）最后的”UDP标头”：</strong>设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。</li>
</ul>
</li>
<li><p>以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的<strong>MAC地址是FF-FF-FF-FF-FF-FF</strong>，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。**当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”**，而其他计算机就可以丢弃这个包。</p>
<p> 接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），<strong>分配给请求端的IP地址和本网络的具体参数则包含在Data部分。</strong></p>
<p> 新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。</p>
</li>
</ul>
</li>
</ul>
<h4 id="访问网页实例"><a href="#访问网页实例" class="headerlink" title="访问网页实例"></a>访问网页实例</h4><p>这个例子经过了简化，它大致上反映了互联网协议的整个通信过程。</p>
<ul>
<li><p>本机参数</p>
<ul>
<li><p>本机的IP地址：192.168.1.100；</p>
<p>子网掩码：255.255.255.0；</p>
<p>网关的IP地址：192.168.1.1；</p>
<p>DNS的IP地址：8.8.8.8。</p>
<p>浏览器要向Google发送一个网页请求的数据包。</p>
</li>
</ul>
</li>
<li><p>DNS协议</p>
<ul>
<li>DNS协议可以帮助我们，将这个网址转换成IP地址。已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包（53端口）。</li>
<li>然后，DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。于是，我们知道了对方的IP地址。</li>
</ul>
</li>
<li><p>子网掩码</p>
<ul>
<li>接下来，我们要判断，这个IP地址是不是在同一个子网络，这就要用到子网掩码。</li>
<li>已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算，结论是，Google与本机不在同一个子网络。</li>
<li>因此，我们要向Google发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。</li>
</ul>
</li>
<li><p>HTTP协议</p>
<ul>
<li><p><img src="http://www.52im.net/data/attachment/forum/201811/01/152959qwuepu61p36qpu5l.jpg"><span class="image-caption">网络编程懒人入门(二)：快速理解网络通信协议（下篇）_8.jpg</span></p>
</li>
<li><p><strong>HTTP部分的内容，类似于下面这样,假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。</strong></p>
<figure class="highlight http"><table><tr><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>[url=http://www.google.com]www.google.com[/url]<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 6.1) ......<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip,deflate,sdch<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.8<br><span class="hljs-attribute">Accept-Charset</span><span class="hljs-punctuation">: </span>GBK,utf-8;q=0.7,*;q=0.3<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>... ...<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>TCP协议</p>
<ul>
<li>TCP数据包需要<strong>设置端口</strong>，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，<strong>总长度变为4980字节</strong>。</li>
</ul>
</li>
<li><p>IP协议</p>
<ul>
<li>然后，TCP数据包再嵌入IP数据包。IP数据包需要<strong>设置双方的IP地址</strong>，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。IP数据包的标头长度为20字节，加上嵌入的TCP数据包，<strong>总长度变为5000字节</strong>。</li>
</ul>
</li>
<li><p>以太网协议</p>
<ul>
<li>最后，IP数据包嵌入以太网数据包。<strong>以太网数据包需要设置双方的MAC地址</strong>，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。</li>
<li>以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为<strong>每个包都有自己的IP标头（20字节）</strong>，所以四个包的IP数据包的长度分别为1500、1500、1500、560。（1480*3+540 &#x3D; 4980）</li>
</ul>
</li>
<li><p>服务器响应</p>
</li>
<li><p>经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的”HTTP请求”，接着<strong>做出”HTTP响应”，</strong>再用TCP协议发回来。</p>
</li>
<li><p>本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。</p>
</li>
</ul>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>侵删</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>NJU-服务端开发-学习笔记</title>
    <url>/2023/12/10/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91-note/</url>
    <content><![CDATA[<p>涉及Spring、Springboot、Spring Cloud、AOP、微服务等后端常用技术栈</p>
<span id="more"></span>



<h1 id="Lecture-1-第一个Spring-boot程序"><a href="#Lecture-1-第一个Spring-boot程序" class="headerlink" title="Lecture 1 第一个Spring boot程序"></a>Lecture 1 第一个Spring boot程序</h1><ul>
<li>git</li>
<li>一个简单的springboot程序<ul>
<li>框架</li>
<li>maven</li>
<li>themyleaf快速构建网页</li>
<li>liveroad热部署</li>
</ul>
</li>
<li>Junit<ul>
<li>(public) void开头</li>
<li>assert</li>
<li><code>StandardOutputStreamLog</code>工具可以收集打到控制台的内容</li>
</ul>
</li>
</ul>
<h1 id="Lecture-2-spring依赖注入"><a href="#Lecture-2-spring依赖注入" class="headerlink" title="Lecture 2 spring依赖注入"></a>Lecture 2 spring依赖注入</h1><p>spring的核心是提供了容器+依赖注入+AOP切面编程</p>
<ul>
<li><p>bean在容器之中</p>
</li>
<li><p>库存Bean注入到商品Bean中（在商品类中，spring帮忙new 库存）</p>
<ul>
<li><p>三种注入方式：</p>
<ul>
<li>类的构造方法</li>
<li>setter方法，set属性</li>
<li>私有属性上加@Autowired</li>
</ul>
</li>
<li><p>不可以通过方法参数注入</p>
</li>
</ul>
</li>
<li><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230914185655677.png"><span class="image-caption">image-20230914185655677</span></p>
</li>
</ul>
<h2 id="三种配置Bean方式"><a href="#三种配置Bean方式" class="headerlink" title="三种配置Bean方式"></a>三种配置Bean方式</h2><ul>
<li><p>顺便配置Bean间的依赖关系</p>
</li>
<li><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230914185947340.png"><span class="image-caption">image-20230914185947340</span></p>
</li>
</ul>
<h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><ul>
<li>方便自定义override</li>
<li>实例化（new）</li>
<li>name：获取名字<ul>
<li>@Override  setBeanName</li>
</ul>
</li>
<li>factory：产生工厂接口</li>
<li>context<ul>
<li>@Override  setApplicationContext以获取Bean信息，在业务逻辑中使用</li>
</ul>
</li>
<li>…</li>
<li>销毁</li>
</ul>
<p>应用上下文</p>
<ul>
<li>建议根据接口编程</li>
</ul>
<h2 id="自动化配置例子（优先）："><a href="#自动化配置例子（优先）：" class="headerlink" title="自动化配置例子（优先）："></a>自动化配置例子（优先）：</h2><ul>
<li>@Component：将Class注册实例化为Bean<ul>
<li>@Component()可以指定Bean的name</li>
</ul>
</li>
<li>@Autowured：注入（对象参数&#x2F;构造器&#x2F;Setter）时需注解。spring从容器上下文寻找实现了接口的对象，并注入当前类（相当于new 子属性）<ul>
<li>若唯一，则返回</li>
<li>若不存在&#x2F;不唯一，则报错</li>
<li>@primary可指定优先注入的类</li>
</ul>
</li>
<li>Object&#x3D;Bean&#x3D;Component(更业务)</li>
<li>@Configuration  总配置类<ul>
<li>上下文可以基于配置类来建立（较为推荐）</li>
<li>@ComponentScan：扫描文件夹中所有的Bean，建立Spring上下文<ul>
<li>等价 &lt;context:component-scan base-package&#x3D;“…”&#x2F;&gt;</li>
<li>基础包（basePackages&#x3D;{“…”,”…”})<ul>
<li>类型不安全：Scan的文件夹目录会变</li>
<li>解决方案：basePackageClasses&#x3D;{.class,.class}建立TagClass标识根文件夹</li>
</ul>
</li>
</ul>
</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230914193437131.png"><span class="image-caption">image-20230914193437131</span></li>
</ul>
</li>
</ul>
<p>JavaConfig例子：</p>
<ul>
<li>不建议把业务代码放入。有可能跳过执行</li>
<li>更适用于改编第三方代码</li>
<li>自动化配置有时会行不通，如：第三方库</li>
<li>@Configuration：配置类</li>
<li>@Bean(name&#x3D;“..”)：提供实例化Bean的逻辑<ul>
<li>Spring的Bean默认使⽤单例模式，只会创建⼀个：在调⽤构造⽅法时会被Spring截获，如果已经new过了就不会再继续new。也可以⼿动指定不⽤Singleton模式（@Scope带参数，可以指定prototype，⽤⼀个创建⼀次</li>
</ul>
</li>
</ul>
<p>xml例子（特殊场景）：</p>
<ul>
<li>构造器注入<ul>
<li><constructor-arg></constructor-arg></li>
<li>c-命名空间</li>
<li>注入字面量值 vase</li>
<li>注入集合</li>
</ul>
</li>
<li>属性注入<ul>
<li>p-命名空间</li>
<li>util-命名空间</li>
</ul>
</li>
<li>ref：引用(用于如list构造、constructor-arg)</li>
<li>value：赋值</li>
</ul>
<p>混合配置类例子：</p>
<ul>
<li><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230914205612870.png"><span class="image-caption">image-20230914205612870</span></p>
</li>
<li><p>@Configuration</p>
<p>@Import(xxx.class)</p>
<p>@ImportResource(“&#x2F;&#x2F;xml path”)</p>
</li>
<li><p>XML中导入</p>
<ul>
<li>&lt;import resource&#x3D;’xml’&#x2F;&gt;</li>
<li></li>
</ul>
</li>
</ul>
<p> —往后考试不考—</p>
<p>Profile选择性配置，类似#ifdef：</p>
<ul>
<li>方法定义：<ul>
<li>@Bean</li>
<li>@Profile(“prov”)</li>
</ul>
</li>
<li>激活<ul>
<li>spring.profiles.default</li>
<li>spring.profiles.active</li>
<li>@ActiveProfiles(“dev”)</li>
</ul>
</li>
</ul>
<p>Conditional条件注入例子：</p>
<ul>
<li><p>@Bean或@Component</p>
</li>
<li><p>@Conditional(**.class)</p>
</li>
<li><p>接口</p>
<ul>
<li><p>Condition{</p>
<p>boolean matches(…)</p>
<p>}</p>
</li>
</ul>
</li>
</ul>
<p>自动装配的歧义：</p>
<ul>
<li>@Primary优先注入</li>
<li>定义时<ul>
<li>@Componet或@Bean</li>
<li>@Qualifier(“…”)自定义限定符</li>
</ul>
</li>
<li>使用时<ul>
<li>@Autowired</li>
<li>@Qualifier(“…”) bean名称或自定义限定符，默认Bean名是限定符</li>
</ul>
</li>
</ul>
<h1 id="Lecture-3-AOP切面编程"><a href="#Lecture-3-AOP切面编程" class="headerlink" title="Lecture 3 AOP切面编程"></a>Lecture 3 AOP切面编程</h1><h2 id="横切关注点（cross-cutting-concern）"><a href="#横切关注点（cross-cutting-concern）" class="headerlink" title="横切关注点（cross-cutting concern）"></a>横切关注点（cross-cutting concern）</h2><ul>
<li>关注共有的可以抽象出来的操作<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230921192144754.png"><span class="image-caption">image-20230921192144754</span></li>
</ul>
</li>
<li>举例：<ul>
<li>日志</li>
<li>安全</li>
<li>事务 </li>
<li>缓存</li>
</ul>
</li>
</ul>
<h2 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h2><ul>
<li>通知（Advice）：切面做什么以及何时做<ul>
<li>what + when</li>
</ul>
</li>
<li>切点（Pointcut）：何处<ul>
<li>具体where</li>
</ul>
</li>
<li>切面（Aspect）：Advice和Pointcut的结合</li>
<li>连接点（Join point）：方法(spring ) | 字段修改、构造方法(其他)<ul>
<li>可以切的地方</li>
</ul>
</li>
<li>引入（introduction）：引入新的行为和状态<ul>
<li>动态给类添加新方法</li>
</ul>
</li>
<li>织入（Weaving）：切面应用到目标对象的过程</li>
</ul>
<h2 id="通知-Advice）类型"><a href="#通知-Advice）类型" class="headerlink" title="通知(Advice）类型"></a>通知(Advice）类型</h2><ul>
<li>@Before 在某连接点之前执行的通知<ul>
<li>“execution(*  包名.接口名.方法名(参数类型) )”</li>
<li>实例化切面Bean,注解</li>
</ul>
</li>
<li>@After</li>
<li>@AfterReturning</li>
<li>@AfterThrowing 出现意外</li>
<li>@Around 环绕通知可以在方法调用前后完成自定义的行为<ul>
<li>相当于前四个的混合，更自由。可以控制返回值</li>
<li>joinPoint.proceed()  调用切面方法</li>
</ul>
</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230921201439967.png"><span class="image-caption">image-20230921201439967</span><ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230921194712381.png"><span class="image-caption">image-20230921194712381</span></li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230921194937329.png"><span class="image-caption">image-20230921194937329</span></li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230921194952447.png"><span class="image-caption">image-20230921194952447</span></li>
</ul>
</li>
<li>原理:Proxy代理<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230921201906728.png"><span class="image-caption">image-20230921201906728</span></li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230921200647533.png"><span class="image-caption">image-20230921200647533</span></li>
</ul>
</li>
</ul>
<h2 id="切点指示器"><a href="#切点指示器" class="headerlink" title="切点指示器"></a>切点指示器</h2><ul>
<li>Pointout法	<ul>
<li>@Pointcut( “execution(* soundsystem.CompactDisc.playTrack( int )) “ + “&amp;&amp; args(trackNumber) &#x2F;&#x2F;获取参数<br>&amp;&amp; within(soundsystem.*) &#x2F;&#x2F;限定包路径<br>&amp;&amp; bean(sgtPeppers) “) &#x2F;&#x2F;限定bean名称，或者： &amp;&amp; !bean(sgtPeppers)</li>
</ul>
</li>
<li>注解法<ul>
<li>@Around(“@annotation(innerAuth)”) &#x2F;&#x2F;限定注解<br>public Object innerAround(ProceedingJoinPoint point, InnerAuth innerAuth) { … }<br>@InnerAuth public R register(@RequestBody SysUser sysUser) { … }</li>
</ul>
</li>
</ul>
<p>多代理类注入</p>
<ul>
<li>增强Bean。在不改变原类的前提下，利用切面新增方法</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230921212102249.png"><span class="image-caption">image-20230921212102249</span></li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230921212516346.png"><span class="image-caption">image-20230921212516346</span></li>
</ul>
<h1 id="Lecture-4-spring-MVC"><a href="#Lecture-4-spring-MVC" class="headerlink" title="Lecture 4 spring MVC"></a>Lecture 4 spring MVC</h1><h2 id="model-view-control"><a href="#model-view-control" class="headerlink" title="model -view-control"></a>model -view-control</h2><ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230930002053524.png"><span class="image-caption">image-20230930002053524</span></li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231007183839364.png" style="zoom:200%;"><span class="image-caption">image-20231007183839364</span>
* 1.必经servlet
* 2.映射路径
* 3.获取参数，映射到controller
* 4.servlet通过controller获取数据与视图
* 5.servlet解析视图</li>
</ul>
<p>类前注解</p>
<ul>
<li><code>@Slf4j</code>：这是Lombok库提供的注解，用于自动生成日志记录器（Logger）。在使用<code>@Slf4j</code>注解后，可以直接使用<code>log</code>字段进行日志记录，而无需手动创建Logger对象。例如，<code>log.info(&quot;Message&quot;)</code>。</li>
<li><code>@Controller</code>：等价于@component。这是Spring框架提供的注解，用于标识一个类作为控制器组件。控制器处理传入的HTTP请求，并返回相应的视图或数据。使用<code>@Controller</code>注解后，Spring会自动识别该类并将其作为控制器进行管理。</li>
<li><code>@RequestMapping(&quot;/design&quot;)</code>：这是Spring MVC框架提供的注解，用于映射HTTP请求到相应的处理方法。在这个例子中，<code>@RequestMapping</code>注解指定了路径为”&#x2F;design”，表示该控制器处理的请求路径为”&#x2F;design”开头的请求。</li>
</ul>
<p>请求映射注解</p>
<ul>
<li>@RequestMapping</li>
<li>@GetMapping </li>
<li>@PostMapping </li>
<li>@PutMapping </li>
<li>@DeleteMapping </li>
<li>@PatchMapping</li>
</ul>
<h2 id="模型数据绑定"><a href="#模型数据绑定" class="headerlink" title="模型数据绑定"></a>模型数据绑定</h2><ul>
<li><p><code>@ModelAttribute</code>：这是 Spring MVC 框架提供的注解，用于将方法参数或方法返回值绑定到模型中。当使用 <code>@ModelAttribute</code> 注解修饰方法时，该方法会在每次请求处理之前被调用，用于准备模型数据。当使用 <code>@ModelAttribute</code> 注解修饰方法参数时，它会从模型中获取对应的属性值，并将其绑定到方法参数中。</p>
<ul>
<li><p>@ModelAttribute标注在方法上时，说明该方法是用于添加一个或多个属性到model上；这样的方法能接收@RequestMapping注解相同的参数类型，只不过不能直接被映射到具体的请求上；</p>
<ul>
<li>当@ModelAttribute注解标注返回值为void的方法时，需要传入Model参数，并使用<code>model.addAttribute()</code>方法手动的往Model上绑定数据。</li>
</ul>
</li>
<li><p>@ModelAttribute标注在方法参数上时，说明该方法参数的值将由model中取得；如果model中找不到，那么该参数会先被实例化，然后被添加到model中；在model中存在以后，请求中所有名称匹配的参数都会填充到该参数中；</p>
</li>
<li><p>这在Spring MVC中被称为数据绑定，一个非常有用的特性，我们不用每次都手动从表格数据中转换这些字段数据；</p>
</li>
</ul>
</li>
<li><p><code>@SessionAttributes</code>：这是 Spring MVC 框架提供的注解，用于指定模型属性的值将存储在会话（Session）中。通过 <code>@SessionAttributes</code> 注解，可以将模型中的指定属性值暂时存储在会话中，以便在多个请求之间共享该属性的值。通常与 <code>@ModelAttribute</code> 注解一起使用，以确保在多个请求之间保持一致的模型属性值</p>
</li>
<li><p>Model属性会复制到Servlet Request属性中，这样视图中就可以使用它们用于渲染页面</p>
<ul>
<li>Servlet Request 是 Java Servlet 规范中定义的一个类，用于表示客户端发起的 HTTP 请求。它包含了请求的各种信息，如请求方法、URL、请求头、请求参数等。通过 Servlet Request，开发人员可以获取并处理客户端发送的请求数据。</li>
<li>servlet是⼀个⼩粒度的运⾏单位<ul>
<li>Tomcat:webserver 是⼀个web容器，可运⾏，⾥⾯装的是servlet（有许多servlet）</li>
<li>servlet处理客户端请求request，返回response</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>SpringMVC获取参数的方式 、Converter </p>
<ul>
<li>Converter 负责将前端传来String格式的表单，转换成Ingredient</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231007184128914.png"><span class="image-caption">image-20231007184128914</span></li>
</ul>
<p>校验</p>
<ul>
<li>领域类上添加校验规则 </li>
<li>控制器中声明校验：@Valid</li>
</ul>
<h2 id="使用视图控制器（View-Controller）"><a href="#使用视图控制器（View-Controller）" class="headerlink" title="使用视图控制器（View Controller）"></a>使用视图控制器（View Controller）</h2><ul>
<li>如果一个控制器非常简单，不需要填充模型或处理输入</li>
<li>继承接口WebMvcConfigurer，用于配置 </li>
<li>简单的从请求URL到视图 registry.addViewController(“&#x2F;“).setViewName(“home”); &#x2F;&#x2F;GET请求</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231001123912054.png"><span class="image-caption">image-20231001123912054</span></li>
</ul>
<p>@data</p>
<ul>
<li>生成setter和getter</li>
<li>Lombok是编译期的东西</li>
</ul>
<h1 id="Lecture-5-数据持久化"><a href="#Lecture-5-数据持久化" class="headerlink" title="Lecture 5 数据持久化"></a>Lecture 5 数据持久化</h1><p>Java数据库连接（Java Database Connectivity，JDBC）和Java持久化API（Java Persistence API，JPA）是两个常用的技术。</p>
<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a><strong>JDBC</strong></h2><p>是Java平台提供的一组API，用于在Java应用程序和各种关系型数据库之间建立连接和执行数据库操作。JDBC允许开发人员使用Java代码来执行诸如查询、插入、更新和删除等数据库操作。它提供了一种标准的方式来访问不同数据库系统，独立于具体的数据库实现。通过JDBC，开发人员可以使用Java语言编写数据库驱动程序，连接到数据库并执行SQL语句。</p>
<ul>
<li><p>JDBC的主要组件包括：</p>
<ul>
<li><p><strong>DriverManager</strong>：用于管理数据库驱动程序的类，负责建立数据库连接。</p>
</li>
<li><p><strong>Connection</strong>：表示与数据库的连接，可以执行SQL语句和事务管理。</p>
</li>
<li><p><strong>Statement</strong>：用于执行SQL语句的接口，包括创建、执行和处理结果等操作。</p>
</li>
<li><p><strong>ResultSet</strong>：表示数据库查询结果集，可以遍历和操作查询结果。</p>
</li>
</ul>
</li>
<li><p>使用JDBC时，开发人员需要手动编写SQL语句、处理连接、事务和结果集等细节。虽然JDBC提供了灵活性和直接控制数据库的能力，但对于大型应用程序或复杂的数据库操作，编写和维护大量的JDBC代码可能变得繁琐和冗长。</p>
</li>
</ul>
<h2 id="JDBC-template"><a href="#JDBC-template" class="headerlink" title="JDBC template"></a>JDBC template</h2><ul>
<li>JdbcTemplate是Spring Framework提供的一个用于简化JDBC（Java Database Connectivity）操作的类库。它封装了JDBC的底层细节，提供了一组简单而强大的方法来执行SQL查询、更新和批处理等操作。</li>
<li>JdbcTemplate简化了JDBC的使用，减少了样板代码的编写，并提供了异常处理和资源管理等功能。它是Spring框架中数据访问对象（DAO）模式的核心组件之一，用于与关系型数据库进行交互。</li>
<li>H2数据库是一个基于Java的嵌入式关系型数据库管理系统（RDBMS）。它提供了一个轻量级、快速、可嵌入的数据库解决方案，适用于开发和测试环境。H2数据库支持标准SQL语法和JDBC API，可以通过内存模式或嵌入式模式在应用程序中嵌入和使用。<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231008142847877.png"><span class="image-caption">image-20231008142847877</span></li>
</ul>
</li>
</ul>
<h3 id="生成TABLE"><a href="#生成TABLE" class="headerlink" title="生成TABLE"></a>生成TABLE</h3><p>如果在应⽤的根类路径下存在名为schema.sql的⽂件，那么在应⽤启动的时候将会基于数据库执⾏这个⽂件中的SQL。所以，我们需要将程序清单3.8中的内容保存为名为schema.sql的⽂件并放到“src&#x2F;main&#x2F;resources”⽂件夹下。</p>
<p>我们可能还希望在数据库中预加载⼀些配料数据。幸运的是，Spring Boot还会在应⽤启动的时候执⾏根类路径下名为data.sql的⽂件。将其保存到“src&#x2F;main&#x2F;resources&#x2F;data.sql”⽂件中。</p>
<ul>
<li>其他方法：</li>
<li>CommandLineRunner</li>
<li>Applycation.run</li>
</ul>
<h3 id="Repository的实现"><a href="#Repository的实现" class="headerlink" title="Repository的实现"></a>Repository的实现</h3><ul>
<li>@Repository</li>
<li>接口: RowMapper<T>，可以使用lambda表达式</T></li>
<li>注入DesignTacoController，使用IngredientByldConverter实现优化</li>
<li>identity字段由数据库自动生成值，获取返回的ID，GeneratedKeyHolder <ul>
<li>PreparedStatementCreatorFactory </li>
<li>PreparedStatementCreator</li>
<li>jdbcOperations.update</li>
</ul>
</li>
</ul>
<h2 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h2><ul>
<li>QLException <ul>
<li>发生异常时很难恢复 ✓ 难确定异常类型</li>
</ul>
</li>
<li>Hibernate异常<ul>
<li>定义了许多具体异常，方便定位问题 ✓ 对业务对象的侵入</li>
</ul>
</li>
<li>Spring所提供的平台无关的持久化异常<ul>
<li>DataAccessException ✓ 具体异常，方便定位问题 ✓ 隔离具体数据库平台</li>
</ul>
</li>
</ul>
<h2 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a><strong>JPA</strong></h2><p>是Java平台的Java持久化规范，提供了一种更高级别的抽象，用于简化Java应用程序与数据库之间的交互。JPA的目标是提供一种对象关系映射（Object-Relational Mapping，ORM）的解决方案，将Java对象与数据库表之间进行映射。</p>
<ul>
<li><p>JPA的核心概念包括：</p>
<ul>
<li><p><strong>实体类</strong>（Entity）：用于表示数据库中的表，通过注解或XML配置与数据库表进行映射。</p>
</li>
<li><p><strong>EntityManager</strong>：类似于JDBC中的Connection，用于管理实体对象的生命周期、执行数据库操作以及处理事务。</p>
</li>
<li><p><strong>JPQL</strong>（Java Persistence Query Language）：类似于SQL的查询语言，用于查询和操作实体对象。</p>
</li>
</ul>
</li>
<li><p>JPA提供了一种面向对象的编程模型，将数据库操作转化为对Java对象的操作，避免了直接编写SQL语句和处理数据库连接的繁琐工作。它还提供了缓存、延迟加载、事务管理等高级特性，简化了开发过程并提高了应用程序的可维护性。</p>
</li>
<li><p>JPA是一个规范，不是具体的实现。常见的JPA实现包括Hibernate、EclipseLink、OpenJPA等。开发人员可以根据具体需求选择适合的JPA实现来与数据库进行交互，并使用JPA提供的API进行开发。</p>
</li>
</ul>
<p>综上所述，JDBC是一种低级别的数据库访问API，提供了直接的数据库连接和操作能力，而JPA是一种高级别的ORM规范，提供了更简化和面向对象的数据库访问方式。在选择使用JDBC还是JPA时，需要根据具体的应用场景和需求来决定。</p>
<h3 id="生成TABLE-1"><a href="#生成TABLE-1" class="headerlink" title="生成TABLE"></a>生成TABLE</h3><ul>
<li>@Entity</li>
<li>@Table(name&#x3D;”Taco_Order”)</li>
<li>@OneToMany<ul>
<li>生成关联表</li>
</ul>
</li>
<li>@NoArgsConstructor注解。JPA需要实体有⼀个⽆参的构造器.</li>
</ul>
<h3 id="repository查询方法"><a href="#repository查询方法" class="headerlink" title="repository查询方法"></a>repository查询方法</h3><p>继承CRUD</p>
<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231008164713521.png"><span class="image-caption">image-20231008164713521</span></li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231008164834610.png"><span class="image-caption">image-20231008164834610</span></li>
</ul>
<p>定义查询方法，无需实现</p>
<ul>
<li>领域特定语言(domain-specific language，DSL)，spring data的命名约定</li>
<li>查询动词＋主题＋断言</li>
<li>查询动词: get、read、find、count</li>
<li>例子:<br>List<TacoOrder> findByDeliveryZip( String deliveryZip );</TacoOrder></li>
</ul>
<p>声明自定义查询</p>
<ul>
<li><p>不符合方法命名约定时，或者命名太长时</p>
</li>
<li><p>@Query(“Order o where o.deliveryCity &#x3D; ‘Seattle”)</p>
<p>List<TacoOrder> readOrdersDeliveredInSeattle( );</TacoOrder></p>
</li>
</ul>
<h3 id="两个好处"><a href="#两个好处" class="headerlink" title="两个好处"></a>两个好处</h3><ul>
<li>便于做mock测试</li>
<li>更改时只需更改Repository</li>
</ul>
<h1 id="Lecture-6-非关系数据库"><a href="#Lecture-6-非关系数据库" class="headerlink" title="Lecture 6 非关系数据库"></a>Lecture 6 非关系数据库</h1><h2 id="MongeDB"><a href="#MongeDB" class="headerlink" title="MongeDB"></a>MongeDB</h2><ul>
<li>分布式</li>
<li>类json格式</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231012185636855.png"><span class="image-caption">image-20231012185636855</span></li>
</ul>
<ol>
<li>基本的CRUD操作：<ul>
<li>创建数据库：使用<code>use &lt;database_name&gt;</code>命令创建一个新的数据库。</li>
<li>创建集合：使用<code>db.createCollection(&quot;&lt;collection_name&gt;&quot;)</code>命令创建一个新的集合。</li>
<li>插入文档：使用<code>db.&lt;collection_name&gt;.insertOne(&lt;document&gt;)</code>命令插入一个文档到指定集合。</li>
<li>查询文档：使用<code>db.&lt;collection_name&gt;.find(&lt;query&gt;)</code>命令查询符合条件的文档。</li>
<li>更新文档：使用<code>db.&lt;collection_name&gt;.updateOne(&lt;filter&gt;, &lt;update&gt;)</code>命令更新符合条件的文档。</li>
<li>删除文档：使用<code>db.&lt;collection_name&gt;.deleteOne(&lt;filter&gt;)</code>命令删除符合条件的文档。</li>
</ul>
</li>
<li>高级查询和操作：<ul>
<li>使用查询运算符和条件语句来执行更复杂的查询操作。</li>
<li>学习索引的创建和使用，以提高查询性能。</li>
<li>学习如何使用聚合管道进行数据聚合和数据处理操作。</li>
<li>学习MongoDB的数据备份和恢复方法，以及复制和分片等高可用性和扩展性特性。</li>
</ul>
</li>
</ol>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ul>
<li><p>Key-value的Hash表结构</p>
</li>
<li><p>存在内存，速度快。也可以持久化</p>
</li>
<li><p>主要作缓存。低延迟</p>
</li>
<li><p>常用作集群，有主从复制</p>
</li>
</ul>
<ol>
<li>Redis的基本操作：<ul>
<li>设置键值对：使用<code>SET</code>命令设置一个键值对。</li>
<li>获取值：使用<code>GET</code>命令获取一个键对应的值。</li>
<li>存储列表：使用<code>LPUSH</code>和<code>RPUSH</code>命令将值添加到列表的左侧或右侧。</li>
<li>存储哈希：使用<code>HSET</code>命令将字段和值添加到哈希中。</li>
<li>存储集合：使用<code>SADD</code>命令将值添加到集合中。</li>
<li>存储有序集合：使用<code>ZADD</code>命令将带有分数的成员添加到有序集合中。</li>
</ul>
</li>
<li>Redis的高级功能：<ul>
<li>使用过期时间：设置键的过期时间，让Redis自动删除过期的键。</li>
<li>发布和订阅：使用<code>PUBLISH</code>命令发布消息，使用<code>SUBSCRIBE</code>命令订阅消息。</li>
<li>事务：使用<code>MULTI</code>和<code>EXEC</code>命令执行一系列命令作为一个事务。</li>
<li>Lua脚本：使用Redis的Lua脚本功能执行复杂的操作。</li>
<li>持久化：了解Redis的持久化机制，将数据保存到磁盘上。</li>
</ul>
</li>
</ol>
<ul>
<li><p>链接java</p>
<ul>
<li><p>新增键值对</p>
<ul>
<li><pre><code>redis.opsForValue().set(product.getSku(), product);
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><br>    <br><br>* 新增<span class="hljs-built_in">set</span><br><br>  * ```<br>    redisTemplate.opsForSet().<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;cart&quot;</span>, product);<br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>序列化是必须的</p>
<ul>
<li><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231012205511018.png"><span class="image-caption">image-20231012205511018</span></p>
</li>
<li><pre><code class="java">redis.setKeySerializer(new StringRedisSerializer());
redis.setValueSerializer(new Jackson2JsonRedisSerializer&lt;Product&gt;(Product.class));
redis.afterPropertiesSet(); // if this were declared as a bean, you wouldn&#39;t have to do this
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-section"># Lecture 7 Spring Securety</span><br><br><span class="hljs-section">## cookie</span><br><br><span class="hljs-bullet">*</span> HTTP 协议是一种用于在客户端和服务器之间传输超文本的协议。它是无状态的，这意味着每个请求都是独立的，服务器不会记住之前的请求。然而，有时候需要在多个请求之间保持一些状态信息，这就是 Cookie 的作用。<br><span class="hljs-bullet">*</span> 当服务器发送 HTTP 响应时，它可以在响应头中包含一个 Set-Cookie 标头，其中包含了一个或多个键值对，用于设置 Cookie 的属性，如名称、值、过期时间、域名、路径等。客户端（通常是Web浏览器）在接收到这个响应时会将这些 Cookie 保存在本地。<br><span class="hljs-bullet">*</span> 之后，当客户端发送新的 HTTP 请求时，它会在请求头中包含一个 Cookie 标头，其中包含了保存的 Cookie 信息。服务器可以读取这些 Cookie，识别客户端，并根据需要采取相应的操作。例如，服务器可以使用 Cookie 来跟踪用户的会话、存储用户的首选项、实现购物车功能，判断客户端是否登录。<br><br><span class="hljs-section">## Basic 认证</span><br><br>在 HTTP 协议中，Basic 认证是一种简单的身份验证机制。它通过在 HTTP 请求的头部添加一个名为 &quot;Authorization&quot; 的字段，将用户名和密码以 Base64 编码的形式发送给服务器来进行身份验证。<br><br>Basic 认证的工作流程如下：<br><br><span class="hljs-bullet">1.</span> 客户端发送 HTTP 请求到服务器，并在请求头部添加 &quot;Authorization&quot; 字段。<br><span class="hljs-bullet">2.</span> &quot;Authorization&quot; 字段的值为 &quot;Basic&quot; 加上用户名和密码的 Base64 编码。格式为：<span class="hljs-code">`Basic &lt;base64encoded(username:password)&gt;`</span>。<br><span class="hljs-bullet">3.</span> 服务器接收到请求后，检查 &quot;Authorization&quot; 字段的值。<br><span class="hljs-bullet">4.</span> 服务器将 &quot;Authorization&quot; 字段的值进行解码，并获取用户名和密码。<br><span class="hljs-bullet">5.</span> 服务器使用解码后的用户名和密码进行验证，通常是比对存储在服务器上的用户凭据。<br><span class="hljs-bullet">6.</span> 如果验证成功，服务器返回请求的资源；如果验证失败，服务器返回 HTTP 401 Unauthorized 响应。<br><br><span class="hljs-section">## Securety</span><br><br>用户需要做的：![<span class="hljs-string">image-20231026184904538</span>](<span class="hljs-link">https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231026184904538.png</span>)<br><br><span class="hljs-bullet">1.</span> 继承UserDetailsService，自定义User类<br><span class="hljs-bullet">2.</span> 实现登录视图<br><span class="hljs-bullet">3.</span> 实现FilterChain，配置合法用户<br><span class="hljs-bullet">   1.</span> <span class="hljs-code">`FilterChain`</span> 是 Spring Security 中的过滤器链，用于处理请求的安全过滤器。每个请求都会经过一系列的过滤器，用于验证身份、授权访问等操作。过滤器链由多个过滤器组成，并按照一定的顺序依次执行。<br><span class="hljs-bullet">   2.</span> 身份验证：过滤器链中的某些过滤器负责身份验证，检查请求中的身份凭证（如用户名和密码、令牌等），并将其与预先配置的用户信息进行比对，以确定请求是否来自有效的身份。<br><span class="hljs-bullet">   3.</span> 访问控制：过滤器链中的其他过滤器负责访问控制，根据配置的规则和权限信息，判断请求是否有权限访问特定的资源。根据规则的配置，可以允许或拒绝请求的访问。<br><span class="hljs-bullet">   4.</span> 处理安全相关的操作：过滤器链还可以处理一些安全相关的操作，如跨站请求伪造（CSRF）防护、XSS（跨站脚本攻击）防护、会话管理等。<br><span class="hljs-bullet">4.</span> 继承WebSecurityConfigureAdapter<br><span class="hljs-bullet">   1.</span> 重写其中的方法，可以定义安全规则、身份验证方式、访问控制等安全相关的配置。<br><span class="hljs-bullet">   2.</span> 提供了默认的安全配置：<span class="hljs-code">`WebSecurityConfigurerAdapter`</span> 类提供了一组默认的安全配置，包括关闭跨站请求伪造（CSRF）防护、启用 HTTP Basic 认证、配置默认登录页面等。通过继承并重写需要修改的方法，可以对默认配置进行定制。<br><span class="hljs-bullet">   3.</span> 配置安全策略：通过重写 <span class="hljs-code">`configure()`</span> 方法，可以添加自定义的安全规则。例如，可以配置哪些 URL 需要进行身份验证、使用哪种身份验证方式、定义访问规则等。这些配置可以基于角色、权限或其他条件来限制用户的访问权限。<br><span class="hljs-bullet">   4.</span> 定义认证方式：通过重写 <span class="hljs-code">`configure(AuthenticationManagerBuilder)`</span> 方法，可以指定身份验证方式。可以使用内存中的用户、数据库中的用户、LDAP、OAuth 等多种方式进行身份验证。<br><br>框架做的：<br><br>1、实现用户登录控制器(get、post)|<br>2、请求重定向到用户登录页面<br>3、通过Filter对设定的权限进行控制权限不通过报以下错误:<br><br><span class="hljs-section">### 自动配置</span><br><br>Spring Securety加入pom.xml后，会有HTTP basic认证对话框并提示你认证。<br><br>要想通过这个认证，你需要⼀个⽤户名和密码。⽤户名为user，⽽密码则是随机⽣成的，它会被写⼊应⽤的⽇志⽂件中。⽇志条⽬⼤致如下<br><br><span class="hljs-bullet">*</span> <span class="hljs-code">```sql</span><br><span class="hljs-code">  Using default security password: 087cfc6a-027d-44bc-95d7-cbb3a798a1ea</span><br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>通过将security starter添加到项目的构建文件中，我们得到了如下的自动配置的安全特性∶</p>
<ul>
<li>所有的HTTP请求路径都需要认证;</li>
<li>不需要特定的角色和权限,</li>
<li>没有登录页面，认证过程是通过HTTP basic认证对话框实现的;</li>
<li>系统只有一个用户，用户名为user</li>
</ul>
<p>为了满足Taco Cloud的安全需求，我们需要编写一些显式的配置，覆盖掉自动配置为我们提供的功能。我们首先配置一个合适的用户存储，这样就能有多个用户了。</p>
<ul>
<li>基于内存的用户存储;</li>
<li>基于JDBC的用户存储﹔</li>
<li>以LDAP作为后端的用户存储﹔</li>
<li>自定义用户详情服务。</li>
</ul>
<p>不管使用哪种用户存储，你都可以通过覆盖<br>WebSecurityConfigurerAdapter基础配置类中定义的configure()方法来进行配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span><br> <span class="hljs-keyword">throws</span> Exception &#123;<br> auth<br> .jdbcAuthentication()<br> .dataSource(dataSource)<br> .usersByUsernameQuery(<br> <span class="hljs-string">&quot;select username, password, enabled from Users &quot;</span> +<br> <span class="hljs-string">&quot;where username=?&quot;</span>)<br> .authoritiesByUsernameQuery(<br> <span class="hljs-string">&quot;select username, authority from UserAuthorities &quot;</span> +<br> <span class="hljs-string">&quot;where username=?&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="web请求保护"><a href="#web请求保护" class="headerlink" title="web请求保护"></a>web请求保护</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> SecurityFilterChain <span class="hljs-title function_">filterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-keyword">return</span> http<br>.authorizeRequests()<br>.antMatchers(<span class="hljs-string">&quot;/design&quot;</span>, <span class="hljs-string">&quot;/orders&quot;</span>).hasRole(<span class="hljs-string">&quot;USER&quot;</span>)<br>.antMatchers(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;/**&quot;</span>).permitAll()<br>.and()<br>.build();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>方法级别保护</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 我们可以直接在 deleteAllOrders() 方法上应用安全性配置，如下所示：</span><br>`<span class="hljs-meta">@PreAuthorize</span>` (<span class="hljs-string">&quot;hasRole(&#x27;ADMIN&#x27;)&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteAllOrders</span><span class="hljs-params">()</span> &#123;<br>orderRepository.deleteAll();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>为了使 @PreAuthorize 工作，您需要启用全局方法安全。为此，您需要使用 @EnableGlobalMethodSecurity注解安全配置类.</p>
<h3 id="阻止CSRF攻击"><a href="#阻止CSRF攻击" class="headerlink" title="阻止CSRF攻击"></a>阻止CSRF攻击</h3><p>跨站请求伪造（CSRF）是一种常见的安全攻击。它涉及到让用户在一个恶意设计的 web 页面上编写代码，这个页面会自动（通常是秘密地）代表经常遭受攻击的用户向另一个应用程序提交一个表单。例如，在攻击者的网站上，可能会向用户显示一个表单，该表单会自动向用户银行网站上的一个 URL 发送消息（该网站的设计可能很糟糕，很容易受到这种攻击），以转移资金。用户甚至可能不知道攻击发生了，直到他们注意到他们的帐户中少了钱。</p>
<p>为了防止此类攻击，应用程序可以在显示表单时生成 CSRF token，将该 token 放在隐藏字段中，然后将其存储在服务器上供以后使用。提交表单时，token 将与其他表单数据一起发送回服务器。然后服务器拦截请求，并与最初生成的 token 进行比较。如果 token 匹配，则允许继续执行请求。否则，表单一定是由一个不知道服务器生成的 token的恶意网站呈现的。</p>
<h3 id="获取用户信息"><a href="#获取用户信息" class="headerlink" title="获取用户信息"></a>获取用户信息</h3><p>然而，也许最干净的解决方案是简单地接受 processOrder() 中的用户对象，但是使用@AuthenticationPrincipal 对其进行注解，以便它成为身份验证的主体：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">processOrder</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> TacoOrder order, Errors errors,</span><br><span class="hljs-params">SessionStatus sessionStatus,</span><br><span class="hljs-params"><span class="hljs-meta">@AuthenticationPrincipal</span> User user)</span> &#123;<br><span class="hljs-keyword">if</span> (errors.hasErrors()) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;orderForm&quot;</span>;<br>&#125;<br>order.setUser(user);<br>orderRepo.save(order);<br>sessionStatus.setComplete();<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>@AuthenticationPrincipal 的优点在于它不需要强制转换（与身份验证一样），并且将特定于安全性的代码限制为注释本身。当在 processOrder() 中获得 User 对象时，它已经准备好被使用并分配给订单了。</p>
<p>三种方式</p>
<ol>
<li>DesignTacoController<br>参数: Principal principal<br>String username &#x3D; principal.getName();</li>
<li>OrderController<br>  @AuthenticationPrincipal User user</li>
<li>安全上下文获取<br>Authentication authentication &#x3D; SecurityContextHolder.getContext(getAuthentication();<br>User user &#x3D; (User) authentication.getPrincipal();</li>
</ol>
<h1 id="Lecture-8-属性配置"><a href="#Lecture-8-属性配置" class="headerlink" title="Lecture 8  属性配置"></a>Lecture 8  属性配置</h1><h2 id="属性使用方法"><a href="#属性使用方法" class="headerlink" title="属性使用方法"></a>属性使用方法</h2><p>四种属性来源（ property source)</p>
<ul>
<li>application.properties、application.yml: server.port &#x3D; 8090</li>
<li>命令行参数（ commandLineArgs ) : java -jar taco-cloud-sd-jdbc-0.0.3-SNAPSHOT.jar <strong>–server.port&#x3D;8081</strong></li>
<li>JVM系统属性: java <strong>-Dserver.port&#x3D;8091</strong> -jar taco-cloud-sd-jdbc-0.0.3-SNAPSHOT.jar</li>
<li>操作系统环境变量：<strong>set SERVER_PORT&#x3D;8082</strong>、java -jar taco-cloud-sd-jdbc-0.0.3-SNAPSHOT.jar</li>
</ul>
<h2 id="Https（考试略"><a href="#Https（考试略" class="headerlink" title="Https（考试略"></a>Https（考试略</h2><ul>
<li>HTTPS (Secure Hypertext Transfer Protocol)安全超文本传输协议，是一个安全通信通道，它基于HTTP开发用于在客户计算机和服务器之间交换信息。它使<strong>用安全套接字层(SSL)进行信息交换</strong>，简单来说它是HTTP的安全版,是使用TLS&#x2F;SSL加密的HTTP协议。HTTP协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议TLS&#x2F;SSL具有<strong>身份验证、信息加密和完整性校验</strong>的功能，可以避免此类问题发生。<ul>
<li>SSL(Secure Sockets Layer安全套接字协议)，及其继任者传输层安全(Transport Layer Security ,TLS)是<strong>为网络通信提供安全及数据完整性</strong>的一种安全协议。TLS与SSL在传输层与应用层之间对网络连接进行加密。</li>
</ul>
</li>
</ul>
<h2 id="单双向验证（考试略"><a href="#单双向验证（考试略" class="headerlink" title="单双向验证（考试略"></a>单双向验证（考试略</h2><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231026200525305.png"><span class="image-caption">image-20231026200525305</span></p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231026200936146.png"><span class="image-caption">image-20231026200936146</span></p>
<h2 id="秘钥配置（考试略"><a href="#秘钥配置（考试略" class="headerlink" title="秘钥配置（考试略"></a>秘钥配置（考试略</h2><p>生成密钥库</p>
<ul>
<li>keytool -genkey -alias tomcat -keyalg RSA -storetype PKCS12 -storepass letmein -keystore  mykeys.p12</li>
<li>密钥库类型: PKCS12</li>
<li><img src="/C:/Users/lar/AppData/Roaming/Typora/typora-user-images/image-20231026205420773.png"><span class="image-caption">image-20231026205420773</span></li>
</ul>
<p>查看密钥库</p>
<ul>
<li>keytool -list -keystore mykeys.p12 -storepass letmein</li>
</ul>
<p>keytool基本使用</p>
<ul>
<li>生成key和库<br>keytool -genkey -v -alias key别名-keyalg RSA -storetype PKCS12 -keystore库文件名.p12</li>
<li>导出证书<br>keytool -keystore库文件名.p12-export -alias key别名-file证书文件名.cer</li>
<li>打印证书信息<br>keytool -printcert -file证书文件名.cer</li>
<li>导入证书到库<br>keytool -import -v -file证书文件名.cer -keystore库文件名.p12</li>
</ul>
<h2 id="SSL配置（考试略"><a href="#SSL配置（考试略" class="headerlink" title="SSL配置（考试略"></a>SSL配置（考试略</h2><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231026214759577.png"><span class="image-caption">image-20231026214759577</span>启用 SSL（Secure Sockets Layer)协议来加密和保护应用程序的通信。下面是对配置中各个属性的解释：</p>
<ul>
<li><code>server.port: 8443</code>: 指定应用程序的端口号为 8443。这是应用程序监听的 HTTPS 连接的端口号。</li>
<li><code>ssl.key-store: classpath:mykeys.p12</code>: 指定使用的密钥库文件的路径和名称。<code>classpath:</code> 前缀表示从类路径中加载密钥库文件，即在应用程序的资源目录下。</li>
<li><code>ssl.key-store-password: letmein</code>: 指定密钥库的密码，用于访问密钥库文件的内容和密钥对。</li>
<li><code>ssl.key-password: letmein</code>: 指定密钥的密码，用于访问密钥库中的具体密钥。</li>
</ul>
<p>这些配置项用于配置应用程序在 HTTPS 模式下监听的端口号、使用的密钥库文件及其密码。通过配置 SSL，应用程序能够使用 HTTPS 协议进行安全的加密通信。</p>
<p>在实际部署中，应根据实际情况配置真实的证书和密钥库，以确保安全性。</p>
<h2 id="配置日志"><a href="#配置日志" class="headerlink" title="配置日志"></a>配置日志</h2><p> Spring Boot默认使用Logback，日志配置文件logback.xml</p>
<ul>
<li>默认日志级别:INFO</li>
<li>分级别、分包目录日志配置(application.yml)<ul>
<li>logging:<br>  level:<br>root: WARN<br>org:<br>  Springframework:<br>    security: DEBUG</li>
<li>以上配置的含义是设置根日志级别为 <code>WARN</code>，意味着只有警告级别及以上的日志会被输出。同时，对于包名为 <code>org.springframework.security</code> 下的所有类，将其日志级别设置为 <code>DEBUG</code>，即会输出该包下的所有调试级别的日志信息。</li>
</ul>
</li>
</ul>
<h2 id="自定义配置属性"><a href="#自定义配置属性" class="headerlink" title="自定义配置属性"></a>自定义配置属性</h2><ul>
<li>ConfigurationProperties(prefix&#x3D; “taco.orders”)</li>
<li>@Validated</li>
</ul>
<p>通过application.yml文件提供值</p>
<ul>
<li>环境变量: taco _orders _pageSize&#x3D;12</li>
<li>程序参数: –taco.orders.pageSize&#x3D;13</li>
<li>访问:<a href="http://localhost:8080/orders%E9%AA%8C%E8%AF%81">http://localhost:8080/orders验证</a></li>
</ul>
<h2 id="激活不同配置-Spring-profile"><a href="#激活不同配置-Spring-profile" class="headerlink" title="激活不同配置 Spring profile"></a>激活不同配置 Spring profile</h2><ul>
<li><p>定义特定profile的属性，通过使用不同的YAML或属性文件</p>
<ul>
<li><p>application-{profile名}.properties</p>
</li>
<li><p>application-{profile名}.yml</p>
</li>
</ul>
</li>
<li><p>也可以将不同profile属性放到同一个YAML文件中，使用3个短线进行分隔，并且使用spring.profiles属性来命名profile</p>
</li>
</ul>
<p>激活的三种方式</p>
<ul>
<li>环境变量: spring_profiles_active&#x3D;prod</li>
<li>命令行参数: java -jar ***.jar –spring.profiles.active&#x3D;prod</li>
<li>JVM系统属性: java -Dspring.profiles.active&#x3D;prod -jar ****.jar</li>
<li>使用注解@Profile(!prod)条件化地创建Bean，可以加到@Configuration或@Bean上</li>
</ul>
<h2 id="Actuator"><a href="#Actuator" class="headerlink" title="Actuator"></a>Actuator</h2><p>Spring Boot Actuator是Spring Boot提供的一个功能强大的模块，用于监控和管理Spring Boot应用程序。它提供了一组内置的RESTful端点（endpoints），可以用于获取关于应用程序运行时的各种信息，例如健康状况、度量指标、配置属性、日志记录等。</p>
<ul>
<li>Spring Boot Actuator的主要目标是帮助开发人员和运维人员更好地理解和管理应用程序的运行状态和行为，以便监测和调试应用程序，进行性能优化和故障排查。</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231102185612299.png"><span class="image-caption">image-20231102185612299</span></li>
</ul>
<p>下面是一些Spring Boot Actuator提供的常用端点：</p>
<ol>
<li><code>/health</code>：用于检查应用程序的健康状况，包括是否存活和是否就绪。</li>
<li><code>/info</code>：提供关于应用程序的基本信息，例如应用程序的名称、版本等。</li>
<li><code>/metrics</code>：用于获取应用程序的度量指标，例如内存使用情况、HTTP请求计数等。</li>
<li><code>/env</code>：获取应用程序的配置属性和环境变量。</li>
<li><code>/loggers</code>：用于管理和配置日志记录器，包括查看日志级别、修改日志级别等。</li>
<li><code>/trace</code>：提供最近的HTTP请求追踪信息，包括请求路径、处理时间等。</li>
</ol>
<h1 id="Lecture-9-RESTful-API"><a href="#Lecture-9-RESTful-API" class="headerlink" title="Lecture 9 RESTful API"></a>Lecture 9 RESTful API</h1><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231102191853434.png"><span class="image-caption">image-20231102191853434</span></p>
<h2 id="K8s"><a href="#K8s" class="headerlink" title="K8s"></a>K8s</h2><p>部署多个pod</p>
<h2 id="REST原则（重要"><a href="#REST原则（重要" class="headerlink" title="REST原则（重要"></a>REST原则（重要</h2><ul>
<li>REST：Representational State Transfer：表现层状态转移 </li>
<li>表现层（Representation）：json、xml、html、pdf、excel </li>
<li>状态转移（State Transfer）：服务端–客户端</li>
</ul>
<p>资源（Resources），就是网络上的一个实体</p>
<ul>
<li><p>标识：URI </p>
</li>
<li><p>HTTP协议的四个操作方式的动词：GET、POST、PUT、DELETE </p>
<ul>
<li>CRUD：Create、Read、Update、Delete</li>
<li>不需要再在url体现增删改查</li>
</ul>
</li>
<li><p>如果一个架构符合REST原则，就称它为<strong>RESTful架构</strong></p>
</li>
</ul>
<h2 id="前端vue"><a href="#前端vue" class="headerlink" title="前端vue"></a>前端vue</h2><p>vue作为桥梁的作用</p>
<ul>
<li><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231102191932611.png"><span class="image-caption">image-20231102191932611</span></p>
</li>
<li><p>Vue所关注的核心是MVC模式中的视图层，同时， 它也能方便地获取数据更新，并通过组件内部特定的方法实现视图与模型的交互</p>
</li>
</ul>
<h3 id="MVVM模型"><a href="#MVVM模型" class="headerlink" title="MVVM模型"></a>MVVM模型</h3><p>单文件组件</p>
<ul>
<li>模板、逻辑和样式在一个组件里，组件更加内聚且更可维护</li>
<li>组件是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用</li>
</ul>
<p>MVVM</p>
<ul>
<li>一种用于构建用户界面的软件架构模式，它将应用程序的逻辑和界面进行分离，使代码更易于维护和测试。</li>
</ul>
<p>下面是对 Vue.js 中 MVVM 架构模式的各个组成部分的介绍：</p>
<ol>
<li>Model（模型）：<br>模型代表应用程序的数据和业务逻辑。在 Vue.js 中，模型通常是由 JavaScript 对象或数组表示，包含应用程序的数据和状态。</li>
<li>View（视图）：<br>视图是用户界面的呈现层，它由 HTML 模板表示。在 Vue.js 中，视图通常是使用 Vue 的模板语法编写的，通过绑定数据和指令来实现动态渲染。</li>
<li>ViewModel（视图模型）：<br>视图模型是连接视图和模型的桥梁。它是一个 JavaScript 对象，在 Vue.js 中由 Vue 实例表示。视图模型负责管理视图和模型之间的数据绑定和交互逻辑。它<strong>通过双向数据绑定将视图的变化反映到模型，并将模型的变化反映到视图。</strong></li>
</ol>
<p>在 Vue.js 中，视图模型通过定义数据属性和计算属性来表示模型，并使用指令和事件绑定等特性来处理用户输入和响应用户操作。视图模型还<strong>提供了一些生命周期钩子函数，用于处理视图的初始化、更新和销毁过程</strong>。</p>
<p>通过 MVVM 架构模式，Vue.js <strong>实现了数据驱动的视图，即当模型的状态改变时，视图会自动更新，而无需手动操作 DOM</strong>。这使得开发人员可以更专注于处理业务逻辑和数据处理，而无需过多关注界面的变化和更新。</p>
<h2 id="REST-API"><a href="#REST-API" class="headerlink" title="REST API"></a>REST API</h2><p>重要理解</p>
<ul>
<li>对资源（url）的操作</li>
<li>以面向数据的格式返回：JSON或XML</li>
</ul>
<h3 id="一些注解"><a href="#一些注解" class="headerlink" title="一些注解"></a>一些注解</h3><ol>
<li><code>@RequestMapping</code>：用于将请求映射到控制器方法或处理程序方法。它可以用于类级别和方法级别的注解，用于定义处理请求的路径、HTTP方法、请求参数等。<ol>
<li>produces 指定指定当前方法返回对象的Content-Type。</li>
<li>consumes指定当前方法可以处理的请求Content-Type</li>
</ol>
</li>
<li><code>@GetMapping</code>：是 <code>@RequestMapping</code> 的缩写形式，用于将 GET 请求映射到方法。它指定了特定的路径，当收到 GET 请求时，将调用对应的方法来处理请求。<ol>
<li>params&#96;属性用于指定URL参数过滤条件。该方法仅处理带有”recent”参数的GET请求。</li>
</ol>
</li>
<li><code>@PostMapping</code>：是 <code>@RequestMapping</code> 的缩写形式，用于将 POST 请求映射到方法。类似于 <code>@GetMapping</code>，它指定了特定的路径，当收到 POST 请求时，将调用对应的方法来处理请求。<ol>
<li><code>@ResponseStatus(HttpStatus.CREATED)</code>表示在POST请求成功后返回状态码201（Created）</li>
</ol>
</li>
<li><code>@PutMapping</code>：是 <code>@RequestMapping</code> 的缩写形式，用于将 PUT 请求映射到方法。类似于 <code>@GetMapping</code>，它指定了特定的路径，当收到 PUT 请求时，将调用对应的方法来处理请求。</li>
<li><code>@DeleteMapping</code>：是 <code>@RequestMapping</code> 的缩写形式，用于将 DELETE 请求映射到方法。类似于 <code>@GetMapping</code>，它指定了特定的路径，当收到 DELETE 请求时，将调用对应的方法来处理请求。<ol>
<li>使用<code>@ResponseStatus(HttpStatus.NO_CONTENT)</code>表示成功删除后返回状态码204（No Content）。</li>
</ol>
</li>
<li><code>@PatchMapping</code>：是 <code>@RequestMapping</code> 的缩写形式，用于将 PATCH 请求映射到方法。类似于 <code>@GetMapping</code>，它指定了特定的路径，当收到 PATCH 请求时，将调用对应的方法来处理请求。<ol>
<li>和Put的区别在于，只更新某一个，相当于补丁</li>
</ol>
</li>
<li><code>@RestController</code>：是一个组合注解，用于标记一个类为 RESTful Web 服务的控制器。它结合了 <code>@Controller</code> 和 <code>@ResponseBody</code> 注解的功能，用于处理请求并返回数据，通常用于构建 RESTful API。</li>
<li><code>@ResponseBody</code>：用于将方法的返回值直接作为响应体返回给客户端，而不是通过视图解析器渲染为视图。它可以用于方法级别或控制器类级别。</li>
<li><code>ResponseEntity</code>：是一个类，用于表示 HTTP 响应的实体，包括状态码、响应头和响应体等。它可以用于方法的返回值类型，以更灵活地构建和自定义 HTTP 响应。</li>
</ol>
<h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><p>请求头：请求头由 key&#x2F;value 对组成，每行为一对，key 和 value 之间通过冒号(:)分割。请求头的作用主要用于<strong>通知服务端有关于客户端的请求信息</strong>。</p>
<ul>
<li>User-Agent：生成请求的浏览器类型 </li>
<li><strong>Accept</strong>：客户端可识别的响应内容类型列表；星号* 用于按范围将类型分组。*&#x2F;*表示可接受全部类型，type&#x2F;*表示可接受 type 类型的 所有子类型。<ul>
<li>application&#x2F;json常用</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231102200252323.png"><span class="image-caption">image-20231102200252323</span></li>
</ul>
</li>
<li>Accept-Language: 客户端可接受的自然语言</li>
<li>Accept-Encoding: 客户端可接受的编码压缩格式 </li>
<li>Accept-Charset： 可接受的字符集 </li>
<li><strong>Host</strong>: 请求的主机名，允许多个域名绑定同一 IP 地址 </li>
<li><strong>connection</strong>：连接方式（close 或 keepalive） </li>
<li>Cookie: 存储在客户端的扩展字段 </li>
<li>**Content-Type:**标识请求内容的类型 </li>
<li>**Content-Length:**标识请求内容的长度</li>
</ul>
<p>请求体：请求体主要用于 POST 请求</p>
<ul>
<li>与 POST 请求方法配套的请求头一般有 Content-Type和 Content-Length</li>
</ul>
<h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>状态行：由 HTTP 协议版本、状态码、状态码描述三部分构成，它们之间由空格隔开。</p>
<p>状态码：由 3 位数字组成，第一位标识响应的类型，常用的5大类状态码如下：</p>
<ul>
<li><p>1xx：表示服务器已接收了客户端的请求，<strong>客户端可以继续发送请求</strong> </p>
</li>
<li><p>2xx：表示服务器已成功接收到请求，<strong>并进行处理</strong></p>
<ul>
<li>记住201 创建资源</li>
</ul>
</li>
<li><p>3xx：表示服务器要求客户端<strong>重定向</strong> </p>
</li>
<li><p>4xx：表示客户端的请求有非法内容</p>
<ul>
<li>未授权，返回状态码401 Unauthorized</li>
</ul>
</li>
<li><p>5xx：标识<strong>服务器意外错误</strong></p>
</li>
</ul>
<p>响应头 </p>
<ul>
<li>Location：服务器返回给客户端，用于重定向到新的位置 </li>
<li>Server： 包含服务器用来处理请求的软件信息及版本信息。Vary：标识不可缓存的请求头列表 </li>
<li><strong>Connection</strong>: 连接方式<ul>
<li>close 是告诉服务端，断开连接，不用等待后续的请求了。 </li>
<li>keep-alive 则是告诉服务端，在完成本次请 求的响应后，保持连接</li>
</ul>
</li>
<li><strong>Keep-Alive</strong>: 300，期望服务端保持连接多长时间（秒）</li>
</ul>
<p>响应内容</p>
<ul>
<li>服务端返回给请求端的文本信息。</li>
</ul>
<h3 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h3><p>将java对象与json互转</p>
<ul>
<li>没有model和视图，控制器产生数据，然后消息转换器转换数据之后的资源表述</li>
<li>spring<strong>自动注册一些消息转换器</strong>（HttpMethodConverter），不过类路径下要有对应转换能力的库，如： Jackson Json processor、JAXB库</li>
</ul>
<p>使用方法</p>
<ul>
<li>使用注解@ResponseBody或类级@RestController，作用：指定使用消息转换器 </li>
<li>请求传入，@RequestBody以及HttpMethodConverter</li>
</ul>
<h2 id="前后端传参的四种方式"><a href="#前后端传参的四种方式" class="headerlink" title="前后端传参的四种方式"></a>前后端传参的四种方式</h2><ol>
<li>GET请求参数</li>
</ol>
<p><strong>通过URL</strong>携带参数,比如:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/users?<span class="hljs-built_in">id</span>=1&amp;name=Tom<br></code></pre></td></tr></table></figure>

<p>后端通过@RequestParam获取参数。</p>
<ol start="2">
<li>POST请求表单</li>
</ol>
<p><strong>表单提交</strong>参数,post表单数据到后端。</p>
<p>后端通过@RequestParam或@ModelAttribute获取表单数据。</p>
<ol start="3">
<li>POST请求body</li>
</ol>
<p><strong>将JSON&#x2F;XML</strong>等格式的数据放入请求体中传输。</p>
<p>后端通过@RequestBody注解将请求体绑定到对象中。</p>
<ol start="4">
<li>POST请求文件</li>
</ol>
<p><strong>通过form表单</strong>或XMLHttpRequest上传文件到后端。</p>
<p>后端通过MultipartFile获取上传的文件。</p>
<ul>
<li><p>总结:</p>
<ul>
<li><p>GET方式通过URL携带参数</p>
<ul>
<li>POST方式通过表单或请求体传参<ul>
<li>表单通过@RequestParam或@ModelAttribute获取</li>
<li>请求体通过@RequestBody将body绑定到对象</li>
</ul>
</li>
</ul>
</li>
<li><p>文件上传通过表单或者XMLHttpRequest对应MultipartFile获取文件</p>
</li>
</ul>
</li>
</ul>
<h2 id="spring-boot-starter-data-rest"><a href="#spring-boot-starter-data-rest" class="headerlink" title="spring-boot-starter-data-rest"></a>spring-boot-starter-data-rest</h2><p>目的</p>
<ul>
<li>将Spring Data存储库暴露为REST端点</li>
<li>自动实现增删改查的REST API</li>
</ul>
<p>用于快速开发基于Spring Data REST的Restful API项目。</p>
<ul>
<li><p>自动引入Spring Data REST、Spring HATEOAS等组件所需要的依赖。</p>
</li>
<li><p>自动配置和启用了Spring Data REST功能。</p>
</li>
<li><p>自动暴露Spring Data Repositories</p>
</li>
<li><p>自动暴露Restful API。</p>
</li>
<li><p>返回值包含实体与其相关实体或操作的URI链接。</p>
</li>
<li><p>对外提供与数据相关的Restful CRUD接口。</p>
</li>
<li><p>可以根据不同需求定制和扩展自动生成的API功能。</p>
</li>
</ul>
<p>使用它可以一步创建基于实体的Restful API项目框架**,开发者只需定义接口和实体类即可。**大大提高开发效率。</p>
<p>使用方式</p>
<ul>
<li><p>@Data<br>@Entity<br>@RestResource(rel&#x3D;”tacos”, path&#x3D;”tacos”)</p>
</li>
<li><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231102211936578.png"><span class="image-caption">image-20231102211936578</span></p>
</li>
</ul>
<h2 id="RestTemplate（不考"><a href="#RestTemplate（不考" class="headerlink" title="RestTemplate（不考"></a>RestTemplate（不考</h2><p>目的</p>
<ul>
<li>测试和保护REST端点</li>
</ul>
<p>RestTemplate是Spring提供的用于执行HTTP请求的客户端模板类。使用RestTemplate可以方便地发起各种HTTP请求,与远程服务进行交互,在Spring注入模板后使用更简单高效。主要方法如下:</p>
<ul>
<li>getForObject:执行HTTP GET请求,并解析响应体为指定对象类型返回。</li>
<li>getForEntity:执行HTTP GET请求,返回ResponseEntity对象,包含响应头和响应体。</li>
<li>postForObject:执行HTTP POST请求,并解析响应体为指定对象类型返回。</li>
<li>postForEntity:执行HTTP POST请求,返回ResponseEntity对象。</li>
<li>postForLocation:执行POST请求,返回Location头指定的URL。</li>
<li>put:执行HTTP PUT请求,用于资源更新。</li>
<li>delete:执行HTTP DELETE请求,用于资源删除。</li>
<li>execute:执行任意HTTP请求但不解析响应体,返回Response。</li>
<li>exchange:执行任意HTTP请求,返回ResponseEntity对象,包含请求响应全过程的数据。</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231102214752049.png"><span class="image-caption">image-20231102214752049</span></li>
</ul>
<h2 id="Feign（不考"><a href="#Feign（不考" class="headerlink" title="Feign（不考"></a>Feign（不考</h2><p>分布式使用</p>
<p>远程调用RestAPI</p>
<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231102211737197.png"><span class="image-caption">image-20231102211737197</span></li>
</ul>
<h1 id="Lecture-10-OAuth2"><a href="#Lecture-10-OAuth2" class="headerlink" title="Lecture 10 OAuth2"></a>Lecture 10 OAuth2</h1><ul>
<li><p>OAuth2，一个专门为 API创建的授权规范。</p>
</li>
<li><p>对微服务作权限控制</p>
</li>
<li><p>统一认证和授权，专心业务</p>
</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231111094840312.png"><span class="image-caption">image-20231111094840312</span></p>
<ul>
<li><p>非常重要的图！考试必考</p>
</li>
<li><p>流程：</p>
<ul>
<li><p>1.用户进入url，发现没登录</p>
</li>
<li><p>2.资源服务器 重定向到 授权服务器，打开登录对话框</p>
</li>
<li><p>3.新的url（资源服务器）让用户提供consent</p>
<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231111102642798.png"><span class="image-caption">image-20231111102642798</span></li>
</ul>
</li>
<li><p>4.用户确认授权consent</p>
</li>
<li><p>5.返回授权码 auth code</p>
</li>
<li><p>6.Client获取auth code 后再向授权服务器获取token（不能直接获取吗？）</p>
<ul>
<li>减少明文密码在浏览器出现的次数，转化为authcode。避免被第三方软件劫持</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231111112405718.png"><span class="image-caption">image-20231111112405718</span></li>
</ul>
</li>
<li><p>7.用户带着token 去资源服务器请求资源</p>
<ul>
<li>资源服务器需向authserver获取公钥，用以解码token,验证身份</li>
</ul>
</li>
<li><p>8.返回资源</p>
<blockquote>
<ol>
<li>令牌和凭证：<ul>
<li>令牌（Token）是一种代表用户身份的数据结构，用于在身份验证和授权过程中进行传递。令牌可以是访问令牌（Access Token）、身份令牌（ID Token）等。它们通常由授权服务器颁发给客户端，用于表示用户的身份和授权信息。</li>
<li>凭证（Credential）是用于证明用户身份和权限的数据，可以是用户名和密码、API密钥、数字证书等。凭证通常由用户提供给身份验证系统或应用程序，用于获取相应的令牌或授权。</li>
</ul>
</li>
<li>公私钥和凭证：<ul>
<li>公私钥是一对密钥，用于加密和解密数据。公钥用于加密数据，而私钥用于解密数据。公钥可以安全地共享给其他人，而私钥必须保持机密。</li>
<li>凭证在身份验证过程中可以与公私钥配对使用，以提供更安全的身份验证机制。例如，数字证书是一种凭证形式，其中包含用户的公钥和其他身份信息，并由证书颁发机构（CA）使用其私钥签名。在身份验证过程中，验证方可以使用公钥解密数字证书的签名，并验证证书的真实性和完整性。</li>
</ul>
</li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li><p>举例：用微信获取信息 理解</p>
</li>
</ul>
<h2 id="JWT、JWK"><a href="#JWT、JWK" class="headerlink" title="JWT、JWK"></a>JWT、JWK</h2><ul>
<li>JSON web key，RSA密钥对(公钥私钥)，用于对令牌签名.令牌会用私钥签名，资源服务器会通过从授权服务器获取到的公钥验证请求中收到的令牌是否有效<ul>
<li>interface JWKSource</li>
<li>interface JwtDecoder</li>
</ul>
</li>
<li>JWT是一种开放标准（RFC 7519），用于在不同实体之间安全传输信息。它由三部分组成：头部（Header）、载荷（Payload）和签名（Signature）。<ul>
<li>头部包含描述JWT的元数据，如使用的加密算法等。</li>
<li>载荷包含有关实体和其他附加数据的信息，例如用户ID、过期时间等。</li>
<li>签名是对头部和载荷进行数字签名的结果，用于验证JWT的完整性和真实性。</li>
</ul>
</li>
<li>JWT提供了一种安全传输和验证信息的标准化格式，而JWK用于描述和传输用于JWT签名和验证的密钥对。通过使用JWK，可以验证JWT的真实性和完整性</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231111101635688.png"><span class="image-caption">image-20231111101635688</span></p>
<ul>
<li>解码例子 ↑</li>
</ul>
<h2 id="授权服务器"><a href="#授权服务器" class="headerlink" title="授权服务器"></a>授权服务器</h2><p>1.<br>2. 开发Spring Security User实体，接入数据库。</p>
<ol>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231111111631218.png"><span class="image-caption">image-20231111111631218</span></li>
</ol>
<h2 id="资源服务器"><a href="#资源服务器" class="headerlink" title="资源服务器"></a>资源服务器</h2><ol>
<li>添加OAuth2  pom依赖</li>
<li>添加SCOPE权限控制 &#x2F; 开启调用API前的过滤器：<ol>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231111111518116.png"><span class="image-caption">image-20231111111518116</span></li>
</ol>
</li>
<li>指定授权服务器地址，目的是获得公钥<ol>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231111111539864.png"><span class="image-caption">image-20231111111539864</span></li>
</ol>
</li>
</ol>
<h2 id="开发客户端"><a href="#开发客户端" class="headerlink" title="开发客户端"></a>开发客户端</h2><ol>
<li>添加Oauth2-client专用的pom依赖</li>
<li>代码配置<ol>
<li>定义第2步的重定向</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231111113701029.png"><span class="image-caption">image-20231111113701029</span></li>
</ol>
</li>
<li>属性配置<ol>
<li>配置获取token的重定向地址</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231111113709321.png"><span class="image-caption">image-20231111113709321</span></li>
</ol>
</li>
</ol>
<h1 id="Lecture-11-消息中间件"><a href="#Lecture-11-消息中间件" class="headerlink" title="Lecture 11 消息中间件"></a>Lecture 11 消息中间件</h1><h2 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h2><p>Java 消息服务（Java Message Servcie）</p>
<ul>
<li>JMS是一个Java标准，定义了使用消息代理（message broker）的通用API</li>
<li>Spring通过基于模板的抽象为JMS功能提供了支持，这个模板就JmsTemplate</li>
</ul>
<p>生产消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">connectionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActiveMQConnectionFactory</span>(BROKER_URL, USERNAME, PASSWORD);<br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> connectionFactory.createConnection();<br>connection.start();<br><span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> connection.createSession(<span class="hljs-literal">false</span>, Session.AUTO_ACKNOWLEDGE);<br><span class="hljs-type">Destination</span> <span class="hljs-variable">destination</span> <span class="hljs-operator">=</span> session.createQueue(<span class="hljs-string">&quot;queue.example&quot;</span>);<br><br></code></pre></td></tr></table></figure>

<p>关键方法</p>
<ul>
<li><p><strong>javax.jms.Destination：指定队列或主题</strong> : tacocloud.order.queue</p>
<ul>
<li><p>application.yml（default-destination）</p>
</li>
<li><p>@Bean（Destination对象）</p>
</li>
<li><p>直接String指定</p>
</li>
</ul>
</li>
<li><p><strong>发送消息</strong>的两个方法：send、<strong>convertAndSend</strong></p>
</li>
<li><p><strong>MessageConverter</strong></p>
<ul>
<li>SimpleMessageConverter：实现String与TextMessage的相互转换、字节数组与BytesMessage的相互转换、Map与MapMessage的相互转换，以及Serializable对象与ObjectMessage的相互转换 </li>
<li>MappingJackson2MessageConverter：使用Jackson 2 JSON库实现消息与JSON格式的互转</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231116204313985.png"><span class="image-caption">image-20231116204313985</span></li>
</ul>
</li>
</ul>
<p>不同模式</p>
<ul>
<li><p>拉取模式(Pull Model):</p>
<ul>
<li>拉取模式下,消费者主动从消息队列中拉取消息。即消费者需要不断地向消息队列发出请求,检测是否有新的消息到来,如果有则拉取消息进行消费。</li>
</ul>
</li>
<li><p>推送模式(Push Model):</p>
<ul>
<li>推送模式下,消息队列主动推送消息给消费者。当消息队列中有新消息到达时,会主动通知并直接发送给消费者,而不是等待消费者拉取。</li>
</ul>
</li>
</ul>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><ul>
<li>Exchange:交换机,它是消息进入队列的入口。负责将消息路由到对应的Queue<ul>
<li>主要类型:<ul>
<li>Direct Exchange:根据routing key完全匹配将消息路由到对应的Queue。</li>
<li>Fanout Exchange:将消息进行广播,将消息路由到所有绑定到该Exchange的Queue。</li>
<li>Topic Exchange:根据routing key的通配符规则将消息路由到对应的Queue。</li>
</ul>
</li>
</ul>
</li>
<li>Binding:绑定关系,它将Exchange和Queue绑定起来。</li>
<li>Routing Key:路由键,Exchange根据该键与Binding的binding key匹配将消息路由到对应的Queue。</li>
<li>Binding key:Binding中的键,它将Exchange和Queue关联起来。</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231116203552518.png"><span class="image-caption">image-20231116203552518</span></li>
</ul>
<h1 id="Lecture-12-spring-integration"><a href="#Lecture-12-spring-integration" class="headerlink" title="Lecture 12 spring integration"></a>Lecture 12 spring integration</h1><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231123205551218.png"><span class="image-caption">image-20231123205551218</span></p>
<ul>
<li>本节课做的：③Email Server</li>
</ul>
<p>集成流配置三种方式</p>
<ul>
<li>XML配置</li>
<li>Java配置 </li>
<li>使用DSL的Java配置</li>
</ul>
<h2 id="最简集成流的五个部分"><a href="#最简集成流的五个部分" class="headerlink" title="最简集成流的五个部分"></a>最简集成流的五个部分</h2><ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231123205532037.png"><span class="image-caption">image-20231123205532037</span></li>
<li>消息分为Header和Payload</li>
</ul>
<h2 id="集成流的组件"><a href="#集成流的组件" class="headerlink" title="集成流的组件"></a>集成流的组件</h2><ul>
<li>Channels（通道） —Pass messages from one element to another.<ul>
<li>例如：PublishSubscribeChanne、QueueChannel、PriorityChannel</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231123210628428.png"><span class="image-caption">image-20231123210628428</span></li>
</ul>
</li>
<li>Filters（过滤器） —Conditionally allow messages to pass through the flow based on some criteria.<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231123210721288.png"><span class="image-caption">image-20231123210721288</span></li>
</ul>
</li>
<li>Transformers（转换器） —Change message values and&#x2F;or convert message payloads from one type to another.<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231123210821660.png"><span class="image-caption">image-20231123210821660</span></li>
</ul>
</li>
<li>Routers（路由器） —Direct messages to one of several channels, typically based on message headers.<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231123212118322.png"><span class="image-caption">image-20231123212118322</span></li>
</ul>
</li>
<li>Splitters（切分器） —Split incoming messages into two or more messages, each sent to different channels. <ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231123212211014.png"><span class="image-caption">image-20231123212211014</span></li>
<li>切分的是消息，不是router到多个channel</li>
</ul>
</li>
<li>Aggregators（聚合器） —The opposite of splitters, combining multiple messages coming in from separate channels into a  single message.</li>
<li>Service activators（服务激活器） —Hand a message off to some Java method for processing, and then publish the return  value on an output channel. <ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231123212241684.png"><span class="image-caption">image-20231123212241684</span></li>
<li>类似transformers，语义上不同</li>
</ul>
</li>
<li>Channel adapters（通道适配器） —Connect a channel to some external system or transport. Can either accept input or  write to the external system. <ul>
<li><img src="/C:/Users/lar/AppData/Roaming/Typora/typora-user-images/image-20231123212510747.png"><span class="image-caption">image-20231123212510747</span></li>
<li><strong>Inbound Channel Adapter（入站通道适配器）</strong>：<ul>
<li><strong>作用</strong>：Inbound Channel Adapter 负责将外部系统的数据转换成消息，并将这些消息发送到 Spring Integration 流程中的通道。</li>
<li><strong>例子</strong>：一个常见的例子是文件适配器（File Inbound Channel Adapter），它可以监听指定的文件夹，并在文件变化时将文件内容转化为消息发送到通道中。另一个例子是 JMS 入站适配器，用于从 JMS 队列接收消息。</li>
</ul>
</li>
<li><strong>Outbound Channel Adapter（出站通道适配器）</strong>：<ul>
<li><strong>作用</strong>：Outbound Channel Adapter  负责将消息从 Spring Integration 流程中取出并传递给外部系统。</li>
<li><strong>例子</strong>：一个例子是文件适配器（File Outbound Channel Adapter），它将消息的内容写入文件。另一个例子是 JMS 出站适配器，用于将消息发送到 JMS 队列。</li>
</ul>
</li>
</ul>
</li>
<li>Gateways（网关） —Pass data into an integration flow via an interface<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231123212410022.png"><span class="image-caption">image-20231123212410022</span></li>
</ul>
</li>
</ul>
<h1 id="Lecture-13-反应式编程"><a href="#Lecture-13-反应式编程" class="headerlink" title="Lecture 13 反应式编程"></a>Lecture 13 反应式编程</h1><p>什么是Reactor、java NIO、netty</p>
<ul>
<li>Reactor是一个反应式编程库，用于构建异步和非阻塞的应用程序。</li>
<li>Java NIO是Java平台提供的非阻塞I&#x2F;O编程模型，用于提高I&#x2F;O操作的性能和并发能力。</li>
<li>Netty则是基于Java NIO的网络应用程序框架，提供了高性能和可定制的网络编程API。</li>
<li>这些技术和框架都有助于构建高效的异步和非阻塞的应用程序和网络服务。</li>
</ul>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ul>
<li>命令式编程范式<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207183004199.png"><span class="image-caption">image-20231207183004199</span></li>
<li>强调顺序，强调怎么做</li>
</ul>
</li>
<li>反应式编程范式<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207190905257.png"><span class="image-caption">image-20231207190905257</span></li>
<li>关注数据流和事件变化，强调什么要做</li>
<li>将计算看作是一系列数据流的转换和响应事件的触发。</li>
</ul>
</li>
<li>声明式编程可以应用于多种编程范式。注重问题的描述和逻辑<ul>
<li>函数式编程是一种常见的声明式编程范式，强调使用函数作为基本的构建块来解决问题，并避免可变状态和副作用。</li>
<li>函数式编程和反应式关系紧密</li>
</ul>
</li>
</ul>
<p>解决了什么问题</p>
<ul>
<li>IO密集型场景，减少等待，管理多线程。<ul>
<li>IO：远程通信、内存读写</li>
</ul>
</li>
<li>用尽量少的线程，解决多请求。事件队列<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207191850202.png"><span class="image-caption">image-20231207191850202</span></li>
</ul>
</li>
</ul>
<h2 id="Reactor（重要）"><a href="#Reactor（重要）" class="headerlink" title="Reactor（重要）"></a>Reactor（重要）</h2><p>Reactive Streams：</p>
<ul>
<li><p>一套规范，供无阻塞回压的异步流处理标准</p>
<ul>
<li>回压是指当生产者生成数据的速度大于消费者处理数据的速度时，消费者如何向生产者发出信号以控制数据流的速度。背压机制是为了解决这种情况下的流量控制问题，以确保消费者能够有效地处理数据，而不会被淹没或溢出</li>
</ul>
</li>
<li><p>与jdk的stream的区别：java的stream是同步的</p>
</li>
<li><p>jdk的反应式编程叫做Flow</p>
</li>
</ul>
<p>Reactor</p>
<ul>
<li>Spring Pivotal团队提供的<strong>响应式编程的Java实现</strong></li>
</ul>
<p>Spring WebFlux</p>
<ul>
<li>基于响应式编程的Web应用程序的开发。</li>
<li>类似于Spring MVC的编程模型，但不基于servlet</li>
</ul>
<h2 id="反应式流规范定义的4个接口（-重要）"><a href="#反应式流规范定义的4个接口（-重要）" class="headerlink" title="反应式流规范定义的4个接口（++重要）"></a>反应式流规范定义的4个接口（++重要）</h2><p>问答题</p>
<p>注意①②③④⑤</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207183850643.png"><span class="image-caption">image-20231207183850643</span></p>
<ol>
<li>Publisher（发布者）：表示数据的<strong>生产者</strong>，可以发布数据流。<ol>
<li>submit：发布数据给subscription，<strong>每个subscriber对应一个subscription</strong></li>
<li>subscribe：与下一个订阅者建立连接</li>
</ol>
</li>
<li>Subscriber（订阅者）：表示数据的<strong>消费者</strong>，可以订阅并处理数据流。<ol>
<li>onSubscribe：publisher告诉订阅者，建立连接</li>
<li>onNext：订阅者获取下一个数据。<strong>背压调节流速</strong></li>
<li>onError：告诉订阅者出错</li>
<li>onComplete：告诉订阅者结束</li>
</ol>
</li>
<li>Subscription（订阅关系）：一个协调者，纽带。表示订阅者与发布者之间的连接，用于控制数据流的请求和取消订阅。<ol>
<li>request，subscriber请求数据</li>
<li>cancel</li>
</ol>
</li>
<li>Processor（处理器）：表示一个中间组件，<strong>同时具有发布者和订阅者</strong>的功能，可以将数据进行<strong>转换、过滤等</strong>操作。<ol>
<li>extends Publisher,Subscriber</li>
</ol>
</li>
</ol>
<h2 id="Flux-和-Mono"><a href="#Flux-和-Mono" class="headerlink" title="Flux 和 Mono"></a>Flux 和 Mono</h2><p>Flux和Mono是Reactor库中的两个核心类，用于支持反应式流编程模型。</p>
<ul>
<li>Flux：Flux是一个表示0到N个元素的异步序列的类。它类似于Java 8中的Stream，但具有异步和背压控制的能力。Flux可以用于表示多个值的流，可以是有限的，也可以是无限的。它可以发出元素，同时也可以处理背压，以确保在消费者准备好接收时进行数据流控制。</li>
<li>Mono：Mono是一个表示0或1个元素的异步序列的类。它类似于Flux，但只能发出零个或一个元素。Mono可以用于表示单个值的流，例如数据库查询、HTTP请求的响应等。它也可以处理背压，确保在消费者准备好接收时进行数据流控制</li>
</ul>
<p>消息</p>
<ul>
<li>正常的包含元素的消息、序列结束的消息和序列出错的消息</li>
<li>和Integration消息区别：没有消息Head和Body之分</li>
<li>和RabbitMQ等中间件区别：不需要序列化和反序列化，因为只在JVM中流动</li>
</ul>
<p>四种操作</p>
<ul>
<li><p>创建操作</p>
<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207202800486.png"><span class="image-caption">image-20231207202800486</span></li>
<li>根据对象&#x2F;集合&#x2F;迭代器，甚至是时间间隔（interval）创建。<ul>
<li>消费时，多线程自动编排</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207203538187.png"><span class="image-caption">ww</span></li>
</ul>
</li>
</ul>
</li>
<li><p>组合操作</p>
<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207205111813.png"><span class="image-caption">image-20231207205111813</span><ul>
<li>merge：合并同类型</li>
<li>zip：合并不同类型到tuple，也可以自己改造元素</li>
<li>first：只看第一个有数据的流</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207212923617.png"><span class="image-caption">image-20231207212923617</span></li>
</ul>
</li>
</ul>
</li>
<li><p>过滤操作</p>
<ul>
<li>Predicate：返回True或False</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207213307397.png"><span class="image-caption">image-20231207213307397</span><ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207213359092.png"><span class="image-caption">image-20231207213359092</span></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>转换操作（重要）</strong></p>
<ul>
<li><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207213626300.png"><span class="image-caption">image-20231207213626300</span></p>
</li>
<li><p>map：转换类型，<strong>返回的是数据</strong></p>
<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207213646882.png"><span class="image-caption">image-20231207213646882</span></li>
</ul>
</li>
<li><p>flatMap：<strong>返回的是流</strong>，所以类型是Mono&#x2F;Flux</p>
<ul>
<li><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207214205506.png"><span class="image-caption">image-20231207214205506</span></p>
<ul>
<li>Schedulers：可以决定是否并行，顺序不可控</li>
</ul>
</li>
<li><p><strong>本质上是扁平化，将多个流化为一个流。在多重流时可以并发处理</strong></p>
</li>
<li><p><img src="/C:/Users/lar/AppData/Roaming/Typora/typora-user-images/image-20231208013716522.png"><span class="image-caption">image-20231208013716522</span></p>
</li>
</ul>
</li>
<li><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207214531371.png"><span class="image-caption">image-20231207214531371</span></p>
</li>
<li><p>返回分组（List）的流。类似MapReduce</p>
<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207214827674.png"><span class="image-caption">image-20231207214827674</span></li>
</ul>
</li>
</ul>
</li>
<li><p>逻辑操作</p>
<ul>
<li><img src="/C:/Users/lar/AppData/Roaming/Typora/typora-user-images/image-20231208014251456.png"><span class="image-caption">image-20231208014251456</span></li>
<li>Boolean也是流</li>
</ul>
</li>
</ul>
<h1 id="Lecture-14-WebFlux"><a href="#Lecture-14-WebFlux" class="headerlink" title="Lecture 14 WebFlux"></a>Lecture 14 WebFlux</h1><h1 id="WebFlux"><a href="#WebFlux" class="headerlink" title="WebFlux"></a>WebFlux</h1><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207200211792.png"><span class="image-caption">image-20231207200211792</span></p>
<ul>
<li>必须Subscribe才能操作数据</li>
</ul>
<h2 id="R2DBC"><a href="#R2DBC" class="headerlink" title="R2DBC"></a>R2DBC</h2>]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
  </entry>
  <entry>
    <title>这是一个什么网站</title>
    <url>/2099/01/01/%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BB%80%E4%B9%88%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<p>学术主页见<a href="lianganran.top/scholar">lianganran.top&#x2F;scholar</a></p>
<span id="more"></span>

<p>#意义#</p>
<p>这是一个lar的个人网站。记录一些学习笔记（计算机、数学），一些随想，一些帮助我理清思绪的文字，一些照片。</p>
<ul>
<li>学术主页见<a href="lianganran.top/scholar">lianganran.top&#x2F;scholar</a></li>
</ul>
<p>右上角进入菜单。随时可能关闭，也可能一直开下去。</p>
<hr>
<h2 id="向内探索与向外输出"><a href="#向内探索与向外输出" class="headerlink" title="向内探索与向外输出"></a>向内探索与向外输出</h2><p>一直是一个分享欲寡淡的人，极少在网络上输出自己的观点与想法。一是因为厌倦争论和讨论的效率过低，二是因为学疏才浅怕真正有学识的人在背后偷笑。</p>
<p>但终究意识到输入与输出必须适配，思绪需要整理否则只是脑海里缠成一团的毛线。不化成文字或影像形式记录下来，“顿悟”也只是自我满足的安慰感。写博客 &#x2F; 微信公众号 &#x2F; 微博知乎都只是一种工具。</p>
<p>于是就有了这个随便捣鼓的网站，有一些随便捣鼓的杂文和学习笔记，你可以借此随便一窥网站主内心的一角，但切不可将其和现实中的印象混淆</p>
<h2 id="如何与我讨论"><a href="#如何与我讨论" class="headerlink" title="如何与我讨论"></a>如何与我讨论</h2><p>可以直接在微信上以任何动机联系我，但请说明来意。</p>
<ul>
<li>我很喜欢与人讨论问题。你可以直接向我发问任何你感兴趣的 或敏感或平淡的 各行各业的 文史哲的数学物理的话题。但【礼貌】【包容】【尊重】【直接】是我个人偏好的交流基本原则。</li>
<li>平时会因为忙 &#x2F; 想独处而<strong>忘记回复消息</strong>，请不要介意</li>
<li>有任何不满也请直接提出</li>
</ul>
]]></content>
      <categories>
        <category>杂文</category>
      </categories>
  </entry>
  <entry>
    <title>量化投资入门1：投资与股票交易规则</title>
    <url>/2023/01/11/1.%E6%8A%95%E8%B5%84%E5%92%8C%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<p>投资与股票交易规则。也适用于主观交易</p>
<span id="more"></span>



<h1 id="【第一讲：投资与股票交易规则】"><a href="#【第一讲：投资与股票交易规则】" class="headerlink" title="【第一讲：投资与股票交易规则】"></a>【第一讲：投资与股票交易规则】</h1><p>第一讲：投资与股票交易规则</p>
<p>这一部分我们先聊一下大佬们的投资市场（一级市场）和散户&#x2F;技术宅&#x2F;宽客们也可以玩的投资市场（二级市场），然后我们介绍一些做量化交易必须了解的股票交易规则。在说这个部分的正题之前，我们有必要再说一下投资。</p>
<p><strong>投资就是花钱买资产，期望能够带来收益，</strong>投资所买的资产也称为<strong>投资标的</strong>。投资标的有很多类型，包括一家公司的<strong>所有权或者股份、上市公司的股权、期货、期权、基金</strong>等。我们最常说的炒股就是在投资上市公司的<strong>股权</strong>。</p>
<p><strong>框架</strong></p>
<ul>
<li>技术分析（短期）（供需）（看图找规律）<ul>
<li>依赖大量数据（hedge fund)</li>
<li>系统速率</li>
<li>机器学习、数学模型</li>
</ul>
</li>
<li>基本面分析（中长期）（价值）<ul>
<li>宏观（底层：货币总量）<ul>
<li>各种率</li>
<li>股&#x2F;债</li>
<li>经济体（国家）选择</li>
</ul>
</li>
<li>行业（看研报）<ul>
<li>所处周期</li>
<li>行业格局（门槛&#x2F;……)</li>
<li>政府政策</li>
<li>板块轮动（大众倾向）</li>
</ul>
</li>
<li>选股<ul>
<li>定性<ul>
<li>模式、成长、护城河&#x2F;门槛（品牌、用户、转换成本）</li>
<li>微笑曲线：上下游</li>
</ul>
</li>
<li>定量<ul>
<li>三张表（盈利能力&#x2F;财务健康&#x2F;价格水平）</li>
<li>行业特征指标</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>目录</strong></p>
<ol>
<li>一级市场与二级市场</li>
<li>股票是如何交易的？</li>
<li>如何看懂行情软件显示的数据？</li>
<li>交易所规则：涨跌幅限制</li>
<li>交易所规则：停复牌</li>
<li>交易所规则：除息除权</li>
</ol>
<h2 id="1-一级市场与二级市场"><a href="#1-一级市场与二级市场" class="headerlink" title="1.一级市场与二级市场"></a>1.一级市场与二级市场</h2><p><strong>一级市场</strong></p>
<p>拿投资公司的股份来说，假设你要投资的公司是未上市的公司，比如现在的ofo、今日头条等。对这些公司进行投资，即出钱认购这些公司的一部分股份，公司盈利之后，股票的价值增加，就能够通过出售相应的股份来获得收益。</p>
<p>但是通常来讲，我们用多少钱能换到公司的多少股份其实很难确定，这就涉及到需要对公司进行<strong>估值</strong>。比如你现在想投资一百万，如果某个公司估值是一千万，那么你就能用着一百万来获得该公司10%的股份。如果你要投资的这家公司是江南皮革厂，它的主要价值在于它拥有的库存的产品、生产的机器和厂房等，通常这一类工厂的估值就比较容易，我们只需要把相应的皮包、生产线按照相应的价值折算成人民币就可以了，这样估算出来的价值一般比较准确。但是现在很多企业的价值并不仅仅在于这些可以计算清楚的资产，比如ofo的估值就不仅仅在于它拥有的小黄车的价值，而更多的在于它的<strong>品牌和商业模式</strong>。因此，对于不同的投资人来讲，对于未上市公司的<strong>估值差异一般是比较大的</strong>。</p>
<p>这一部分的投资通常由一些机构来完成，主要有如下几个原因。其一，需要的资金量比较大，一般都是几百万到几十亿地投，一般人也没这个钱；其二，其风险是很高，这些被投资的公司大多数都没有办法等到上市或者盈利的那一天，一般来讲，投十个成功一个已经很不错了；其三，需要相关领域及其专业，只是，这些等待投资的公司业务水平参差不齐，但是忽悠水平基本上都是一流的，如果没有一定的专业知识很容易被这些公司忽悠地团团转。当然也有一些个人来做，就是我们说的<strong>天使投资人</strong>什么的，他们凭借自己对于某些行业的专业知识，来准确对公司进行估值和投资，以获得收益。</p>
<p>这些投资即我们常听到的<strong>VC（Venture Capital，风险投资）、PE（Private Equity，私募股票投资）</strong>等，属于**<u>一级市场</u><strong>。一级市场相对来讲属于比较“脏”的劳动，</strong>需要对于相应的行业有很深的理解、需要对于特定的公司进行详细的调研、甚至需要对于该公司的创始人都要能有足够的观察**，这部分的投资不是我们前面讲到的适合理工科宅男&#x2F;宅女的工作。当然，这部分工作如果能够做的好，回报也是相当丰厚的。一般对于某个公司的投资目标都是冲着翻几十倍甚至几百倍去的。</p>
<p><strong>二级市场</strong></p>
<p>通常来说，当一家公司发展壮大之后，就会进行IPO<strong>（Initial Public Offering，首次公开发行）</strong>，就是能够通过增发股份公开地募集资金了。一般来讲，<strong>IPO之后公司就会在交易所挂牌交易，这就是我们常说的上市</strong>。公司上市之后，普通的股民就可以自由买卖该公司的股票了。公司的股份在交易所交易的时候已经被拆成了上千万股，因此股民花个几千或者几万块钱就可以买入公司的一手（&#x3D;100股）股份，这样也大大降低了公众投资的资金门槛。另外，所有在交易所挂牌交易的股票都<strong>遵循同一套交易规则</strong>，并且需要符合交易所的同一套规定，比如定期财务审计和公告、重大事项披露等，这个给我们做量化带来了很多便利。股民在交易所自由买卖某公司的股票的市场，我们一般就把它叫做**<u>二级市场</u><strong>。一般来说，公司上市之后VC和PE投资人就算是快成功完成这一场投资了，在公司上市之后（还需要在禁售期之后），这些资金一般就会</strong>选择退出**，相应的股份就会由股民来接盘。</p>
<p>大家通常觉得一家公司上市了就很牛逼，其实并不是这样。上市是因为公司需要融资，要么是因为需要更多的钱来扩大再生产，而自己又找不到这么多钱；要么是因为在早些时候拿了投资人的钱，就得照顾投资人的利益，通过上市来让投资人把他们所取得的收益兑现。所以<strong>上市说明公司缺钱，其目的主要就是向股民借钱。并不是所有的公司做大了都会上市</strong>，比如瑞典的宜家就是属于传统的家族企业的模式，其掌门人也宣称宜家永远不上市。其主要原因就是1）上市之后会<strong>丧失对企业的掌控能力</strong>，毕竟拿了金主爸爸的钱就要听金主爸爸的话；2）上市就必须要进行<strong>交易所规定的信息披露</strong>，这会影响公司的避税；3）当然最主要的原因就是人家不缺钱或者有其他的融资方式。公司通过上市的方式来融资**<u>主要目的就是分担风险</u><strong>，因为如果公司亏损股民也需要承担一部分损失，相应的补偿就是如果公司盈利也需要给股民一部分收益。如果一家公司一直都稳定赚钱，那么公司显然就不需要来找公众来分担风险，如果公司缺钱也会去</strong>找银行贷款或者发行债券**，这样需要支付的利息是恒定的，但是比分给股民的收益小很多，公司经营的风险就由公司自己来承担。同样的例子还有“国民女神”陶碧华所经营的老干妈，即使年销售额达到几十亿，足够上市公司的规模了，但是人家就是不上市。陶碧华本人称“上市就是欺骗人家的钱”。</p>
<p>讲了这么多，看起来公司上市之后股民来投资好像真的是凶多吉少。但其实为了保证股民们的利益，<strong>交易所制定了许多的规则，来确保这些上市公司不坑股民</strong>。首先，公司要上市就需要满足诸多的规定，其中包括公司要成立多少年以上，并且近几年都要有足够的利润等。同时，上市之后也需要及时披露公司的各种规定的信息，比如公司每季度的营业状况、高管的变动、高管的薪资等。如果公司上市之后营运出现问题，交易所也会对相关的公司做出警告甚至强制其退市。总的来说，以近两年的股市为例，按上证综指来算的话，年化收益率也是也是远超过定期存款的。因此，如果采取有效的投资方法，在股市中也是能取得较好的收益的。</p>
<p>总结一下，一级市场指的是从天使投资人开始给公司投资到公司上市这段时期的资本市场，这段时期是公司成长最快、盈利最多的一段时期，同时也是风险最高的一段时期，它需要投资人较多的专业知识和较高的资金门槛。二级市场指的是公司上市之后股民开始可以在交易所买卖相应股票的市场，它相比于一级市场来说风险更小、收益也更小，不过其收益和风险相比于余额宝或者定期存款也是十分巨大的了。</p>
<h2 id="2-股票是如何交易的？"><a href="#2-股票是如何交易的？" class="headerlink" title="2.股票是如何交易的？"></a><strong>2.股票是如何交易的？</strong></h2><p>股票交易本质上和日常去菜市场买菜差不多。卖家说一颗白菜一块钱，买家觉得这个价格可以接受就可以付钱取走菜。股票交易就是把这白菜、莴笋换成了平安银行股票、万科的股票等等，交易场地由菜市场换成了股票交易所。我们国家的股票交易所主要就是深圳证券交易所和上海证券交易所。股票交易和菜市场买菜不一样的地方主要在于，在菜市场中你不仅关心白菜的价格，同时还关心白菜的质量，有时候我们还会觉得图便宜买了的白菜可能不好吃。在股票交易中，A卖的白菜和B卖的白菜，只要它们都是白菜就没有任何区别，买到一棵白菜的价格越便宜越好。因此对于买家来说，目标就是以最低的价格买到白菜；而对于卖家来说就最高的价格卖出白菜。市场上可能有几千个人都要卖白菜，同时由由几千个人想买白菜，那么如何决定把谁的白菜卖给谁呢。于是交易所使用了我们称之为竞价交易的方式来进行交易的撮合。</p>
<p>在炒股软件上（通常在软件的右上方）我们可以看到这样的信息，它是限价委托薄（limit order book）&#x2F;订单薄的一个表示，股民们一般称之为盘口。</p>
<p>卖五      20.00       3 </p>
<p>卖四      19.98       3 </p>
<p>卖三      19.97       13 </p>
<p>卖二      19.89       8</p>
<p><strong>卖一</strong>      19.88       34</p>
<p><strong>买一</strong>      19.82       8 </p>
<p>买二      19.81       6 </p>
<p>买三      19.80       24 </p>
<p>买四      19.79       20 </p>
<p>买五      19.70       10 </p>
<p>显然，卖家希望成交价格越高越好，买家希望成交的价格越低越好。排在上面的“卖一”到“卖五”表明卖家接受的愿意出售股票的单位价格，即卖方出价（ask price）。以“卖一”为例，后面紧跟着的19.88这样的数字就是他们的出价，再后面跟着的数字34就是表明有34手股票愿意在这个价格被卖掉。要注意的是我们看到的价格单位是“元&#x2F;股”，但是后面标的数量单位是“手”，<strong>一手等于100股，手也是最小的交易单元</strong>。这大概有点像你去菜市场买菜都是起码一两斤地买，不允许你只买一根小葱。（有一个例外情况就是，如果你手上剩了110股，那么你应当一次性卖出，不能剩个10股在手上；至于为什么你手上会有10股的零头出现，我们之后会讲到）同样，排在下面的“买一”到“买五”是买家接受的愿意购买股票的单位价格，即买方出价（bid price）。显然买家愿意出尽可能低的价格，因此买价就被排在下方。</p>
<p>如果僵持在这个局面，卖方和买方就没有办法就价格达成一致意见，因此也就没有交易。假设这个时候有一个人来，想来购买这支股票，那么他就需要下单购买股票，下单主要有两种类型：限价单和市价单。</p>
<p><strong><u>限价单</u><strong>的意思就是我不仅给出我想购买多少收股票，而且给出我想以什么价格购买该股票。如果限价单的价格达到卖方最低的价格，在上面这个情况下，就是说如果挂出的限价单的价格大于等于19.88，那么你就能和刚刚在19.88价格上叫卖的卖家以19.88元的价格成交。需要注意的是，假如你挂出的限价单为以20.00元买一手，在上述情况下，你仍然会和挂在19.88元的卖家以19.88元成交。为什么会这样做呢？假想你是卖家，你挂在了一个更”实惠“的价格上，结果系统没把你的挂单给成交了，反倒去成交了叫卖价格更高的卖家，你肯定不高兴，对吧？因此，系统会优先成交挂单价格更优的挂单，对于卖家而言就是叫卖价格更低的挂单，这个就叫做</strong>价格优先原则</strong>。好了，在你挂出了这个限价单之后它就立即成交，那你就成功的买到了一手股票，但是你买到的这一手股票究竟是谁卖给你的呢？卖一档上之前显示有34手股票都希望被成交，你下了这一单之后只能有其中的一手股票被成交，那究竟是哪一手股票被卖给了你呢？根据<strong>时间优先原则</strong>，最先挂到这个价格上的卖单会最先被成交，所以其实这些卖单躺在订单薄中等着被带走，他们排了一个队，排在前面的先被带走。假设你限价单的价格没有达到卖方最低的价格，那么你的订单就会进入到系统的订单薄中。比如你挂出的限价单为以19.70元买一手，那么你的这个订单就会进入系统的限价委托薄中，在盘口上面你就会看到“买五”这一栏后面的数量就会增加1，变为11。当然，如果你的某个订单长时间躺在订单薄中没有被成交，你可以撤单，把这个订单撤销。</p>
<p>如果你下的单是**<u>市价单</u><strong>，那么基本上来说系统会帮你实时的查一个目前的“市价”，然后自动帮你申报。假设你下了一个对手方最优价格申报的市价单，那么系统就会帮你以目前“卖一”价下一个限价单。通常，按照市价申报的订单会很快被成交，但是也不是一定会被成交。比如，你刚刚下一个“对手方最优价格申报”的市价单，挂在了19.88元的价格上面，但是刚好不凑巧，卖一档上面的34手刚刚被成交了或者</strong>卖方刚刚撤了单，那么你的订单就变成了一个限价单**，以“买一”的身份躺在了订单薄中，再等待其他的卖家来主动卖给你。根据交易所的规则，市价单还有很多其他类型，但是大体意思与此类似，这里不一一介绍了。同样的，如果你希望卖出某个股票，也可以下限价单或者市价单，操作方式和买入类似。</p>
<p>严谨的同学可能就要问了，这样的撮合成交方式比较适合订单一个一个地来，这样系统就可以一个个的处理。但是在股市刚刚开盘的时候，大家的买卖意愿憋了一晚上，大家的订单就会在开盘的时候一股脑涌入交易所。同样，在收盘的时候，由于接下来的一个晚上甚至好几天都不能进行交易，大家也想赶着最后几分钟把想进行的买卖都做成，因此也会集中涌入较多的订单。这就有点像春运抢票的是刚刚放票的时候，大家都去12306上抢票，这时候网页就会变得特别卡顿甚至刷不出来；或者在学校澡堂洗澡的时候，同学们总会赶在最后的那半个小时挤着去洗澡。因此，在开盘和收盘的一段时间内就不再采用刚刚我们所说的**<u>连续竞价方式</u><strong>，而是采取我们接下来要讲的</strong><u>集合竞价方式</u><strong>。</strong>开盘集合竞价时间为开盘后的前十分钟，收盘集合竞价时间为收盘前的三分钟<strong>。集合竞价期间，交易所只接受限价单的申报，并且竞价期间结束之后再集中撮合成交。所有该阶段成交的订单价格都一样，所有高于此价格的买单和所有低于此价格的卖单都会被成交，刚好在此价格上的买卖单按照先后顺序撮合成交，直到其中一方被全部撮合成交。交易所就是要</strong>找到这样一个能够促成尽可能多交易的价格**。</p>
<p>咳咳，划重点了，在股票交易中买卖双方可以通过下限价单或者市价单来申报买卖股票。交易所使用竞价交易的方式来根据买卖双方的申报撮合成交，其中开盘和收盘的一小段时间中使用集合竞价的方式来撮合成交，其他时间使用连续竞价的方式来撮合成交。撮合交易遵循价格优先原则和时间优先原则。最后需要说的是，虽然这里只是讲了股票的交易规则，但是其规则和很多<strong>其他金融市场的交易规则都差不多</strong>，包括金融期货、商品期货、基金、甚至是比特币等虚拟货币。</p>
<h2 id="3-如何看懂行情软件显示的数据？"><a href="#3-如何看懂行情软件显示的数据？" class="headerlink" title="3.如何看懂行情软件显示的数据？"></a><strong>3.如何看懂行情软件显示的数据？</strong></h2><p>市面上有很多可以查看股票行情的软件，不管是电脑上的同花顺、大智慧，网页端的新浪财经、雅虎财经，甚至手机端的支付宝等软件都能够很方便地查看某只股票的行情。如果你打开这类行情软件，随便查询一只股票的，你都会看到与下面这张图类似的线。下图是我从同花顺软件上面截的图，但是其他软件也应该大同小异。 <img src="http://storage-uqer.datayes.com/564aee87f9f06c4446b4829b/cb33ff7e-88ba-11e8-9626-0242ac140002"><span class="image-caption">图片注释</span> 图：蜡烛图（平安银行 <a href="http://000001.sz/">000001.SZ</a>）</p>
<p>很显然，上面一部分的图指示的是该支股票的价格。我这里选择的是按照日频画图，所以图上每一根都代表一天的股价。最上端表示的是这一天该股票最高的成交价，最下端表示的是这一天股票最低的成交价。柱子最高端和最低端代表开盘价和收盘价。如果红色的，代表这一天的股价在上涨，因此柱子下端是开盘价，上端是收盘价；如果是绿色的，代表这一天的股价在下跌，这时柱子上端是<strong>开盘价</strong>，下端是<strong>收盘价</strong>。</p>
<p>下面一部分的图指示的是每一天的<strong>成交量</strong>，（高）的表面成交量大；反之，成交量就比较小。</p>
<p>很多软件还可以选择以不同的统计频率来画。如果以五分钟频率来画图，那么一根羊肉串代表的就是五分钟内的最高价（high）、最低价（low）、第一笔成交价（open）、最后一笔成交价（close）；如果以周或者月来画图，代表的就是每周、每月的相应信息。简言之，蜡烛图反映在某个采样频率下的”高开低收“价格信息。</p>
<h2 id="4-交易所规则：涨跌幅限制"><a href="#4-交易所规则：涨跌幅限制" class="headerlink" title="4.交易所规则：涨跌幅限制"></a><strong>4.交易所规则：涨跌幅限制</strong></h2><p>首先来介绍一下<strong>中国特色的涨跌幅限制</strong>，又称作涨跌停制度。其实很简单，一句话讲完了：限定挂单价格仅能在上一个交易日收盘价的上下10%以内（对于大多数股票）。这样的制度会产生什么样的效果呢？比如说，獐子岛（<a href="http://002069.sz/">002069.SZ</a>）某天晚上收盘之后发布公告说该公司投放到海底的扇贝苗现在全部找不到了，这样的新闻意味着这样一个靠卖扇贝的公司将无货可卖，公司就会亏损，该公司的股票就无法为股民带来收益，因此股价肯定会下跌。这样<strong>可能会引起股价下跌的消息</strong>称之为**<u>利空消息</u><strong>；反之叫做</strong><u>利好消息</u>**。这样的消息使得獐子岛公司的股票不再那么值钱了，假如前一天收盘价为20.00元&#x2F;股，这个消息爆出来之后，可能意味着该公司并值不到这么多钱，假如现在该公司股票合理的价格只值10元&#x2F;股。到了第二天，持有该支股票的股民通常会希望抛售手中的股票，因为之后的价格（10元&#x2F;股）比现在的价格（<del>20元&#x2F;股）低很多，所以对于卖家而言，只要价格高于其股票真实价格（10元&#x2F;股），能卖就卖了。为了让自己的股票尽可能快被卖出，他们会在能挂单的最低价格挂单，比如在18.00元&#x2F;股上。对于买家而言，除非价格跌落到正常水平（</del>10元&#x2F;股），他们都不愿意挂单购买。但是这一天他们能挂单的价格只能在18.00<del>22.00元&#x2F;股这个区间内，因此通常这一天没有买单挂出。假设真的是这样的情况，那么今天一笔交易也不会成交，今天就没有成交价，按照规定，今日的收盘价就会延续前一日收盘价，那么再下一个交易日仍然会限定在18.00</del>22.00元&#x2F;股这个区间内。但在通常的情况下，还是会有少数人在18元&#x2F;股的价格上来买入的，这样就能够把成交价拉低到18元&#x2F;股上。类似地，到了下一个交易日，该股能够挂单的股价区间就在14.4~21.6元&#x2F;股上。对于涨停来说也是与此情形类似。</p>
<p>总结一下，<strong>涨跌停发生通常由于与该公司或者行业有关的消息或者新闻导致</strong>，这些消息导致股票价格预期高于（或者低于）涨跌幅限制（通常为10%），由于交易所限制每日涨跌幅，因此只有少量的交易在昨日收盘价以上10%（或者以下10%）的价格上成交。由于成交量极少，我们称之为涨停板（或者跌停板）。</p>
<p>了解这样的制度对于我们的做量化来说有什么样的帮助呢？</p>
<p>我们后面会讲到，当我们形成了一个想法或者一个量化投资的策略的时候，我们会首先在历史的数据上检验我们的策略是否有效，即回测。在做回测的时候我们需要注意的是，在涨停的时候，虽然可能有一个成交价，但是实际情况下我们几乎不可能在这一个价格上买到股票；同理，在跌停的时候，我们也无法在历史数据中的成交价上卖出股票。因此，在回测的时候我们通常假定不能以涨停价格买入股票；不能以跌停价格卖出股票。</p>
<p>另外，我们注意到发生涨跌停的时候，其实际价格通常远高于或者远低于当前价格，通常需要通过好几个交易日的连续涨停或者跌停来达到均衡的价格。因此，当我们希望预测股票涨跌的时候，我们常常会根据统（ji）计（qi）规（xue）律（xi）抓住这个规律。即如果今天涨停，我就预测明天也涨停；如果今天跌停，我就预测明天也跌停。在这样的时候如果我们观察预测正确率会发现其结果可能比瞎猜好很多，但其实这部分正确率其实无法转化为真正的盈利。</p>
<p>图：涨停板（江南嘉捷 <a href="http://601313.sh/">601313.SH</a>） <img src="http://storage-uqer.datayes.com/564aee87f9f06c4446b4829b/c77f6fe8-88bb-11e8-9626-0242ac140002"><span class="image-caption">图片注释</span></p>
<h2 id="5-交易所规则：停复牌"><a href="#5-交易所规则：停复牌" class="headerlink" title="5.交易所规则：停复牌"></a>5.<strong>交易所规则：停复牌</strong></h2><p>刚刚我们了解了我们常常所说的涨停、跌停，其实我们可以看到，它们并不是真正的停牌，只不过价格的限制使得双方不能够以合适的价格来交易，不过在涨跌停的时候还是会有极小量的交易量的。那么真正的停牌是什么样的呢？**<u>停牌</u><strong>其实就是在某段时间整个交易日或者某个交易日的一段时间内禁止交易该股票。有些停牌会提前较长一段时间发公告通知什么时间会停牌，有些停牌会比较突然；有些停牌会提前通知复盘时间，有些停牌之后一段时间也不通知复盘时间。停盘的原因也比较多，比如涉嫌内</strong>幕交易、操纵市场，或者将发生影响股价的重大事件**等。</p>
<p>举个栗子，最近经常关注股市的同学一定会注意到最近一直大涨的江南嘉捷（<a href="http://601313.sh/">601313.SH</a>），其股价从2017年11月7日开始连续18个涨停，从之前不到10块钱的价格涨到现在的50多块。那为什么江南嘉捷会这样一路猛涨呢？原因就是它被360公司借壳，也叫做借壳上市。</p>
<p>借壳上市是什么意思呢？之前我们提到，一家公司如果想上市，需要进行IPO，并且需要满足证监会一系列的规定。但目前的情况来看，申请IPO的公司数量很大，证监会一年差不多也就能受理两三百家公司的IPO，如果现在申请IPO基本上需要两年才能够上市。上市需要经过等（pai）待（dui）、预披露、发审会（过会）才能等到最后的发行。通常来讲，这整个过程的完成需要两年多的时间，但也有等待了四五年才完成这个过程的公司。如果公司上市心切（急着用钱-.-），那么还有一个选择就是<strong>借壳上市</strong>。股市中总有一个公司上市之后营运状况堪忧，股价一靡不振的“垃圾股”，这些<strong>希望上市的新晋独角兽公司可以通过把这样的垃圾股公司买下来，然后继承它们的交易所席位</strong>。</p>
<p>一般来讲被借壳公司的股票价格在被借壳的公告发出之后都会直线上升。那你可能就要想了，这样重大的事项肯定会经过漫长的谈判，如果你潜入敌营守在谈判室门口，人家一出来你就通过读表情来判断谈判结果如何。如果你掐指一算，该公司要被借壳，就赶紧赶在公告发布之前下单买入该公司大笔股票，坐等火箭发射。这样岂不是美滋滋。然而这样的情况几乎不可能发生，因为当两家公司要坐下来谈判的时候，它们会先给交易所发停牌申请，先暂停股票的交易。等两家公司谈好了，再发布相应的公告，然后开盘交易。</p>
<p>就江南嘉捷这只股票来说，它披露将被360借壳之前就进行了长达半年的停牌。因此，如果想通过这样的小道消息来发家致富，你可能只能在半年之前夜观天象了。</p>
<p>PS.重大资产重组（借壳上市）有点像买个二手房，买到之后肯定还是会装修一下的。360公司马上也要来“装修”了，不仅将股票简称更名为“三六零”而且拿下来一个尾号360的股票代码（<a href="http://601360.sh/">601360.SH</a>）。哎，股票代码变更爽了公司领导，最后坑的还是我们这些数据清洗工，都不知道股票代码更换给我们带来多大的麻烦嘛╮(╯_╰)╭。</p>
<h2 id="6-交易所规则：除息除权"><a href="#6-交易所规则：除息除权" class="headerlink" title="6.交易所规则：除息除权"></a><strong>6.交易所规则：除息除权</strong></h2><p> 最后我们来介绍以下除息除权。对于股民来讲，除息除权最直接的体现就是某只股票突然某天的价格比前一天的价格少了很多，大多数情况可能是价格直接比前一天少了一半。发生这样的情况先别紧张，这里是发生了<strong>除息除权</strong>，它并不会让你的资产受损。除息（exclude dividend，XD）指的是<strong>分派利息</strong>；除权（exclude right，XR）中的“权”指的是股权，即<strong>分配股权</strong>；除息除权（dividend right，DR）指的是除息和除权同时发生。</p>
<p>先来说说<u><strong>除息</strong></u>。除息之前你<strong>购买的股票的价值包含公司的价值和公司的未分配利润</strong>，在除息发生的时候，公司按照你的持股比例<strong>把公司未分配的利润以现金的形式分发给你</strong>，相应地你持有股票就仅仅包含公司的价值了（可能还存在少量未分配利润）。既然股票内在价值发生变动，那么价格自然也会发生变动，价格变动为</p>
<p>除息参考价（每股） &#x3D; 前收盘价 - 每股现金红利 从公式中你可以看到，如果你持有该公司的股票，其实除息前后你的总资产其实并没有发生变化，只不过之前你的资金放在了股票中，现在一部分资金变成了现金。其实就是把一部分钱从左边口袋放到了右边口袋。</p>
<p>再来说说<u><strong>除权</strong></u>。除权通常可以分为股票股利分配（简称<strong>送股</strong>）、公积金转增股票（简称<strong>转股</strong>）和<strong>配股</strong>。前两个对股民来说没有太大的区别，它们和除息一样属于分红。最常见的形式比如10送5（10转5），其含义就是每10股股票送股5股（每10股转股5股）。假如手上有100股股票，发生送股（配股）之后，那么你手上就多出来了50股，你手中的股票数量就变为了150股。但其实你并没有占到便宜，因为相应的价格也会发生变动，价格变动为</p>
<p>除权参考价（每股） &#x3D; 前收盘价 &#x2F; （1 + 每股送股比例 + 每股转股比例） 配股稍有区别，配股的含义是给你一个权力能够以低于市价的某个价格优先认购一部分股票。举个例子来说，如果某公司股票价格为10元&#x2F;股，该公司发布公告以2:1的比例增股发行，新股发行价为8.5元&#x2F;股。如果你持有该公司的100股，那么你可以再花100 * (1&#x2F;2) * 8.5 &#x3D; 425元购买50股，这样你就拥有了该公司的150股股票，这150股的理论价值为10 * 100 + 8.5 * 50 &#x3D; 1425元。但其实你也没占到便宜，因为这时股票的参考价变动为1425 &#x2F; 150 &#x3D; 9.5 元&#x2F;股。</p>
<p>把除息除权这些事件全部写到公式中来即为</p>
<p>除权息参考价（每股） &#x3D; [ (前收盘价 - 每股现金红利) + 配股价格 * 每股配股比例] &#x2F; (1 + 每股送股比例 + 每股转股比例 + 每股配股比例) 最后，我们以一个实际的例子来复习一下除息除权。</p>
<p>以万科A（<a href="http://000002.sz/">000002.SZ</a>）2004年5月25日的一次除息除权为例（好不容易找了一个又有转送股又有派息的事件，虽然是十多年前的事件了）。该公司在2004年4月16日发布公告，要对2004年5月25日（股权登记日）持有该公司股票的股东进行分红，在2004年5月26日（除息日）进行分红。每10股送股1股，每10股转股4股，每股分派红利0.5元。我们观察到除息日前一日收盘价为7.32元&#x2F;股，我们可以加算一下除息权参考价(7.32 - 0.5) &#x2F; (1 + 0.1 + 0.4) &#x3D; 4.55元&#x2F;股，实际上下一日的开盘价为4.81元&#x2F;股。实际上我们计算的只是交易所用来计算除息权之后涨跌幅限制的<strong>参考价</strong>，市场对除息权之后股票的定价一般会在此价格上上下浮动。</p>
<p>图：除息除权（万科A <a href="http://000002.sz/">000002.SZ</a>） <img src="http://storage-uqer.datayes.com/564aee87f9f06c4446b4829b/d6fcae86-88bb-11e8-8122-0242ac140002"><span class="image-caption">图片注释</span></p>
<p>除息除权更多的意义反映在公司的会计和纳税的层面上，这里并不展开讲；另外，除息除权之后会使得公司的单股股价降低，更加吸引小散户的资金投入。了解除息除权对于我们做量化有些什么意义呢？</p>
<p>首先，我们在量化分析中肯定会用到股票的历史价格信息。如果直接使用这一的价格信息，就会发现<strong>股票的价格会因为除息除权事件而变得不连续</strong>，这对于我们量化分析十分不友好。因此我们会使用复权数据，就是在除息除权发生的时候把这一段gap给接起来。那我们是把之前的数据接到之后的数据上还是把之后的数据接到之前的数据上呢？其实两种做法都有。</p>
<p>如果<strong>把之后的数据接到之前的数据上就叫做后复权</strong>，后复权数据以该公司股票发行日为起点，只有股票发行日到其历史上第一次除息除权之间的价格是真实的价格，之后的价格都比真实价格更大。如果把之前的数据接到之后的数据上就叫做前复权，<strong>前复权数据通常以最新交易日为基准点，这样最近一段时间内的价格是股票的真实价格</strong>。</p>
<p>从维护复权数据的角度上来说，<strong>前复权数据更难维护</strong>。对于一只股票来讲，一旦某一天发生了除息除权，就需要把该股票历史上所有价格数据都进行一次更新；而后复权数据则不存在这样的问题，某一日的后复权数据一旦给定就永远不会再改变了。</p>
<p>然而通常来讲，最近的数据我们希望其保真度更高，前复权数据就具有这样的一个优势，因为前复权数据能够准确反映最近一段时间的真实价格和价格变动。从价格绝对数值的角度来讲，股票的绝对价格过高会增加散户投资的门槛。以现在茅台的价格为例，茅台收盘740.40元&#x2F;股，如果你想买入一手茅台需要花费将近七万五千块钱，对于小散户而言可能有些总共也就投个几万块来炒股，还不够买着一手茅台的。所以看来咱们小屁民不仅喝不起茅台，也买不起茅台股。因此，准确反映股票的绝对价格也是比较重要的。从价格变动的角度来讲，股票的最小价差为0.01元，因此我们通常四舍五入到第二位小数点就可以了；但是如果我们使用复权数据，对于高价股四舍五入后，总会有一段数据的价差与实际价差不一样。在这种情况下使用<strong>前复权数据就能更准确地反映最近的股市变化。</strong></p>
<p><strong>小结</strong></p>
<p>我们大致了解了公司如何上市和发行股票，了解了股票交易的订单薄、涨跌幅限制、停复牌和除息除权规则，还学习了如何读懂蜡烛图。</p>
<p>至此，当你搞懂了这些知识之后，你的知识水平已经达到<strong>我国股民的平均水平</strong>了。对于初步尝试做量化投资的同学来说，了解这些关于股市的规则已经足够了。如果还想进一步的了解股票交易规则和规定，建议去读一下**<u>深圳证券交易所规则或者上海证券交易所规则原文，以及其他相关的政策规定。</u>**</p>
<p>本文转自<a href="http://sealzhang.tk/">张楚珩的仓库</a></p>
]]></content>
      <categories>
        <category>量化交易</category>
      </categories>
  </entry>
  <entry>
    <title>量化投资入门2：量化投资概念和基本模型</title>
    <url>/2023/01/12/2.%E9%87%8F%E5%8C%96%E6%8A%95%E8%B5%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>几个过时但经典的盈利模型</p>
<span id="more"></span>

<h1 id="【第二讲：量化投资概念和基本模型】"><a href="#【第二讲：量化投资概念和基本模型】" class="headerlink" title="【第二讲：量化投资概念和基本模型】"></a>【第二讲：量化投资概念和基本模型】</h1><p><strong>目录</strong></p>
<p>1、传统投资与量化投资 </p>
<p>2、量化投资与有效市场假说</p>
<p> 3、再谈量化投资概念 </p>
<p>4、一种简单的量化模型：现代资产组合理论（MPT）</p>
<p> 5、进一步的量化模型：资本资产定价模型（CAPM） </p>
<p>6、更强大的量化模型：单因子模型和多因子模型（Factor Model） </p>
<p>7、再讲一个量化模型：套利与套利定价模型(APT）</p>
<h2 id="1-量化投资概念"><a href="#1-量化投资概念" class="headerlink" title="1.量化投资概念"></a>1.量化投资概念</h2><p><strong>传统投资与量化投资</strong></p>
<p>其实感觉标题这么起也不是很恰当，因为传统投资指的是什么方法也没有一个很明确的定义，投资的方法一直都在发展，姑且认为“传统”的就是非量化的其他投资方法吧。从名称上来说，量化投资中的“量化”指的就是数量化，就是需要定量的数据。个人总结，<strong>量化投资&#x3D;数据+模型</strong>，它包括量化<strong>择时和选股</strong>、<strong>套利、资产组合与风险管理</strong>和算法交易等。</p>
<p>传统投资主要基于个人的逻辑分析和判断。举个栗子来说，如果有一天你看了苹果的iPhone X发布会，觉得这个产品很牛，肯定大卖。产品大卖肯定会给公司带来可观的利润，紧接着你就去买了苹果公司的股票（NASDAQ: AAPL），等着产品大卖之后股票涨价，卖出股票赚得差价。再或者你觉得楼下彭阿姨买的煎饼果子味道独特，一直有很多回头客来购买，在未来的一两年内煎饼果子摊能扩大生产规模和盈利能力，于是你就去买了彭阿姨煎饼果子摊的股票（NASDAQ: JBGZ，误），以期获取收益。这样的投资方法主要靠投资者个人的推理和判断，并不经过太多的数值计算，我们称之为传统投资方法。大家都很熟悉的巴菲特（Warren Edward Buffett）就更多地采取这样的方法，其投资决定的形成当然也会基于一定的数据和调研，但是最后的决定主要还是由其个人的主观判断形成。当然，比较厉害的就在于其个人判断十分准确，因此取得了很好的投资业绩。不过并不是人人都有巴菲特的这样一个大脑，因此，这种方法可能会非常成功，但是不可复制。</p>
<p>而量化投资主要是基于数据和模型。举例来说，你观察了彭阿姨煎饼果子摊，通过煎饼果子摊资产定价模型，结合你调查到的该公司营业数据，算得该公司价值10w，该公司发行了1w股股票，平均每股价值10元&#x2F;股，但是目前该公司股价只有5元&#x2F;股，因此你觉得该公司股票有很大的上涨空间，因此去投资了该公司股票。指出一下，量化投资并不都像这样通过估计股票价值这样来预测股票未来的走势，也有其他的方式。在此领域成功的代表就是西蒙斯（James Harris Simons），如果按盈利能力来算，西蒙斯所管理的大奖章基金的年化收益率可能是巴菲特的两到三倍，并且在数次金融危机中都屹立不倒。其本人就是一名颇有建树的数学家，在转行做金融之后，也是建立了复杂的数学模型来进行量化投资。在赚了很多钱之后，还养了一帮数学家、物理学家做研究，毕竟物理学家好像也不是很贵（自嘲）。我们学校就有西蒙斯本人捐的一栋楼——陈-赛蒙斯楼，现在被用作外国专家楼。</p>
<p>图：陈-赛蒙斯楼（出处见水印） <img src="http://storage-uqer.datayes.com/564aee87f9f06c4446b4829b/d43bf3b8-8ee8-11e8-bfc5-0242ac140002"><span class="image-caption">图片注释</span></p>
<p>借用看来的一个比喻，说传统投资方法就像是中医，讲求的是望、闻、问、切，通过医生自己的经验和判断来给患者开方治疗；量化投资就像是西医，需要通过化验、拍片来确定患者的病灶，然后根据一套生理学的理论来给出治疗的方法。西医需要做的抽血化验、拍片检查就好像量化投资里面的数据，数据越准确，越可能得到更好的结论；西医中的生理学理论就好像量化投资中搭建的模型，根据化验检查的结果进行分析得到结论。所以我们常常看到，有很多老中医医术高超，但这种医术并不是刻意轻易学得来的，需要通过一带一的学徒制来传授。而西医讲究的是系统性的方法，可以通过在医学院的学习把这样的方法复制。</p>
<p>总结一下，传统投资方法就好比中医，通过较为主观的分析和判断来进行投资，可复制性较差；量化投资方法好比西医，关键在于数据和模型，通过数值计算来得到投资决策，具有较强可复制性。</p>
<p><strong>量化投资与有效市场假说</strong></p>
<p>根据投资的目的来分类的话，仅仅希望能够跟随市场平均水平的投资方式叫做被动投资，如果希望投资组合的收益能够超过市场表现，那么这种投资方式叫做主动投资。对于做主动投资的人来说，有效市场假说就好像洪水猛兽，因为它直接认定没有办法通过历史数据来获得超额收益。有效市场假说（efficient-market hypothesis）是由Eugene Fama于1970年提出的。他另外一个很有名的工作是Fama-French三因子模型，据说他拿这个模型赚了十多年钱，赚完了才把它公布出来，结果又得了个诺贝尔经济学奖。好了，我们回来讲一下这个<strong>有效市场假说</strong>。这个假说通过一些假设，推出了市场的定价一直处于一个有效的状态下，即<strong>市场上的定价已经综合反映了各方面的信息</strong>。既然市场定价已经综合反映了市面上的各种信息，那么我们再根据这些信息和历史规律来试图找到一个更为有效的定价就是徒劳的。有效市场假说直接<strong>否定了主动投资的可行性</strong>。</p>
<p>有效市场假说的想法是说假设股票有效价格的改变是由各种消息驱动的，好消息和坏消息的的到来是随机的。市场的参与者都是独立、理性并且追求利润的，因此当消息传播到市场上之后，这些参与者的投机行为就能够使得价格迅速恢复到新消息下的有效价位上。因此，在这个调节机制下，价格会保持合理，市场会持续有效。根据市场有效的程度，该假说还可以分为论断强弱不同的若干版本。在市场是<strong>弱式效率</strong>（weak form efficiency）时，我们无法从<strong>历史的价量</strong>中找到帮助我们盈利的规律；在<strong>半强式效率</strong>（semi-strong form efficiency）时，从<strong>公开渠道</strong>获得的所有信息都是无助于我们找到有用规律的；在强式效率（strong form efficiency）时，假说断定从<strong>任何渠道获得的信息</strong>都无法帮助我们盈利。</p>
<p>这样的假说听起来还挺令人沮丧的。但是个人认为有效市场假说中本身就肯定了肯定了理性市场参与者对于信息进行加工处理然后反作用于市场的作用，亦即正是由于这一部分人通过加工利用这些信息赚到了钱，才把价格拉回到了有效的位置上。如果我们能比其他市场参与者更加迅速地对于市面上的信息做出反应，就能获取相应的利润。从实证的角度上来说，股票市场确实会常常出现“不有效”的定价。A股市场的不有效现象更为明显，其主要原因还是参与者的成熟度离美股市场还有一定的差距，亦即<strong>我国股市的定价偏离的机会仍然较多</strong>，这也给量化投资以更多的机会。</p>
<p>回头看一下前面把量化投资比作西医的比喻还挺恰当的。量化投资所做的事情就是要找到市场的病灶，即<strong>市场定价不合理之处，然后通过投资并且盈利来纠正这样的不合理定价</strong>。</p>
<p><strong>再谈量化投资概念</strong></p>
<p>有好多名词大家常常和量化投资一起见到，比如说基本面分析、技术面分析、程序化交易等等，它们和量化交易又怎样的关系呢？</p>
<p>首先来讲讲基本面分析（fundamental analysis）和技术面分析（technical analysis）。**<u>基本面分析</u><strong>主要依靠</strong>公司财务数据<strong>和</strong>宏观经济数据<strong>，比较常见的公司财务数据有原始数据有公司的</strong>总资产、总负债、每股收益<strong>等，比较常见的宏观经济数据有</strong>GDP增速、国家外汇和黄金储备、货币供应量<strong>等。不过就基本面的定义而说，</strong>基本面还包括市面上的新闻、公告和舆情信息<strong>。而<u><strong>技术面分析</strong></u>主要依靠股票市场历史上的</strong>交易价格和成交量**，虽然其原始数据比较单调，但在技术面分析中却发展出了大量的分析手段，从价量数据中衍生出相当多的技术指标。</p>
<p>那么基本面分析和技术面分析和量化投资是什么样的关系呢？很多人认为量化投资主要是做技术面分析，其实确实如此，在量化投资领域所<strong>用到的技术面信息更多一些</strong>。在所利用的基本面信息中，也是更多的用到数量化的公司财务数据和指数化的宏观经济数据，而新闻、公告、<strong>舆情等信息的利用相对来讲不是十分充分</strong>。究其原因，相比于传统的量化而言，量化投资所需要的数据更倾向于数量化的数据，甚至是结构化的数据；另外，在传统量化中，由于主要靠人工来进行分析，希望数据量尽可能少而精，但与此相反，在量化投资中，我们更倾向于找寻数据中的规律，因此希望有更多的数据。基本面分析中所用到的新闻、公告、舆情信息不便于进行结构化和数量化，因此在目前的量化投资中用到的不多；基本面分析中所用到的财务数据由于其更新频率通常为季度甚至是年度数据，导致其数据量较少，也给其在量化投资中的应用带来了一定的困难。</p>
<p>总结一下，在量化投资中确实更倾向于利用技术面分析中的一些数据，但量化投资也会使用基本面分析中带给我们的数据；目前基本面分析中的信息利用的较少，是由于其使用上的困难，但个人认为将基本面分析中的信息放进量化投资框架中进行研究肯定是量化投资未来的发展方向之一。</p>
<p>那么量化投资是不是一定是程序化交易呢？</p>
<p>答案是不一定。量化投资讲的是一种投资分析的方法。完全可以通过量化投资得到一个结果，然后手动下单交易，并且目前在业界很多中低频交易策略（按星期或者月频率调仓）中，就是通过量化投资方法生成相应的交易方案之后，通过交易员来手动下单操作的。不过如果做出来的量化投资策略就是一个高频的交易，比如日内的择时，甚至是以秒为时间计量的高频交易，这样的策略如果靠人工操作就无法保证其对于量化策略的执行力，因此这样的策略最后一定是靠程序化交易的。</p>
<h2 id="2-几个基本量化投资模型"><a href="#2-几个基本量化投资模型" class="headerlink" title="2. 几个基本量化投资模型"></a>2. 几个基本量化投资模型</h2><h3 id="一种最简单的量化模型：现代资产组合理论（MPT）"><a href="#一种最简单的量化模型：现代资产组合理论（MPT）" class="headerlink" title="一种最简单的量化模型：现代资产组合理论（MPT）"></a><strong>一种最简单的量化模型：现代资产组合理论（MPT）</strong></h3><p>下面进入这一讲的重点，我们将要介绍一些最简单的量化模型。</p>
<p>现代资产组合理论（modern portfolio theory，MPT），是由Harry Markowitz在1952年提出的，他本人也是在38年之后获得了诺贝尔经济学奖。不过，在讲这个模型之前，我们先来讲一下风险。</p>
<p>我们常常说一个理性的投资人是追求利润并且厌恶风险的，所以理性的投资人一直在做的事情就是最大化利润，并且最小化风险。但是我们怎样来衡量风险呢？我们熟知的余额宝就属于风险比较低的理财产品，而股票市场就属于风险比较高的投资。但这样的认识是我们凭感觉得来的，我们能不能用什么办法具体地来计算相应的风险呢？答案是我们可以使用<strong>收益率序列的方差来表征风险</strong>。（还有其他表征风险的方式，<u>方差是一种最基本的方法</u>，见风险价值（VaR）是否是有史以来最蠢的衡量指标？）</p>
<p>举个栗子，我们可以查看一下余额宝（天弘基金）和平安银行股票（<a href="http://000001.sz/">000001.SZ</a>）近期的每日收益率（这里只是举例子，计算可能不科学，因为余额宝在非交易日也会有收益）</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20221226175016913.png"><span class="image-caption">image-20221226175016913</span></p>
<p>当我们要来评价相应的风险的时候就可以计算出两者实际的“风险”究竟是多少。余额宝收益率序列标准差为σ&#x3D;0.0123，平安银行股票收益率序列标准差为σ&#x3D;221.8064。（风险一般用<strong>方差var</strong>来表示，由于这个例子中其方差差距太大，因此就只写标准差）有了这样的数字我们就可以对于其“风险”进行比较了。</p>
<p>下面来讲一下MPT是什么。MPT中的portfolio中文叫做资产组合，资产组合是什么呢？假设市面上有n个可以进行投资的标的，一个资产组合可以表示为一个n维的向量P&#x3D;(w1,w1,⋯,wn)，向量的每一维代表该投资组合投资到相应标的的金额比例，且满足∑ni&#x3D;1wi&#x3D;1。</p>
<p>每个标的的收益ri都是一个随机变量。资产组合的<strong>收益rp</strong>也是一个随机变量，并且可以表示为rp&#x3D;∑ni&#x3D;1wiri。</p>
<p>刚刚我们说了，每个**标的的风险可以写成var(ri)&#x3D;cov(ri,ri)**。资产组合的的风险也可以写出来var(rp)&#x3D;∑ni&#x3D;1∑nj&#x3D;1cov(ri,rj)。</p>
<p>MPT这个理论要做的就是在<strong>达到期望收益的情况下，最小化投资风险</strong>。因此，对于一个理性的投资者来说，就是要解如下的一个优化问题</p>
<p>minvar(rp)&#x3D;∑i&#x3D;1n∑j&#x3D;1ncov(ri,rj) s.t.  E(rp)&#x3D;∑i&#x3D;1nwiE(ri)≥μ,  ∑i&#x3D;1nwi&#x3D;1 其中的μ就是预期的收益率。我们可以看出，给定一个预期的收益率μ，我们可以解到一个可以最小化风险的资产组合，并且可以得到该资产组合的风险。相应地，我们可以画出在MPT框架下的收益-风险曲线。这条曲线就是下图中的蓝线，也称作<strong>有效前沿（efficient frontier）或者马科维兹子弹（Markowitz bullet）。</strong> <img src="http://storage-uqer.datayes.com/564aee87f9f06c4446b4829b/01e4f350-8ee9-11e8-bfc5-0242ac140002"><span class="image-caption">图片注释</span></p>
<p>图中的红点为代表无风险利率，我们可以看到它的风险为0，收益为一个特定的值rf，可以简单地把它理解为银行存款利率。蓝线上绿色的点是这条线上<strong>夏普比率最高的点</strong>，这一点对应的资产组合称作**<u>市场组合</u>**（market portfolio）。夏普比率定义为相比于无风险投资的超额收益相对于所承受风险的比值</p>
<p>Sharpe&#x3D;E(rp)−rfvar(rp) 可以简单地这样理解，<strong>有效前沿上的资产组合</strong>是都是相<strong>应给定收益下风险最小的资产组合</strong>，而市场组合是有效前沿上投资收益-风险比（即投资效率）最高的资产组合。注意到，市场组合中不包括无风险资产。如果资产组合能够包括无风险资产，那么还可以组合出橙线以下区域的收益-风险配置，这条<strong>橙色的线我们称之为资本市场线</strong>（capital market line）。为什么这条线上的点可以通过加入无风险资产构建出来呢？简单来说，比如资本市场线上红点和绿点之间的线段，可以通过购买α比例的无风险资产再加上1−α比例的市场组合来得到。当α&#x3D;1时，全部购买无风险资产，在红点处；当α&#x3D;0时，就为市场组合，在绿点处。其实α还可以为负数，这时候相当于以无风险利率从市场借钱，然后购买更多的市场组合，对应的点就在绿点上方的射线上了。</p>
<p>敲黑板 1、我们使用方差来衡量风险 2、通过资产组合的配置可以降低风险，中和收益 3、有效前沿是在诸多有风险资产上配置资产组合能达到的最好情况，市场组合是其中投资效率最高的一个资产组合 4、资本市场线是加入无风险资产资产之后能够配置出来收益-风险特征的边界</p>
<h3 id="进一步的量化模型：资本资产定价模型（CAPM）"><a href="#进一步的量化模型：资本资产定价模型（CAPM）" class="headerlink" title="进一步的量化模型：资本资产定价模型（CAPM）"></a><strong>进一步的量化模型：资本资产定价模型（CAPM）</strong></h3><p>资本资产定价模型（Capital Asset Pricing Model，CAPM）是由Jack Treynor, William F. Sharpe, John Lintner和Jan Mossin等人<strong>在MPT基础上独立提出的</strong>，CAPM是可以由MPT推导出来的，但这里不做推导了，我们直接写公式。</p>
<p>CAPM表述的是任何一种<strong>风险资产的收益率相对于市场组合收益率之间的关系</strong></p>
<p><strong><u>E(rs)&#x3D;rf+βs(E(rM)−rf)</u></strong></p>
<p>rs表示某种风险资产的收益率，可以理解为某只股票的收益率；rf是无风险资产收益率；rM是市场组合收益率；**βs表示该风险资产相对于市场的敏感性，它的计算公式为βs&#x3D;cov(rs,rM)&#x2F;var(rM)**，它反映的是该风险资产收益随着市场组合收益波动的关联性大小。在牛市期间，如果买入βs&gt;1的股票，可能赚钱比市场平均收益更多的收益；在熊市期间，如果持有βs&lt;1的股票能够避免过多的损失，甚至如果某风险资产的βs&lt;0，则该风险资产能帮助你在熊市期间赚钱（比如股票的空头）。</p>
<p>我们来看一下βs的计算公式，其分母部分计算方法为var(rM)&#x3D;∑Ni&#x3D;1∑Nj&#x3D;1wiwjcov(ri,rj)，分子部分的计算方法为cov(rs,rM)&#x3D;∑Ni&#x3D;1wicov(rs,ri)。通常来讲，市场组合中的证券数目是相当大的。举例来说，A股市场的股票数目现在有三千多只，如果再加上期货、基金可能会有上万中投资标的。相应的分母部分需要计算N2量级个的协方差，运算量非常大。我们之后介绍的因子模型可以解决这样的问题。</p>
<p>总结一下，资本资产定价模型主要说的就是，在投资者都是风险厌恶的情况下，如果某个投资标的具有更大的风险，投资人会期望该投资标的能够带来更大的收益；反过来，如果某投资标的有更多的收益，那么它会承担更多的风险。<strong>收益和风险满足公式所描述的线性关系。</strong></p>
<h3 id="更强大的量化模型：单因子模型和多因子模型（Factor-Model）"><a href="#更强大的量化模型：单因子模型和多因子模型（Factor-Model）" class="headerlink" title="更强大的量化模型：单因子模型和多因子模型（Factor Model）"></a><strong>更强大的量化模型：单因子模型和多因子模型（Factor Model）</strong></h3><p>单因子模型的提出基于如下的想法，宏观经济的因素对于不同的风险资产的收益都产生影响，并且该影响会较大程度上影响风险资产的收益，如果能把该影响剥离开，就能够更好地来分析风险资产的收益。即认为风险资产的收益可以分解为</p>
<p>ri,t&#x3D;αi+βiFt+ϵi,t 其中</p>
<p><strong>α表示因子预期收益，</strong></p>
<p><strong>ri,t表示风险资产i的在t时刻的收益</strong>；</p>
<p><strong>Ft是某宏观经济影响因素</strong>，它对于不同的资产在同一个时刻都是相同的</p>
<p>；<strong>βi是该资产对于该宏观经济影响因素的敏感程度</strong>；<strong>ϵi,t是噪声&#x2F;残差</strong>，其期望为零。</p>
<p>举个例子来说，某股票A在持有初期的期望收益为5%，在持有期期间，GDP增速8%，GDP是影响该股票的唯一因素，它对于GDP增速的敏感程度为1.1。同时，在持有期间，公司发生了一件利好事件，使股价上升3%。则此时该公司收益为</p>
<p>rA&#x3D;αA+βAF+ϵA&#x3D;5%+1.1×8%+3%&#x3D;16.8% 如果我们还知道GDP增速的波动率σ2F&#x3D;1%，该股票噪声波动率σ2ϵ&#x3D;4%，则可以算出该股票的风险</p>
<p>σ2A&#x3D;βA²×σ2F+σ2ϵ&#x3D;1.21×1%+4%&#x3D;5.21% </p>
<p>注意到，单因子模型仅仅认为所有股票只受到一项宏观经济因素的影响，如果认为所有的股票受到多个互不相关因素的影响，那么自然可以写出**<u>多因子模型</u>**（目的：求因子暴露和αi）</p>
<p>ri,t&#x3D;αi+β(1)iF(1)t+⋯+β(K)iF(K)t+ϵi,t 一般称<strong>β为因子暴</strong>露，<strong>F为因子收益。</strong></p>
<p>当多因子模型包含的因子为宏观经济相关的内容时（比如国内生产总值、货币供应量、黄金和外汇储备等），这类宏观经济数据的基本形式就是一列<strong>与特定股票i无关的时间序列</strong>，我们通常把它们作为**<u>因子收益</u>**；</p>
<p>然后<strong>在每一只股票上做时间序列回归得到相应的<u>因子暴露</u><strong>。这时，因子收益代表的是宏观经济带来的全局性（也称系统性）的收益率，</strong>因子暴露代表的是该股票对于这一项宏观经济指标波动的敏感性。</strong></p>
<p>那时间序列回归怎么做？</p>
<p>把股票i固定的时候，去**<u>拟合</u>**如下方程</p>
<p>rt&#x3D;α+β(1)F(1)t+⋯+β(K)F(K)t 这时，该股票的收益率时间序列rt和诸多宏观经济时间序列F(k)t都已知，通过**<u>多元线性回归</u>就可以求到相应的α和β(k)** 通常多因子模型所包含的因子还可以为与特定股票相关的<strong>基本面或者技术面特征</strong>（比如该股票的近期趋势、市值大小、相对估值等），这类<strong>数据的基本形式是对于每一只股票，都有一个时间序列</strong>。比如常见的反映股票规模的因子股票总市值，具体来说就等于该股票的股价乘上该公司发行的总股数。这个因子每天对于每只股票都会有一个数值。这时，相应的多因子模型就写作</p>
<p>ri,t&#x3D;βt+X(1)i,tf(1)t+⋯+X(K)i,tf(K)t+ϵi,t 这时因子暴露X(k)i,t代表的就是该股票这个时刻在某种风险上的暴露。举例来说，我们都知道一家小的公司比一家大公司有更大的倒闭风险（即市值风险），因此，如果股票总市值这个因子数值越小，就说明该公司更多地暴露在市值风险上，即更容易因为战乱、政府政策等外部原因倒闭或者亏损。既然小市值的公司承受了更大的风险，那么根据风险溢价的原理来说，小市值公司的收益率期望就会更高。那么<strong>减小每单位的市值</strong>，市场上的投资者希望收回多少额外的收益呢？这件事情就<strong>由相应的因子收益来衡量</strong>了。因子收益如何得到呢？我们一般通过横截面回归来得到相应的因子收益。</p>
<p>那么**<u>横截面回归</u>**怎么做？（目的：求收益。所以要固定t）</p>
<p>把同一个时刻或者一段时期中的不同数据点拿过来，拟合如下方程，就是横截面回归。这个时候，时间参数t就是固定的了。</p>
<p>ri&#x3D;β+X(1)if(1)+⋯+X(K)if(K) 其中不同股票的<strong>收益率ri</strong>和每只股票在此时的<strong>因子暴露数值X(k)i</strong>是<strong>已知的</strong>，通过多元线性回归得到相应的α和f(k) 补充两点说明（如果怕被搅晕可以不用看），</p>
<p>我没有统一这两种模型的记号，原因是写了之后懒得改了（误），这样的记号比较约定俗成（误），其实书籍论文、券商研报的记号也是鱼龙混杂，大家抓住实质就好。 对于第二种模型来说，虽然我纠结再三还是在β和f下加上了脚标t，但是我们假定它们在一段较长的时期内是不变化的。即它们随时间变化的速度比因子暴露X随时间的变化慢很多。 最后再补充一点（如果还没有被搅晕那就继续往下看吧）</p>
<p>多因子模型该如何应用？</p>
<p>先说一句，大家通常用<strong>α表征特质性收益，用β表示系统性收益</strong>。而大家常常说，Alpha是量化投资的圣杯，大家做的就是去找Alpha。就我们这个模型而言怎样找Alpha呢？</p>
<p>对于第一种模型来说，如果要<strong>选股，可以选择单股特质收益αi比较高的股票</strong>，这表明该<strong>股票在剥离掉宏观经济影响因素之后，仍然有较高的收益率</strong>；如果要做资产组合，那么可以找一个资产组合是的该资产组合中的α按比例加起来大于零，并且对于每一项β按比例加起来都等于零，其含义就是该资产组合不受到所有外部宏观经济的影响，纯靠自己的特质赚钱。简言之，就是<strong>抵消Beta，找到Alpha</strong>。</p>
<p>对于第二种模型来说，外部系统的风险都集中反映到截距项βt中（这也是为什么我们在这里用β），而<strong>股票特质性的收益被分解到了后面的X(1)i,tf(1)t+⋯+X(K)i,tf(K)t中</strong>。因此，我们要做的就是<strong>找到后面这一坨算出来的数值最大股票</strong>。这些因子就叫做Alpha因子，对应的这一坨就称为Alpha收益。</p>
<p>当然，随着市场上根据这个模型来操作的玩家越来越多，一旦一种因子暴露X(k)的计算方法被大家都知道了，大家就会通过相应的投资作用于市场，这个时候，相应的因子收益f(k)就会被市场上使用这个因子的玩家一点点吃掉。当该因子被完全吃掉的时候，该因子的因子收益会接近于零，这个时候，该因子就失效了。当该因子失效之后，该因子就不能再作为Alpha因子了。再多说一句，<strong>对于一个失效的因子来说，在较长的时间段内做横截面回归，相应的因子收益f接近于零；如果在跨度较短的每个横截面都做回归，得到一系列的因子收益ft，它的均值接近于零。</strong>对失效的因子来说，其因子收益ft均值接近于零，但是它在每个小的横截面上的的数值绝对值都很大，那么我们可以把它们作为风险因子保留在模型中。风险因子对应的收益我们称之为Beta收益。</p>
<p>如果我们的因子都被吃掉了那该怎么办？我们需要<strong>从残差项中发掘出新的因子</strong>，如果新的因子加入之后，总体的残差变小，说明新的因子对于股价具有解释能力。如果这个因子对应的因子收益ft能够很稳定地朝同一个方向偏离零，那么这个因子就能够作为一个Alpha因子了，其对应的收益就为Alpha收益。对于选股而言，我们就可以选出Alpha收益更大的股票。对于构建资产组合来说，我们可以找一个资产组合是的其Alpha收益按资产组合的比例加起来最大，并且其Beta收益按比例加起来为零。</p>
<p>刚刚讲的这两种模型对应的构建资产组合的方法都是最大化Alpha收益，并且尽量抵消掉Beta收益，这样的做法就叫做Alpha策略。</p>
<p>为什么大家希望抵消Beta收益呢？因为这里大家假设宏观经济更难以预测，而对于单个股票或者对于单个因子的预测更有信心。当然，如果你对于宏观经济十分了解，能够很好地预测宏观经济的走向，那么你就去赌beta，一样可以赚钱。比如，你预测未来宏观经济走势较强、社会局势稳定、工业发展迅速，那么小市值因子（现在认为它是一种风险因子，并且注意我说的是“小”市值因子）对应的因子收益就会大于零，那么你就去买小市值股票，赚钱Beta收益。</p>
<p>假设市场上投资标的个数为N，研究的时间截面个数为T，因子个数为K。刚刚说到<strong>CAPM要计算某只股票的期望收益就需要计算该支股票的βs，大概需要计算N^2个协方差</strong>，每个协方差的计算为两列长度为T的序列。在多因子模型中，如果需要计算计算某只股票的期望收益只需要做K维线性回归。对于时间序列回归来说，输入为K+1个长度为T的序列；对于横截面回归来说，输入为K+1个长度为N的序列。通常K比N要小很多，因此<strong>多因子模型相比于CAPM，计算量减小了很多。</strong></p>
<p>总结一下，多因子模型分为两类。一种是使用<strong>宏观经济因素来作为因子的模型</strong>，这种模型可以<strong>直接得到因子收益</strong>，通过时间序列回归得到因子暴露；另一种是使用表征股票特征的<strong>基本面或者技术面因素来作为因子的模型</strong>，这种模型可以<strong>直接得到因子暴露</strong>，通过横截面回归得到因子收益。(宏观：已知因子收益求因子暴露。基本面：已知因子暴露求因子收益)</p>
<p>第一种： ri,t&#x3D;αi+β(1)iF(1)t+⋯+β(K)iF(K)t+ϵi,t 第二种： ri,t&#x3D;βt+X(1)i,tf(1)t+⋯+X(K)i,tf(K)t+ϵi,t</p>
<h3 id="再讲一个量化模型：套利与套利定价模型（APT）"><a href="#再讲一个量化模型：套利与套利定价模型（APT）" class="headerlink" title="再讲一个量化模型：套利与套利定价模型（APT）"></a><strong>再讲一个量化模型：套利与套利定价模型（APT）</strong></h3><p><strong><u>套利</u><strong>（arbitrage）是利用同一种或者相似的实物资产或金融资产的不同价格来</strong>获取无风险受益</strong>的行为，是通过买入收益率偏高的证券同时卖出收益率偏低的证券来实现的。勾一下重点就是<strong>同时买入和卖出</strong>。比如说，你看到学校食堂里面的鸡蛋七毛钱一个，同样的鸡蛋在学校大门外要买一块钱，那你就从食堂买来鸡蛋立马跑到校门外去卖掉，这个就是套利。假如你要是买来一堆鸡蛋，先屯着不卖，等过年鸡蛋涨价的时候再卖，这种赚钱的方式就不属于套利。</p>
<p>套利定价模型（arbitrage pricing theory，APT）讲的是一个理想的市场条件下各个证券定价应该满足的表达式。这里所说的理想市场条件指的是市场没有交易成本，同时市场中的交易者都是回避风险并且对于证券的预期报酬有一致性看法。那么证券定价就满足以下表达式</p>
<p>ri&#x3D;αi+β(1)iF(1)+⋯+β(K)iF(K)+ϵi 这里的表达形式和参量代表的含义其实质与我们之前讲的多因子模型是一样的，只是由于这里<strong>不考虑时间序列的特性，因此省略了时间下标</strong>。不过需要注意的是，对于每只股票的β而言，还是需要像多因子模型一样，通过时间序列回归来得到。</p>
<p>如果一个资产组合**<u>满足以下三点要求，我们就称之为套利组合</u>**（arbitrage portfolio）</p>
<p><strong>初始投资为零</strong>，即对投资组合P&#x3D;(w1,⋯,wN)有∑Ni&#x3D;1wi&#x3D;0 </p>
<p>投资<strong>组合的风险为零</strong>，风险分为系统性风险和非系统性风险。系统性风险为零即对于任意的k∈[K]，∑Ni&#x3D;1β(k)iwi&#x3D;0；非系统风险则要求投资的种类足够多和分散，由大数定理就能够得到∑Ni&#x3D;1wiϵi&#x3D;0 </p>
<p>当然最重要的一点就是<strong>盈利为正</strong>，即∑Ni&#x3D;1wiri&#x3D;0，结合前两条，有∑Ni&#x3D;1wiαi&#x3D;0 </p>
<p>当市场上存在这一的套利组合的时候，我们就说这个市场上存在套利机会。</p>
<p>举一个例子，假如市场上有三只股票，分别是A、B、C，我们暂时只考虑一个宏观经济的影响因素，这三只股票的收益率和它们对该因素的敏感程度如下表所示</p>
<p>股票	收益率	敏感程度</p>
<p>A	12%	1.0 </p>
<p>B	25%	3.5 </p>
<p>C	15%	2.0 </p>
<p>那么这样的一个市场是否存在套利机会呢？我们可以看到，通过构建一个套利组合P&#x3D;(0.3,0.2,−0.5)，可以实现投资总额∑Ni&#x3D;1wi&#x3D;0.3+0.2+(−0.5)&#x3D;0，同时，系统性风险∑Ni&#x3D;1wiβi&#x3D;0.3×1+0.2×3.5−0.5×2.0&#x3D;0。但是总的收益∑Ni&#x3D;1wiri&#x3D;12%×0.3+25%×0.2+15%×(−0.5)&#x3D;1.1%&gt;0。</p>
<p>因此，这样的市场存在套利机会，通过构建这样的组合，我们可以在没有系统性风险的情况下获得1.1%的期望收益。</p>
<p>不过需要提一下的是，套利定价模型只是给我们提供了一个这样的框架，这样的套利组合是否真正地能够盈利其实更多地取决于你把什么东西当做因子填到公式中，<strong>如果你选定的一组因子对于交易者对于证券的预期有很好的解释能力，那么你找到的套利机会才是“真”套利机会。</strong></p>
<p><strong>小结</strong></p>
<p>这里简单介绍了量化投资的概念，并且介绍了一些基本的量化投资模型，<strong>量化投资的模型都试图定量解释投资标的的收益率。</strong>这些模型都有着共同的特征，<strong>他们都把资产收益率与其他的因素建立起了线性的联系</strong>，虽然<strong>线性关系是一种最直接、最简单的定量关系，但是在历史上，这样的模型却常常是十分有效的</strong>。像我们这一讲里面提到的MPT、Fama-French三因子模型等都是诺贝尔奖级的工作。当然，金融市场里面是否存在非线性的关系呢？个人认为答案是肯定的，但是就目前来说，线性模型还是业界量化投资的主力。随着线性模型带给我们收益的一步步枯竭，非<strong>线性模型可能会成为之后量化模型的探索方向。而机器学习领域已经发展出来许多较为成熟的非线性模型</strong>，机器学习中的非线性模型将会以怎样的方式应用到量化投资领域呢？我将会在第四讲中来聊一聊。</p>
<p>本文改编学习自<a href="http://sealzhang.tk/">张楚珩的仓库</a></p>
]]></content>
      <categories>
        <category>量化交易</category>
      </categories>
  </entry>
  <entry>
    <title>量化投资入门3：如何开展量化投资研究</title>
    <url>/2023/01/13/3.%E9%87%8F%E5%8C%96%E6%8A%95%E8%B5%84%E6%95%B0%E6%8D%AE%E3%80%81%E5%9B%9E%E6%B5%8B%E3%80%81%E8%A1%A1%E9%87%8F%E6%8C%87%E6%A0%87%E5%92%8C%E5%AE%9E%E7%9B%98/</url>
    <content><![CDATA[<p>整体把握开发一个挣钱策略的思路</p>
<span id="more"></span>

<h1 id="【第三讲：如何开展量化投资研究？】"><a href="#【第三讲：如何开展量化投资研究？】" class="headerlink" title="【第三讲：如何开展量化投资研究？】"></a>【第三讲：如何开展量化投资研究？】</h1><p><strong>目录</strong></p>
<p> 1、需要哪些数据？——巧妇难为无米之炊</p>
<p> 2、怎样测量策略的性能？——搭建回测系统</p>
<p> 3、怎样衡量量化策略的好坏？——一箩筐统计指标</p>
<p> 4、开始挣钱！——从回测到实盘</p>
<p>现在市面上出现了很多供大家进行量化投资研究的网站，比如<a href="https://link.zhihu.com/?target=https://uqer.io">优矿 - 大数据时代的量化投资 - 通联量化实验室</a>、<a href="https://link.zhihu.com/?target=https://www.joinquant.com">JoinQuant聚宽量化交易平台</a>、<a href="https://link.zhihu.com/?target=https://bigquant.com">BigQuant - 人工智能量化投资平台</a>、<a href="https://link.zhihu.com/?target=https://www.ricequant.com">RiceQuant米筐量化交易平台</a>)等，几乎清一色地在底层使用Jupyter Notebook环境来供大家进行量化投资研究。这些网站通常都为大家提供一些基本的量化投资所需要的数据，教大家使用一些基本的量化模型，并且提供封装好的数据接口、回测接口，甚至模拟盘和实盘接口。</p>
<ul>
<li>突然发现京东也开始做量化投研了，跑去看了一下，大公司做的至少示例代码至少比其他家的规范。链接<a href="%5B%E5%A4%9A%E5%BF%AB%E5%A5%BD%E7%9C%81%EF%BC%8C%E8%B4%AD%E7%89%A9%E4%B8%8A%E4%BA%AC%E4%B8%9C%EF%BC%81%5D(https://link.zhihu.com/?target=https://quant.jd.com)">JD Quant</a>。（更新，好像据说京东的这个要凉凉了？）</li>
</ul>
<p>在这些网站上进行量化投资的研究可以帮助大家很快速的了解量化投资的过程，把大家从繁琐的数据清洗、系统搭建中解放出来，能把更多的精力投入到策略的开发上来。但是其坏处就是，数据和回测等的封装让大家很难去了解到量化投资的工作细节，但是如果要想真正真枪实弹去市场上挣钱，除了有很好的想法之外，拼的就是这些细节。<strong>因此，要想严肃地来做量化投资研究，肯定还是需要自己对于这些底层的细节进行一定的了解。</strong></p>
<p>个人并不反对在上面列举的这些第三方量化投研网站上面进行研究，不过这里主要讲一下如何自己在本地开展量化投资的研究。</p>
<p>量化投资的开发流程一般是：回测-模拟盘-实盘测试-实盘运行，我们这里主要讲第一个。</p>
<h1 id="1-需要哪些数据？——巧妇难为无米之炊"><a href="#1-需要哪些数据？——巧妇难为无米之炊" class="headerlink" title="1.需要哪些数据？——巧妇难为无米之炊"></a>1.<strong>需要哪些数据？——巧妇难为无米之炊</strong></h1><p>首先，讲一下我们可能用到的数据类型有哪些。可能用到的主要有以下几类数据： </p>
<p>1、历史日行情数据：即提供历史上每天每只股票的高开低收等价格信息以及成交量相关的信息，这也是量化中最基础的数据。通常能提供历史日行情数据的，几乎都能在当天交易日收盘之后提供更新的数据，因此也是实时更新的日行情数据。 </p>
<p>2、历史日内行情数据：即能提供历史上每一天中间更为细节的价量信息，通常为5分钟一个数据点，也有一分钟甚至半秒频率的数据。每个数据点的形式一般为该数据点代表时间段内的一个价量综合统计，包含高开低收和成交量信息。 </p>
<p>3、历史分笔数据：即历史上每一笔交易的明细，每一个数据点是一笔交易，记录了每一笔成交的价格、数量、时间等信息，是记录<strong>实际成交信息</strong>最为细致的数据。 </p>
<p>4、历史限价委托薄数据：记录了历史上每一个时刻限价委托薄的快照，每一个数据点代表一个时刻，每个数据点之间的间隔通常较小，比如0.5秒。每个数据点包含该时刻十档（或者五档）报价和挂单量等数据。限价委托薄数据是市面上反映<strong>盘口信息</strong>最为细致的数据。 </p>
<p>5、历史财务报表数据：提供各个公司所发布的财务报表数据，用于计算一些<strong>基本面因子</strong>。 </p>
<p>6、历史日度因子数据：提供历史上计算好的一些基本面和技术面因子，第三方提供的基本面和技术面因子通常都是一些<strong>市面上公开的因子</strong>。 </p>
<p>7、其他辅助数据：包括指数数据、指数成分数据、行业板块概念分类数据、个股基本信息等。 </p>
<p>8、其他特色数据：包括公告数据、新闻舆情热度数据、宏观经济数据等。 </p>
<p>如果只是做回测，使用以上的数据就足够了，但是如果策略开发进行到了模拟盘甚至实盘的步骤，除了需要一个交易接口供你发出下单指令之外，你还需要以上<strong>数据的实时接口</strong>。因此，以上数据都对应相应的实时版本，这里不再一一介绍。需要注意的是，真正的实时分笔数据和实时限价委托簿数据好像交易所是不让分发的，大家看到的一般是延迟过后的数据。虽然以上很多数据都能找到免费的来源，但当你真正想要实盘的时候，还是<strong>建议去购买相应的数据</strong>，毕竟要是数据出了问题导致亏了钱，也是很心痛的。</p>
<p>下面介绍一些数据的来源。</p>
<ul>
<li><a href="https://link.zhihu.com/?target=http://tushare.org">Tushare -财经数据接口包</a>：是一个免费、开源的Python接口，提供准实时和历史的行情，对于使用Python来开发的同学来说，使用起来比较方便。其工作原理是从本地出发抓取新浪财经的数据，因此延时较大。有几家量化投研网站的支持，数据源应该不会用一段时间就没了。提供除了上面3、4、6之外的数据。</li>
<li><a href="https://link.zhihu.com/?target=https://github.com/shidenggui/easyquotation">Github: easyquotation</a>：和上一个类似，是Github上面一个开源的Python工具，在本地抓取新浪财经、腾讯财经等数据源的数据。我没有用过。</li>
<li><a href="https://link.zhihu.com/?target=http://www.wind.com.cn">万得资讯</a>：万得资讯也叫做wind，是业界认可度比较高的一家行情数据提供商，提供的数据也很全。好像有学生试用版，不过要是购买正式版的话还是很贵的。使用Wind可以把数据下载到本地再进行研究，也可以直接调用它提供的接口，我记得有Excel、C++和Python的接口。</li>
<li><a href="https://link.zhihu.com/?target=http://www.gildata.com">恒生聚源</a>：与万得资讯类似，也是收费的。数据库很全面。</li>
<li><a href="https://link.zhihu.com/?target=http://www.gtarsc.com/Home/Index">国泰安</a>：与万得资讯类似，也是收费的。个人没用过，不过看了一下，感觉数据很全面。</li>
<li><a href="https://link.zhihu.com/?target=https://mall.datayes.com/dashboard?lang=zh">通联数据</a>：特点在于除了提供基本的行情和财务信息之外，还提供很多它自己计算好的因子数据。通联数据商城中有些数据是免费的或者免费试用的，不过还有很多数据是需要购买的。</li>
<li>有些第三方的量化投研网站是没有禁止你把相关数据下载下来的，你可以直接从上面下载。</li>
</ul>
<h1 id="2-怎样测量策略的性能？——搭建回测系统"><a href="#2-怎样测量策略的性能？——搭建回测系统" class="headerlink" title="2.怎样测量策略的性能？——搭建回测系统"></a><strong>2.怎样测量策略的性能？——搭建回测系统</strong></h1><p>有了数据之后，当然下一步是计算因子、建立模型并且设计交易策略了。因子、模型和策略这么重要的东西当然不会放在这一讲里面了(^o^)&#x2F;~。在经过这些步骤之后就能够进行回测了，概括起来流程如下图所示。 <img src="http://storage-uqer.datayes.com/564aee87f9f06c4446b4829b/ba3ff2a6-9493-11e8-8cfa-0242ac140002"><span class="image-caption">图片注释</span></p>
<p>在这里，<strong>因子</strong>指的是利用数据构建的另一些可以<strong>直接用于模型的输入的数据</strong>；<strong>模型</strong>指的是利用算出来的因子和&#x2F;或一些原始数据来得到一个<strong>对于个股&#x2F;时间点进行的评分</strong>，即输入是因子&#x2F;数据，输出是评分；<strong>策略</strong>指的是根据模型输出的结果，来优化<strong>决策形成资产组合的配置</strong>。</p>
<p>股票市场的量化中，最为常见的就是每周调仓（或者说每几天调仓），在这种情况下，模型的目标就是每天选出五日期望收益率比较高的股票，策略的目标就是给出是的收益最大化的买卖股票列表和相应的数量。举个例子来说，模型的输入通常是这样的一堆数据 </p>
<p><img src="https://pic4.zhimg.com/v2-bae8a154c9c24e0f270b905866166947_b.jpg"><span class="image-caption">img</span></p>
<p>模型的输出通常是这样的数据，同时这样的数据也是策略的输入</p>
<p><img src="https://pic3.zhimg.com/v2-1929896d10c40db8e3f0671b7c68d136_b.jpg"><span class="image-caption">img</span></p>
<p>策略的输出是这样的数据</p>
<p><img src="https://pic2.zhimg.com/v2-fb2f2021375cd87e75eda5943cb249a9_b.jpg"><span class="image-caption">img</span></p>
<p>当有了策略的输出之后，下一步就是看一看回测效果如何。当然，如果策略是由模型输出简单生成的，我们也可以直接把模型的输出当做回测程序的输入。</p>
<p>最简单的回测程序一般就直接把每一期选出来的资产组合的权重向量<strong>w</strong><em>i</em>和这一期到下一期之间每只股票的收益向量<strong>r</strong><em>i</em>相乘即可，即，每一期投资组合的收益<strong>r</strong>P*,<em>i</em>&#x3D;<strong>w</strong><em>T**i</em>⋅<strong>r</strong><em>i</em> 。但是这样简单的回测方式只能用于大致观察模型或者策略的效果，由于其得到结果的精度较差，无法用于对于模型和策略的定量分析。要想准确地测模型和策略的表现，就需要搭建一个比较完善的回测系统。</p>
<p>一个较为完善的回测系统需要满足以下的一些需求。</p>
<p>1、能够指定股票池选股（比如选股范围可以为沪深300、中证500、中证800或者全市场选股，前三个可以分别使用000300、000905、000906成分股作为股票池） </p>
<p>2、能够指定选择或者剔除ST股票 </p>
<p>3、处理停牌和退市：停牌期间该部分股票不能交易，退市之后按照退市规定处理手中相应的股票 </p>
<p>4、处理涨跌停：涨停不能买入、跌停不能卖出，指定能不能涨停卖出、跌停买入 </p>
<p>5、指定使用当日的哪一个价格来交易：twap、vwap、open还是close </p>
<p>6、计算交易成本（印花税、手续费、冲击成本） </p>
<p>7、每个调仓日股票先卖出再买入，每个交易日进行资产结算（仓位一般按照该日收盘价结算） </p>
<p>8、如果输入是策略的输出，即已经指定好了目标持仓的配比，那么就根据往以该持仓为目标去进行模拟交易；如果给定的输入是模型的输出，通常先把该交易日模型预测出来的得分进行排序，然后选择排名靠前的股票来做多（也可以选排名靠后的做空） </p>
<p>9、回测程序输出净值曲线、交易明细、每日持仓明细，净值曲线是回测最重要的输出，后两者是为了具体地查看最后生成策略的细节 </p>
<p>看了这么多是不是手痒痒了，快自己写一个回测程序吧。</p>
<h1 id="3-怎样衡量量化策略的好坏？——一箩筐统计指标"><a href="#3-怎样衡量量化策略的好坏？——一箩筐统计指标" class="headerlink" title="3.怎样衡量量化策略的好坏？——一箩筐统计指标"></a>3.<strong>怎样衡量量化策略的好坏？——一箩筐统计指标</strong></h1><p>前面讲到量化的初步流程依次有因子计算、模型、策略、回测，最后输出了净值曲线。为了衡量整个流程的好坏，通常可以由净值曲线计算得到一些统计量，通过这些统计量来衡量整个量化流程的好坏。</p>
<p><strong>策略收益</strong>（Total Portfolio Return） 对于一个策略来说最重要的衡量指标就是该策略的盈利能力，策略收益是最为直接的反映策略绝对盈利能力的指标。 <img src="http://storage-uqer.datayes.com/564aee87f9f06c4446b4829b/85896342-957b-11e8-8cfa-0242ac140002"><span class="image-caption">图片注释</span> 其中Pi是策略最初的资产总量（包括股票总价值加上现金)；Pf是策略最后的资产总量。</p>
<p><strong>策略年化收益</strong>（Annualized Portfolio Return） 策略A的净值十年翻了一倍，策略B的净值一年就翻了一倍，但是他们的策略收益是一样的。这样比较显然不公平。换句话说，对于不同回测区间长度上的回测来说，需要在同一个尺度上比较，即看一看他们折合下来一年能赚多少。 <img src="http://storage-uqer.datayes.com/564aee87f9f06c4446b4829b/8b38fd34-957b-11e8-8cfa-0242ac140002"><span class="image-caption">图片注释</span> 其中n是回测期间的交易日天数，250是一年的交易日天数。</p>
<p><strong>策略年化波动率</strong>（Annualized Portfolio Volatility） 衡量策略的波动，定义为策略每年的收益率的波动范围 <img src="http://storage-uqer.datayes.com/564aee87f9f06c4446b4829b/93d97504-957b-11e8-bfc5-0242ac140002"><span class="image-caption">图片注释</span> 其中，Rp表示策略的收益率序列，Rp,i表示收益率序列中的每一个分量，R¯p表示收益率序列的平均值，n是回测期间的交易日天数。</p>
<p><strong>策略年化下行波动率</strong>（Annualized Downside Portfolio Volatility） 对于我们做做量化投资来说，如果收益率“往上”波动，其实我们并不介意，谁会介意多挣点钱呢？我们真正担心的“风险”其实是是下行风险，即收益率“往下”波动的情形。因此我们使用策略年化下行波动率来衡量下行风险。</p>
<p><img src="http://storage-uqer.datayes.com/564aee87f9f06c4446b4829b/995d5ac2-957b-11e8-bfc5-0242ac140002"><span class="image-caption">图片注释</span></p>
<p>其中指示函数 I(x)&#x3D;{1x is True 0x is False</p>
<p><strong>基准收益</strong>（Total Benchmark Return） 除了直接比较策略的绝对收益之外，我们通常也关心在回测的这回测区间中整体的市场环境，即使用基准收益来衡量整体的市场环境。通常选用这个时期中某一个成分指数来作为基准，成分指数通常可以选择沪深300指数、中证500指数、中证800指数等，当然也可以选择这些成分指数对应的股指期货净值来计算。 <img src="http://storage-uqer.datayes.com/564aee87f9f06c4446b4829b/9e31a260-957b-11e8-bfc5-0242ac140002"><span class="image-caption">图片注释</span> 其中Ii是回测开始时的基准（指数或者股指期货净值）；Pf是回测结束时的基准。</p>
<p><strong>基准年化收益</strong>（Annualized Benchmark Return） 类似地，有基准年化收益 <img src="http://storage-uqer.datayes.com/564aee87f9f06c4446b4829b/a24f50c2-957b-11e8-8cfa-0242ac140002"><span class="image-caption">图片注释</span></p>
<p><strong>基准年化波动率</strong>（Annualized Benchmark Volatility） 类似地，有基准年化波动率 <img src="http://storage-uqer.datayes.com/564aee87f9f06c4446b4829b/a6d10dac-957b-11e8-bfc5-0242ac140002"><span class="image-caption">图片注释</span> 其中，RM表示基准的收益率序列，σ(⋅)函数的定义和前面相同，n是回测期间的交易日天数。</p>
<p><strong>相对年化收益</strong>（Annualized Hedged Return） 策略A测量的是2015年上半年，策略B测量的是2015下半年。在2015年上半年就算是瞎猜也能赚到不少钱，但是在2015年下半年如果能保持净值就算是十分优秀的策略了。因此单纯比较它们的年化收益也是不公平的，我们需要把整体市场的因素剔除之后再对它们进行比较，这时我们就需要使用对冲年化收益来衡量策略的好坏了。 <img src="http://storage-uqer.datayes.com/564aee87f9f06c4446b4829b/abe315ce-957b-11e8-bfc5-0242ac140002"><span class="image-caption">图片注释</span></p>
<p><strong>相对年化波动率</strong>（Annualized Hedged Volatility） 相应的，有相对年化波动率 <img src="http://storage-uqer.datayes.com/564aee87f9f06c4446b4829b/b1b0cbe0-957b-11e8-8cfa-0242ac140002"><span class="image-caption">图片注释</span></p>
<p>其中 <img src="http://storage-uqer.datayes.com/564aee87f9f06c4446b4829b/bbc02f54-957b-11e8-8cfa-0242ac140002"><span class="image-caption">图片注释</span> 是相对收益率序列，σ(⋅)函数的定义和前面相同。</p>
<p><strong><u>贝塔</u><strong>（Beta） 反映</strong>策略净值与市场波动的关联性</strong>，也是前面讲到CAPM中的β。加入一个策略β&#x3D;0.5，说明当市场总体上涨1%的时候，市场带给策略的收益率会有+0.5%；当市场总体下跌1%的时候，市场带给策略的收益率会有-0.5%。 <img src="http://storage-uqer.datayes.com/564aee87f9f06c4446b4829b/c3185e48-957b-11e8-bfc5-0242ac140002"><span class="image-caption">图片注释</span> 其中Rp表示策略收益率序列，RM表示相应的市场基准收益率序列（比如如果选择沪深300作为市场收益率基准，那么RM就是沪深300指数的百分比增量序列)。这里大写字母表示是一个序列而不是一个数字。</p>
<p>当Beta&lt;0时表明策略走向常常和市场方向相反，比如空头组合；Beta&#x3D;0表明策略的收益与市场关联不大，比如固定收益类；0&lt;Beta&lt;1表明策略收益走向与市场相同，但是相较市场来说波动更小、风险更小；类似地Beta≥1表明策略收益相较市场来说风向相差不多或者风险更大。</p>
<p><u><strong>阿尔法</strong></u>（Alpha） 其作用类似于前面讲的对冲年化收益，都反映的是扣除市场大环境之后的收益率。只不过这里阿尔法的计算以CAPM模型为基础。 <img src="http://storage-uqer.datayes.com/564aee87f9f06c4446b4829b/c9978d2a-957b-11e8-bfc5-0242ac140002"><span class="image-caption">图片注释</span> 其中rf为无风险利率，实际计算过程中可以把它当做定期存款利率或者把它当做零。</p>
<p><strong><u>夏普比率</u><strong>（Sharpe） 反映的是每承担一个单位的风险能够获得多少超额收益，是一个</strong>综合风险和收益的衡量指标</strong>。通常希望这个指标越大越好，这个指标也是量化策略评价中最为重要的一个指标。我们希望这个数值越大越好。 <img src="http://storage-uqer.datayes.com/564aee87f9f06c4446b4829b/ce215510-957b-11e8-bfc5-0242ac140002"><span class="image-caption">图片注释</span> <strong>信息比率</strong>（Information Ratio） 夏普比率衡量的是策略绝对收益的收益风险特征，信息比率衡量的是策略<strong>相对收益</strong>的收益风险特征。 <img src="http://storage-uqer.datayes.com/564aee87f9f06c4446b4829b/d2703a32-957b-11e8-8cfa-0242ac140002"><span class="image-caption">图片注释</span> </p>
<p><strong>无风险利率</strong></p>
<p>一般用国债利率衡量。</p>
<p><strong>索提诺比率</strong>（Sortino） 表示每承担一个单位的下行风险能够获得多少超额收益。 <img src="http://storage-uqer.datayes.com/564aee87f9f06c4446b4829b/d7154956-957b-11e8-8cfa-0242ac140002"><span class="image-caption">图片注释</span> **<u>最大回撤</u>**（Max Drawdown） 反映策略极端情况下的最大亏损 <img src="http://storage-uqer.datayes.com/564aee87f9f06c4446b4829b/da7c5260-957b-11e8-bfc5-0242ac140002"><span class="image-caption">图片注释</span> 其中P表示净值序列，它可以由收益率序列计算出来 <img src="http://storage-uqer.datayes.com/564aee87f9f06c4446b4829b/dea38700-957b-11e8-8cfa-0242ac140002"><span class="image-caption">图片注释</span></p>
<p><strong>胜率</strong>（Winning Rate） 反映策略交易一次能够盈利的概率</p>
<p>WinningRate&#x3D;策略交易盈利次数&#x2F;策略交易总次数 </p>
<p>当然前面讲的这些是对于整个流程的衡量方法，整个流程的效果是其中每一个步骤的加和。有时候我们还需要分别对于每一个步骤进行分析，希望看看到底是哪一个步骤制约了整体策略的性能。这时候就需要分别对于各个步骤进行性能的测量。</p>
<p>对于因子的计算来说，我们一般通过以下一些指标来衡量因子计算的好坏</p>
<p><strong><u>信息系数（Information Correlation，IC）</u></strong> 即在每一个横截面上计算因子数值和收益率之间的相关系数，相关系数的计算方法有两种，分别是pearsonr和spearmanr。注意到，<strong>信息系数是对于每一个时间截面都计算出来一个数值</strong>，因此会产生一个IC的时间序列，我们一般对这个时间序列计算均值，这个数值是研报中提到的IC。IC的<strong>绝对数值</strong>越大，相应的因子越好。很多研报里面为了区别这两种计算方式，又把后一种计算出来的信息系数成为<strong>rank IC</strong>。</p>
<p><strong><u>信息比率</u><strong>（Information Ratio，IR或者ICIR） 只计算IC序列的均值可能出现的问题是，有些表现</strong>不稳定的因子IC的均值也可能绝对值较大</strong>。为了综合考虑因子IC稳定性，可以通过ICIR指标来衡量。ICIR&#x3D;mean(IC)&#x2F;std(IC)，公式中IC指的是IC序列。</p>
<p>对于模型来说，也可以使用IC和ICIR来衡量模型的好坏，只需要把以上计算中因子的数值替换为模型输出的评分即可。</p>
<p>当然，对于流程中各个步骤的评判来说，也可以使用控制变量法来进行评判。即，只改变流程中的某一个步骤，同时控制流程中的其他步骤，直接观察整个流程的评价指标的变化。</p>
<p><strong>总结</strong></p>
<p> 看了这么多统计指标，头大。我们来总结一下，其中加黑的部分是需要重点关注的指标。</p>
<p><img src="https://pic2.zhimg.com/v2-246940eb93d2a7f2d95c51420cc066e9_b.jpg"><span class="image-caption">img</span></p>
<h1 id="4-开始挣钱——从回测到实盘"><a href="#4-开始挣钱——从回测到实盘" class="headerlink" title="4.开始挣钱——从回测到实盘"></a>4.开始挣钱——从回测到实盘</h1><p>这一部分虽然写的不长，但其实这一步并不容易。经常出现的是回测中有很好的效果，但是一放到模拟交易或者实盘交易中表现就不如回测了。产生这种现象主要有两种常见的原因。</p>
<p><strong><u>第一种原因是未来信息</u><strong>。在因子的构造、模型的计算、策略的组合以及回测中，都不能利用未来的信息来做决定。这种浅显的道理一说出来大家都明白，但是</strong>对于未来信息的利用有时候是十分隐蔽的</strong>，如果不仔细看很多时候难以发现。拿模型计算来说，最基本的防止对于未来信息的利用就是不能在未来的数据上进行参数拟合，然后把模型再用到过去的预测中。有些时候对于未来信息的利用会更为隐蔽，比如在回测的时候如果我们指定了沪深300成分股中选股，我们需要使用”那一时刻”的沪深300成分股，而不是“未来时刻”的沪深300成分股。再比如，对于ST股票的提出，我们需要使用“那一时刻”的ST股票。再比如，在因子计算过程中有时会利用到财报数据，很多时候财报在第一次公布的时候数据并不准确，<strong>上市公司会在之后的某个时刻修正之前已经公布的财报的数据</strong>。因子的计算就不能够使用这些看似更为准确的财报数据。</p>
<p><strong><u>第二种原因是过拟合</u><strong>（overfitting）。我们前面提到，不能在未来的数据上拟合模型的参数，然后把它用于过去的决策。而过拟合其实是一种更为隐蔽的对于未来信息的利用，即在总的数据上调整模型中的超参数，然后人为选出使得策略效果最好的超参数，最后</strong>这样的超参数实际上又用于了过去的决策。</strong>虽然从某种程度上来说，过拟合也是一种隐式的利用未来信息，但是避免过拟合并不能像未来信息那样从源头上杜绝它。</p>
<p>模型中的超参数只有经过一定的调整才能真正反映模型的性能。举个例子，你想比较一辆兰博基尼和一辆奔驰，你肯定需要把这两辆车的发动机、轮胎、悬挂都调教好了再去比较。而调整的方法就是让车在路上跑一跑看看有没有调整好。汽车本身就像量化策略，而它们的发动机、轮胎等就好比是策略的超参数。 <img src="http://storage-uqer.datayes.com/564aee87f9f06c4446b4829b/10735bf2-957c-11e8-8cfa-0242ac140002"><span class="image-caption">图片注释</span></p>
<p>那**<u>怎么避免过拟合呢</u><strong>？方法就是把</strong>训练的数据分为两段<strong>，在一段独立的数据上面进行超参数的调整，调整好了之后再再另一段数据集上面进行测试。在前一段数据上调整好之后，再把模型放到后一段数据上评价，</strong>后一段数据上面的评价尽可能不要反馈到模型**中，同时尽量减少在后一段数据上测试的次数。</p>
<p>当策略回测能够达到预期的效果，并且也尽力避免了未来信息和过拟合之后，我们就可以进行模拟交易的测试了。模拟交易的数据是股市最新的实时数据，这些数据是百分之百的样本外数据。如果策略能在这些数据上也表现仍然不错的话，也从结果上说明了之前的模型没有受到未来信息和过拟合的影响。</p>
<p>下一步我们就可以考虑实盘了。对于一些频率比较低的策略，比如一些月度调仓的策略，可以由策略生成结果之后，人工来完成相关的交易。但是稍微高频一些的策略则需要使用程序来自动完成，比如一些按周调仓的策略可能需要某一天以均价买入一定数量的某只股票，通过程序来实现底层的“以vwap&#x2F;twap交易“使得交易的结果更有保障。相关的这些程序如何来编写又是一个比较大的topic了，以后有时间再来细讲。</p>
<p>最后放一些<strong>开源的交易接口</strong>供参考。</p>
<p><a href="http://www.vnpy.org/">vn.py</a>：是一个基于Python的开源实时交易接口</p>
<p><a href="https://github.com/QuantBox/QuantBox_XAPI">Quant Box</a>：基于C、C++、C#的开源交易接口</p>
<p>本文改编学习自<a href="http://sealzhang.tk/">张楚珩的仓库</a></p>
]]></content>
      <categories>
        <category>量化交易</category>
      </categories>
  </entry>
  <entry>
    <title>量化投资入门4：机器学习如何与量化投资结合</title>
    <url>/2023/01/14/4.%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9C%A8%E9%87%8F%E5%8C%96%E6%8A%95%E8%B5%84%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>由于本人Machine Learning知识过少，留待日后更新</p>
<span id="more"></span>



<h1 id="第四讲：机器学习如何与量化投资结合？"><a href="#第四讲：机器学习如何与量化投资结合？" class="headerlink" title="第四讲：机器学习如何与量化投资结合？"></a>第四讲：机器学习如何与量化投资结合？</h1><p><a href="https://zhuanlan.zhihu.com/p/56012917">https://zhuanlan.zhihu.com/p/56012917</a></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a><strong>目录</strong></h2><ul>
<li>基本框架</li>
<li>决策树模型</li>
<li>支持向量机</li>
<li>贝叶斯模型</li>
<li>聚类模型</li>
<li>强化学习</li>
</ul>
]]></content>
      <categories>
        <category>量化交易</category>
      </categories>
  </entry>
  <entry>
    <title>量化投资入门5：财务分析与决策</title>
    <url>/2023/08/15/5.%E8%B4%A2%E5%8A%A1%E5%88%86%E6%9E%90%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>会计核心课。内容为THU肖星老师的财务分析与决策课程的子集</p>
<span id="more"></span>



<p><a href="https://www.bilibili.com/video/BV1or4y137U7/?p=2&spm_id_from=pageDriver&vd_source=5412994b4214344801beb943df586d53">肖星.财务分析与决策.清华大学</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><ul>
<li><p>本节即资产负债表、利润表、现金流量表的作用、意义及局限性。重点是学会看财务报表，数据分析后进而提高商业决策能力。会计是一门科学也是一门艺术。</p>
</li>
<li><p>三张报表目的：描述企业经济活动</p>
<ol>
<li>资产负债表：描述企业财务状况，家底；投、融资活动</li>
<li>利润表：描述企业经营状况</li>
<li>现金流量表：描述现金变化的来龙去脉；持续经营的风险</li>
</ol>
</li>
<li><p>企业主要的三项活动 ：</p>
<ul>
<li>一家企业运转，伴随着三项主要活动。<strong>循环往复，使总资金增加</strong><ul>
<li><strong>经营活动</strong></li>
<li><strong>投资活动</strong>（广义，投入资金）</li>
<li><strong>融资活动</strong></li>
</ul>
</li>
<li>比如，我们打算要开一家公司，会去银行借款，拿到现金后开始购买原材料、生产设备、租借厂房，销售生产出的产成品获得现金回款，偿还借款。</li>
</ul>
</li>
</ul>
<h2 id="一、资产负债表中需要注意的几个科目"><a href="#一、资产负债表中需要注意的几个科目" class="headerlink" title="一、资产负债表中需要注意的几个科目"></a>一、<strong>资产负债表</strong>中需要注意的几个科目</h2><table>
<thead>
<tr>
<th align="left">资产</th>
<th align="right"></th>
<th>负债</th>
<th align="right"></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>流动资产</strong></td>
<td align="right"></td>
<td><strong>流动负债</strong></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">货币资金</td>
<td align="right">808</td>
<td>短期借款</td>
<td align="right">1262</td>
</tr>
<tr>
<td align="left">应收账款</td>
<td align="right">1180</td>
<td>应付账款</td>
<td align="right">688</td>
</tr>
<tr>
<td align="left">其他应收款</td>
<td align="right">21</td>
<td>其它应付款</td>
<td align="right">9</td>
</tr>
<tr>
<td align="left">预付帐款</td>
<td align="right">221</td>
<td>预收款项</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">存货</td>
<td align="right">527</td>
<td>其他流动负债</td>
<td align="right">1044</td>
</tr>
<tr>
<td align="left">待摊费用</td>
<td align="right">9</td>
<td>流动负债合计</td>
<td align="right">3004</td>
</tr>
<tr>
<td align="left">其他流动资产</td>
<td align="right">290</td>
<td></td>
<td align="right"></td>
</tr>
<tr>
<td align="left"><strong>非流动资产</strong></td>
<td align="right"></td>
<td><strong>非流动负债</strong></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">长期投资</td>
<td align="right">60</td>
<td>长期借款</td>
<td align="right">1368</td>
</tr>
<tr>
<td align="left">固定资产</td>
<td align="right">5422</td>
<td>应付债券</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">无形资产及其他</td>
<td align="right">168</td>
<td>长期应付款</td>
<td align="right">12</td>
</tr>
<tr>
<td align="left"><strong>总资产</strong></td>
<td align="right">8706</td>
<td>其他非流动性负债</td>
<td align="right">793</td>
</tr>
<tr>
<td align="left"></td>
<td align="right"></td>
<td></td>
<td align="right"></td>
</tr>
<tr>
<td align="left"></td>
<td align="right"></td>
<td><strong>股东权益</strong></td>
<td align="right"></td>
</tr>
<tr>
<td align="left"></td>
<td align="right"></td>
<td>实收资本&#x2F;股本</td>
<td align="right">498</td>
</tr>
<tr>
<td align="left"></td>
<td align="right"></td>
<td>资本公积</td>
<td align="right">2002</td>
</tr>
<tr>
<td align="left"></td>
<td align="right"></td>
<td>盈余公积</td>
<td align="right">308</td>
</tr>
<tr>
<td align="left"></td>
<td align="right"></td>
<td>未分配利润</td>
<td align="right">722</td>
</tr>
<tr>
<td align="left"></td>
<td align="right"></td>
<td><strong>负债及股东权益合计</strong></td>
<td align="right">8706</td>
</tr>
</tbody></table>
<h3 id="1-1-资产科目"><a href="#1-1-资产科目" class="headerlink" title="1.1.资产科目"></a>1.1.资产科目</h3><p><strong>流动资产(Current Assets): 指企业在1年内可收回现金的资产</strong></p>
<p>经过单个循环就变成资金。</p>
<p>按<strong>变成资金的速率</strong>排序：</p>
<ul>
<li><p>货币资金(Cash): 包括现金、银行存款、现金等价物(除了长期投资的货币基金)</p>
</li>
<li><p><strong>应收账款(Accounts Receivable)</strong>: 由于销售商品、提供服务或其他商业活动带来的应该收回但<strong>暂时未收回</strong>的资金</p>
<ul>
<li>为了商业竞争&#x2F;支票</li>
</ul>
</li>
<li><p>其他应收款(Other Receivables): 除下列以外的临时应收款(预付定金、金融资产回购、应收票据贴现、应收账款、预付款项、应收股利、应收利息、应收待追偿权、应收分保账款)</p>
<ul>
<li>借给朋友&#x2F;临时周转&#x2F;出差备用金</li>
<li>中国特色：以借名义来占用资金</li>
</ul>
</li>
<li><p>预付账款(Prepaid Accounts): 相关公司已经提前付款，但本期尚未收益或收益期涉及多个财务期</p>
</li>
<li><p><strong>存货(Inventory)</strong>: 包括成品、在产品、生产过程中的消耗材料和物料等</p>
<ul>
<li>原材料&#x2F;还没卖的</li>
</ul>
</li>
<li><p>待摊费用(Deferred Expense): 最初是一笔<strong>资产</strong>，但随着企业的正常运营和时间的流逝，最终变为一笔<strong>费用</strong>。比如预付的房租、广告费用、土地使用权</p>
<ul>
<li>资产：换来有用的东西</li>
<li>费用：没有留下东西</li>
<li>本质：逐渐减少变为费用的预付的资产。例子：预付广告费</li>
</ul>
</li>
</ul>
<p><strong>非流动资产(Non-current Assets): 流动资产以外的资产</strong></p>
<p>经过多个循环才变成资金</p>
<ul>
<li>长期投资(Long term investment): 包括长期股权投资、债券投资、其他长期投资</li>
<li><strong>固定资产</strong>(Fixed Assets): 指满足下列特征的有形资产 (a) 为生产商品、提供劳务、出租或经营管理而持有的 (b) 使用寿命超过一个会计年度<ul>
<li>设备（非流动，不等于原材料）</li>
</ul>
</li>
<li>无形资产(Intangible Assets): 包括：专利权、非专利技术、商标权、著作权、土地使用权（中国特色）等</li>
<li>其他<ul>
<li>商誉(Goodwill): 在企业合并时，它是购买企业投资成本超过被并企业净资产公允价值的差额</li>
<li>折旧(Depreciation): 指固定资产在使用中的损耗</li>
<li>生物性资产(Biological Assets): 指有生命的动物和植物。又包括消耗性生物资产、生产性生物资产和公益性生物资产</li>
</ul>
</li>
</ul>
<p><strong>其他注意事项</strong></p>
<ul>
<li><p>人不归在资产报表里，即使是设计公司（所有权）。但有些情况下会成为待摊资产（花钱买球星）</p>
</li>
<li><p>资产的价值：右边数字一般取决于<strong>历史成本</strong>（当时购买资产的价格）</p>
<ul>
<li>当资产类型客观透明，用<strong>公允价格</strong>计算（金融资产，投资性房地产）</li>
<li>忽略增值，记录减值</li>
<li>会计的谨慎性质</li>
<li>例子：分析造纸业做假账</li>
<li>唯一增加方法：做交易。（所以有企业买卖自己）</li>
</ul>
</li>
</ul>
<p><strong>怎么分析企业</strong></p>
<ul>
<li>看比例组合（正反分析都可）<ul>
<li>固定资产-制造业</li>
<li>应收账单-竞争</li>
</ul>
</li>
</ul>
<h3 id="1-2-负债科目"><a href="#1-2-负债科目" class="headerlink" title="1.2.负债科目"></a>1.2.负债科目</h3><p>许多和资产对应</p>
<p><strong>流动负债(Current Liability): 指1年内需要支付的负债</strong></p>
<ul>
<li>短期借款(Short term borrowing): 企业为了维持正常经营、偿付某项债务，还款期在1年内的借款</li>
<li>应付账款(Accounts Payable): 因购买原材料、接受劳务所欠供应商的账款</li>
<li>其他应付款(Other Payable): 企业在商品交易业务以外发生的应付和暂收款项。指除下列以外的应付、暂收其他单位或个人的款项(应付票据、应付账款、应付工资、应付利润)。比如，应付工工资、应交税金(企业销售商品代收的增值税)</li>
<li>预收款项(Deposit Received): 由购货方预先支付一部分货款给供应方而发生的一项负债</li>
<li>其他<ul>
<li>应付工资、应交税金</li>
</ul>
</li>
</ul>
<p><strong>非流动负债(Non-current liabilities): 还款期长于1年的负债</strong></p>
<ul>
<li>长期借款(Long term borrowing): 指从银行、其他金融机构借来还款期长于1年的负债</li>
<li>应付债券(Bonds payable): 企业为筹集资金而对外发行的期限在一年以上的长期借款性质的书面证明，约定在一定期限内还本付息的一种书面承诺（中国较少）</li>
<li>长期应付款(Long term payable): 除了长期借款和应付债券以外的长期负债，包括应付引进设备款、应付融资租入固定资产的租赁费(经营性租赁、融资性租赁)、分期付款等<ul>
<li>经营性租赁</li>
<li>融资性租赁：相当于分期付款</li>
</ul>
</li>
</ul>
<h3 id="1-3-股东权益科目"><a href="#1-3-股东权益科目" class="headerlink" title="1.3.股东权益科目"></a>1.3.股东权益科目</h3><p><strong>股东权益(Shareholder’s equity): 也叫做净资产，反映公司自有资本</strong></p>
<ul>
<li>实收资本（有限公司） &#x2F;  股本(Capital Stock): 股东在公司所占权益，多指股票（股东投入的）<ul>
<li>股本（实收资本） &#x3D;&#x3D; 注册资本<ul>
<li>法律权利的上限</li>
<li>决定股东分红</li>
</ul>
</li>
</ul>
</li>
<li>资本公积(Additional paid-in capital): 包括资本溢价（股本溢价）和直接记入所有者权益的利得和损失等（外部投入的）<ul>
<li>注册资本之外的资金</li>
<li>例如：上市公司</li>
</ul>
</li>
<li>盈余公积(Surplus reserve): 企业按照规定从净利润中提取的各种积累资金(中国要求至少保留10%)<ul>
<li>法律规定必须留下的</li>
</ul>
</li>
<li>未分配利润(Retained earnings): 企业选择未作分配的利润，它在以后年度可继续进行分配，在未进行分配之前，属于所有者权益<ul>
<li>详细看利润表</li>
</ul>
</li>
</ul>
<p><strong>整体回顾</strong></p>
<ul>
<li><p>左边：投入公司的分别拿去做什么了</p>
</li>
<li><p>右边：投入公司的钱是哪里来的</p>
</li>
<li><p>资产 &#x3D; 负债 + 股东权益</p>
<ul>
<li>股东权益 &#x3D; 资产 - 负债：剩余求偿权<ul>
<li>意义：股东是最终的风险和利益承担者</li>
</ul>
</li>
<li>资产 ≠ 财产物资</li>
</ul>
</li>
<li><p>资产本质是权利，负债本质是义务</p>
</li>
<li><p>这张表本质是<strong>时点</strong>的概念，相当于快照</p>
</li>
</ul>
<h2 id="二、利润表及ROE杜邦分析"><a href="#二、利润表及ROE杜邦分析" class="headerlink" title="二、利润表及ROE杜邦分析"></a>二、利润表及ROE杜邦分析</h2><ul>
<li>作用<ul>
<li>描述企业有没有赚到钱</li>
<li>形成对企业未来利润的预期</li>
</ul>
</li>
<li>收入 - 所有成本费用 &#x3D; 利润<ul>
<li>现金流 &#x3D; 收入现金 - 付出现金</li>
</ul>
</li>
<li>本质是<strong>时段</strong>的概念</li>
</ul>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="right"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">营业收入</td>
<td align="right">4300</td>
</tr>
<tr>
<td align="left">-营业成本</td>
<td align="right">3100</td>
</tr>
<tr>
<td align="left">-营业税金及附加</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">-销售费用（营业费用）</td>
<td align="right">250</td>
</tr>
<tr>
<td align="left">-管理费用</td>
<td align="right">200</td>
</tr>
<tr>
<td align="left">-财务费用</td>
<td align="right">130</td>
</tr>
<tr>
<td align="left">-资产减值损失</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">+公允价值变动收益</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">+投资收益</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">&#x3D;营业利润</td>
<td align="right">620</td>
</tr>
<tr>
<td align="left">+营业外收入</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">&#x3D;利润总额</td>
<td align="right">620</td>
</tr>
<tr>
<td align="left">-所得税费用</td>
<td align="right">100</td>
</tr>
<tr>
<td align="left">&#x3D;净利润</td>
<td align="right">520</td>
</tr>
</tbody></table>
<p><strong>利润表科目</strong></p>
<ul>
<li>营业收入(Operating Income): 企业在生产经营活动中，因销售产品或提供劳务而取得的各项收入<ul>
<li>收入≠收获现金</li>
</ul>
</li>
<li>营业总收入&#x3D;营业收入</li>
<li>营业总成本&#x3D;营业成本+营业税金及增加+费用</li>
</ul>
<p>-<strong>营业成本(Operating Cost): 包括生产成本、研发支出、表外资产(比如，组织建设、品牌渠道)</strong></p>
<ul>
<li>生产成本: 包括原材料、制造费用、变动成本、固定成本</li>
<li>变动成本(Variable Cost): 总额在相关范围内随着业务量的变动而呈线性变动的成本</li>
<li>固定成本(Fixed Cost): 总额在一定时期和一定业务量范围内，不受业务量增减变动影响而能保持不变的成本</li>
</ul>
<p><strong>-营业税金及附加(Business tax and surcharges): 企业经营活动应负担的相关税费，包括营业税、消费税、城市维护建设税、资源税等。</strong></p>
<ul>
<li>营业税(Business Tax): 国家对工商营利事业按营业额征收的税，属于流转课税的一类，价内税<ul>
<li>价内税：不需要由消费者承担</li>
<li>现在已经营改增</li>
</ul>
</li>
<li>增值税(Value-added Tax): 一种销售税&#x2F;价外税，由消费者承担的税费，是基于商品或服务的增值而征税的一种间接税<ul>
<li>价外税(Tax excluded in price): 比如增值税</li>
<li>不包含在该表项，体现在应交税金里</li>
</ul>
</li>
</ul>
<p><strong>-费用(Expense): 公司为销售而发生的各种成本支出、管理、利息、税金等，包括营业费用、管理费用、营业费用等</strong></p>
<p>费用 ≠ 付出现金</p>
<ul>
<li>营业费用(Operating Expense): 等同于销售费用</li>
<li>管理费用(General and administrative expense): 企业的行政管理部门为管理和组织经营而发生的各项费用<ul>
<li>管理人员工资</li>
</ul>
</li>
<li>财务费用(Financing expense): 企业在生产经营过程中为筹集资金而发生的各项费用，包括利息支出、汇兑净损失、金融机构手续费等<ul>
<li>主要为利息</li>
</ul>
</li>
</ul>
<p><strong>-资产减值损失</strong>(Impairment loss of assets impairment): 因资产的账面价值高于其可收回金额而造成的损失。会计准则规定资产减值范围主要是固定资产、无形资产以及除特别规定外的其他资产减值的处理</p>
<p>**+公允价值变动收益(**Changes of fair value assets): 以公允价值计量且其变动记入当期损益的交易性金融资产。一般房地产、债券、股权投资这些可以使用公允价值计价</p>
<p><strong>+投资收益(Investment income):</strong> 对外投资所取得的利润、股利和债券利息等收入减去投资损失后的净收益</p>
<p><strong>以上得到营业利润(Operating Profit)</strong>&#x3D;营业总收入-营业总成本-资产减值损失+公允价值变动收益+投资收益</p>
<ul>
<li>+营业外收入(Non-operating revenue): 包括：非流动资产处置利得、非货币性资产交换利得、出售无形资产收益、债务重组利得、企业合并损益、盘盈利得、因债权人原因确实无法支付的应付款项、政府补助、教育费附加返还款、罚款收入、捐赠利得。没有持续性<ul>
<li>存货盘盈 &#x2F; 固定资产卖掉</li>
<li>偶然因素</li>
</ul>
</li>
<li>-营业外支出(Non-operating expenses): 包括非流动资产处置损失、非货币性资产交换损失、债务重组损失、公益性捐赠支出、非常损失、盘亏损失等。</li>
</ul>
<p>**以上得到利润总额(Total profit)&#x3D;**营业利润+营业外收入-营业外支出。（该项不如营业利润能反应企业的持续收入）</p>
<ul>
<li>所得税费用(Income tax)&#x3D;应纳税所得*所得税税率(0.25)</li>
<li>应纳税所得(Taxable Income): 根据税法规定所确认的收入总额与准予扣除项目金额（即可扣除的费用）的差额（根据税法）</li>
</ul>
<p><strong>净利润(Net profit)&#x3D;利润总额-所得税费用，</strong>也称为税后利润，净利润多，企业的经营效益就好，衡量一个企业经营效益的主要指标</p>
<h2 id="三、如何用现金流量表进行企业估值"><a href="#三、如何用现金流量表进行企业估值" class="headerlink" title="三、如何用现金流量表进行企业估值"></a>三、如何用<strong>现金流量表</strong>进行企业估值</h2><table>
<thead>
<tr>
<th align="left"><strong>经营活动产生的现金流</strong></th>
<th align="right"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">销售商品、提供劳务收到的现金</td>
<td align="right">3000</td>
</tr>
<tr>
<td align="left">收到的税费返还</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">收到的其他与经营活动有关的现金</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left"><strong>现金流入小计</strong></td>
<td align="right">3000</td>
</tr>
<tr>
<td align="left">购买商品、接受劳务支付的现金</td>
<td align="right">1750</td>
</tr>
<tr>
<td align="left">支付给职工以及为职工支付的现金</td>
<td align="right">1200</td>
</tr>
<tr>
<td align="left">支付的各项税费</td>
<td align="right">100</td>
</tr>
<tr>
<td align="left">支付的其他与经营活动有关的现金</td>
<td align="right">450</td>
</tr>
<tr>
<td align="left"><strong>现金流出小计</strong></td>
<td align="right">3500</td>
</tr>
<tr>
<td align="left">经营活动产生的现金流量净额</td>
<td align="right">-500</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left"><strong>投资活动产生的现金流</strong></th>
<th align="right"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">收回投资所受到的现金</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">取得投资收益所到的现金</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">处置固定资产、无形和其他长期而所收到的现金净额</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">收到的其他与投资活动有关现金</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left"><strong>现金流入小计</strong></td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">购建固定资产、无形和其他长期所支付的现金</td>
<td align="right">5850</td>
</tr>
<tr>
<td align="left">投资所支付的现金</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">支付的其他与投资活动有关现金</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left"><strong>现金流出小计</strong></td>
<td align="right">5850</td>
</tr>
<tr>
<td align="left">投资活动产生的现金流量净额</td>
<td align="right">-5850</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left"><strong>融资活动产生的现金流</strong></th>
<th align="right"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">吸收投资所到的现金</td>
<td align="right">3200</td>
</tr>
<tr>
<td align="left">借款所收到的现金</td>
<td align="right">5100</td>
</tr>
<tr>
<td align="left">收到的其他与筹资活动有关现金</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left"><strong>现金流入小计</strong></td>
<td align="right">8300</td>
</tr>
<tr>
<td align="left">偿还债务所支付的现金</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">分配股利、润或偿付息所支的现金</td>
<td align="right">230</td>
</tr>
<tr>
<td align="left">支付的其他与筹资活动有关的现金</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left"><strong>现金流出小计</strong></td>
<td align="right">230</td>
</tr>
<tr>
<td align="left">筹资活动产生的现金流量净额</td>
<td align="right">8070</td>
</tr>
<tr>
<td align="left">汇率变动对现金的影响</td>
<td align="right">0</td>
</tr>
<tr>
<td align="left">现金及等价物净增加额</td>
<td align="right">1720</td>
</tr>
</tbody></table>
<ol>
<li><p>什么是现金流量表? <strong>时点</strong>概念，反映持续经营的风险</p>
<ol>
<li>目的：描述现金的来龙去脉，进行三种分类（现金与其他资产相比最特殊）。更确切地说，现金流量表描述了企业的风险状况。</li>
<li>经营活动流入 &#x2F; 投资活动流出更反映价值</li>
<li>现金流分析，肯定希望三项活动现金流净额都为正，但最不希望经营性现金流净额为负</li>
</ol>
</li>
<li><p>年末的货币资金-年初的货币资金 &#x3D; 现金净流量 &#x3D; 现金流入-现金流出</p>
<ol>
<li>可以通过现金流量表了解</li>
</ol>
</li>
<li><p>净利润 - 净现金流 &#x3D; 非现金资产的变化</p>
</li>
<li><p>现金及等价物净增加额 &#x3D; 经营活动现金流净额 + 投资活动现金流净额 + 融资活动现金流净额</p>
</li>
<li><p>净利润重要还是经营现金流重要？在<strong>资产价值有保证的情况下</strong>，利润表相对更重要；而如果报表中出现贬值的资产，则现金流相对更重要。设备折旧会影响净利润减少，但经营现金流不变。</p>
</li>
</ol>
<p>经营性现金流: 反映企业的造血机能</p>
<ul>
<li><p>(+)销售商品、提供服务所获得的现金</p>
</li>
<li><p>(+)退税收入</p>
</li>
<li><p>(+)其他经营活动带来的现金收入</p>
</li>
<li><p>(-)购买商品、服务所支出的现金</p>
</li>
<li><p>(-)支付员工工资</p>
</li>
<li><p>(-)支付的各项税费</p>
</li>
<li><p>(-)其他经营活动带来的现金支出</p>
</li>
</ul>
<p>投资性现金流: 固定资产、对外投资</p>
<ul>
<li><p>(+)收回投资所收回的现金</p>
</li>
<li><p>(+)投资所得收益</p>
</li>
<li><p>(+)处置固定资产、无形资产、其他长期资产所取得的现金净额</p>
</li>
<li><p>(+)其他投资活动带来的现金收入</p>
</li>
<li><p>(-)购买固定年资产、无形资产、长期资产所支付的现金</p>
</li>
<li><p>(-)投资所支付的现金</p>
</li>
</ul>
<p>融资性现金流（债务融资 &#x2F; 股权融资）</p>
<ul>
<li><p>(+)从投资者获取的现金</p>
</li>
<li><p>(+)从银行、其他金融机构所获得的短期借款、长期借款</p>
</li>
<li><p>(+)其他融资活动带来的现金收入</p>
</li>
<li><p>(-)偿还债务所支付的现金</p>
</li>
<li><p>(-)分红、还息所支出的现金</p>
</li>
<li><p>(-)其他融资活动带来的现金支出</p>
</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230108185440357.png"><span class="image-caption">image-20230108185440357</span></p>
<p>区分：筹资活动是指导致企业资本及债务规模和构成发生变化的活动。投资活动是指企业<strong>长期资产的购建</strong>和<strong>不包括在现金等价物内的投资</strong>及其处置活动。（能进行资本计算）经营活动是指企业投资活动和筹资活动以外的所有交易和事项。</p>
<h2 id="四、为什么是这三张报表"><a href="#四、为什么是这三张报表" class="headerlink" title="四、为什么是这三张报表"></a>四、为什么是这三张报表</h2><p>三张报表两个维度（收益维度，风险维度）</p>
<p>活下去的收益 &#x2F; 能不能活下去</p>
<ul>
<li><p>利润表主要在描述经营活动</p>
</li>
<li><p>资产负债表主要在描述投资融资活动，也简要描述了经营活动</p>
<ul>
<li>这两张报表足够描述三种活动</li>
</ul>
</li>
<li><p>现金流量表在风险视角，重新描述三种活动</p>
</li>
</ul>
<p>不严谨的例子:</p>
<ul>
<li>银行放贷时：最关注企业现金流量表（风险）</li>
<li>个人投资者：最关心利润表（未来预期）</li>
<li>收购公司：资产负债表（买了什么）<ul>
<li>零成本收购：承担负债获得资产</li>
<li>担心造假：专业公司评估财报</li>
<li>一般而言，资产是高估的风险，负债是低估的风险（或有负债、表外负债），负债更难控制</li>
</ul>
</li>
</ul>
<h2 id="五、如何对公司估值"><a href="#五、如何对公司估值" class="headerlink" title="五、如何对公司估值"></a>五、如何对公司估值</h2><h3 id="1-利用财报数据比率，去分析一家公司的竞争"><a href="#1-利用财报数据比率，去分析一家公司的竞争" class="headerlink" title="1.利用财报数据比率，去分析一家公司的竞争"></a>1.利用财报数据比率，去分析一家公司的竞争</h3><p>常用的方法有，</p>
<p>a) <strong>纵向趋势</strong>分析，顾名思义，判断这些重要科目的历史趋势 </p>
<p>b) <strong>横向对比</strong>分析&#x2F;同型分析，比较两个同行业、同发展阶段的公司财务报表 </p>
<p>c) 比率分析，抽象出不同公司体量，但可比较的衍生指标，比如总资产周转率、净利率等</p>
<ul>
<li>制造业一般看，固定资产周转率、应收账款周转率、存货周转率</li>
</ul>
<p><strong>常用的几个比率指标</strong></p>
<ol>
<li>毛利率(Gross Margin)&#x3D;(营业收入-营业成本)&#x2F;营业收入，反映企业盈利能力。 <strong>毛利率反映竞争形势，要么资源独占，要么有牌照限制，要么有技术优势，要么有品牌优势</strong></li>
<li>净利率(Net profit margin)&#x3D;净利润&#x2F;营业收入，反映企业盈利能力</li>
<li>总资产周转率(Total asset turnover ratio)&#x3D;<strong>营业收入</strong>&#x2F;总资产。反映企业销售、管理能力，也能体现效率</li>
<li>应收账款周转率(Accounts receivable turnover ratio)&#x3D;营业收入&#x2F;期间平均应收账款，反映应收账款变现效率<ol>
<li>应收账款天数(Accounts receivable turnover days)&#x3D;365&#x2F;应收账款周转率</li>
</ol>
</li>
<li>流动资产周转率(Current Assets Turnover)&#x3D;营业收入&#x2F;期间平均流动资产，反映企业资本利用效率</li>
<li>固定资产周转率(Fixed asset turnover)&#x3D;营业收入&#x2F;期间平均固定资产，反映企业资本利用效率</li>
<li>存货周转率(Inventory turnover)&#x3D;<strong>营业成本</strong>&#x2F;期间平均存货，用于评估企业库存水平的合理性(多少变成商品了)</li>
<li>流动比率(Current Ratio)&#x3D;流动资产&#x2F;流动负债(&gt;&#x3D;2比较安全，国际上&gt;&#x3D;3比较安全，但国内银行倾向于短期贷款，新债还旧债)</li>
<li>速动比率(Quick Ratio)&#x3D;(流动资产-库存)&#x2F;流动负债，较为保守的<strong>评估企业偿还流动负债能力</strong>的指标</li>
<li><strong>财务杠杆</strong>(Asset to liability ratio)&#x3D;总负债&#x2F;总资产，也反映风险</li>
<li>总资产报酬率(ROA,资产净利率)&#x3D;净利润&#x2F;总资产</li>
<li><strong>净资产报酬率(ROE)</strong>&#x3D;净利润&#x2F;股东权益&#x3D;ROA*权益乘数&#x3D;ROA*(总资产&#x2F;股东权益)<ol>
<li>权益乘数&#x3D;总资产&#x2F;股东权益</li>
</ol>
</li>
<li>投资资本报酬率(ROIC)&#x3D;税前利润&#x2F;(净资产+有息负债)&#x3D;(税后利润+财务费用)&#x2F;(净资产+有息负债)</li>
<li>EBITDA(息税前利润)&#x3D;净利润+所得税</li>
</ol>
<p><strong>ROE-杜邦分析</strong> </p>
<p>一般而言，优秀公司的ROE在20%左右，体现在ROE持续的高或增速快。 那么我们作为企业管理者，要想提高企业ROE，可以采取以下途径： </p>
<p>a) 提高资产周转率：优化销售渠道、薄利多销、优化库存、定制市场战略等 </p>
<p>b) 提高净利润率：提高毛利率、提高营业收入、优化成本、政府扶持、税费优惠等 </p>
<p>c) 提高权益乘数：廉价的财务杠杆、提高负债率(假定总资产和利润不变)</p>
<h3 id="2-自由现金流估值模型"><a href="#2-自由现金流估值模型" class="headerlink" title="2.自由现金流估值模型"></a>2.自由现金流估值模型</h3><p><strong>进行企业估值之前，我们建议先对企业进行经营战略、战术上的研究，从而有一个定性的认识</strong></p>
<ol>
<li><strong>五力模型</strong>，用于进行行业分析，判断行业竞争是否激烈等等。从下述几个方面综合考量，<strong>现有竞争品，新产品，替代产品，购买方议价能力，供货方议价能力</strong></li>
<li><strong>企业的战略制定</strong>，是采取成本领先战略(低毛利、高周转)，还是差异化战略(高毛利、低周转)</li>
<li><strong>企业的战略执行</strong>，结合第二章中的财务比率，横向对比，考察公司战略执行情况</li>
</ol>
<p><strong>介绍现金流估值之前，先要讲一个机会成本的概念</strong>(类似β收益？)</p>
<ol>
<li><p><strong>机会成本(Opportunity cost)</strong>: 指股东&#x2F;债权人投资该企业，所放弃投资同行业&#x2F;其他产品的收益，一般反映行业平均盈利水平</p>
</li>
<li><p>那么企业经营的及格线是什么？首先要创造经济利润，其次ROIC大于机会成本</p>
</li>
<li><p>平均投资资本成本(WACC): 这里投资资本包括有息负债、股东权益。该指标可以用于判断所投资项目的风险</p>
<ul>
<li><p>投资资本(Invested Capital)&#x3D;有息负债+股东权益</p>
</li>
<li><p>投入资本回报率(ROIC)&#x3D;税后净利润 &#x2F; 投资资本</p>
</li>
<li><p>WACC&#x3D;有息负债&#x2F;投资资本⋅债务成本⋅(1−企业所得税税率)+股东权益&#x2F;投资资本⋅股本成本</p>
</li>
</ul>
</li>
<li><p><strong>经济利润</strong>(Economic Profit)&#x3D;excessReturn(超额收益)*投资资本&#x3D;(ROIC-WACC)*投资资本</p>
<ul>
<li>净利润大于0而经济利润小于0说明什么？说明企业不能为股东赚到钱，不能超过<strong>行业平均盈利水平</strong></li>
</ul>
</li>
</ol>
<p><strong>最终介绍一个自由现金流估值模型</strong> </p>
<p>公司自由现金流FCF&#x3D;净利润+财务费用+折旧及摊销-资本开支-净运营资本增加额</p>
<ul>
<li>净利润、财务费用，来自利润表</li>
<li>折旧及摊销，包括固定资产折旧、投资性房地产折旧、无形资产摊销，来自现金流量表的附表</li>
<li>资本支出&#x3D;-(投资性现金流流出小计-与经营无关的投资支出[比如购买理财])，来自现金流量表</li>
<li>运营资本&#x3D;(流动资产-现金)-(流动负债-短期借款)，来自资产负债表</li>
<li>净运营资本增加额&#x3D;今年的运营资本-去年的运营资本</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/Typora/typora-user-images/image-20230115102631106.png"><span class="image-caption">image-20230115102631106</span></p>
<h2 id="六、对公司进行财务预测"><a href="#六、对公司进行财务预测" class="headerlink" title="六、对公司进行财务预测"></a>六、对公司进行财务预测</h2><p>作为研究员的我们需要拍定企业财务指标的假设、构建勾稽关系、完成财务预测模型。</p>
<p><strong>基本假设&#x2F;预测</strong></p>
<ul>
<li><p>主营产品假设: 未来3年销售收入增长率(销售收入)、毛利率(销售成本)</p>
</li>
<li><p>盈利能力假设: 未来10年(一般未来3~10年的数值&#x3D;未来第3年的数值)，销售收入增长率、综合毛利率、一般行政开支占主营收入比例、研发支出占主营收入比例、销售费用&#x2F;销售收入、其他业务利润、营业外支出(资产置换、政府补助)、所得税税率、股利分配比率、盈余公积提取比例</p>
</li>
<li><p>营运效率假设: 未来10年，应收票据&#x2F;销售收入、应收账款周转天数、其他应收账款&#x2F;销售收入、预付账款&#x2F;销售成本、存货周转天数、待摊费用和其他流动资产&#x2F;营业费用和管理费用、应付票据&#x2F;销货成本、应付账款周转天数、预收账款&#x2F;销售收入、应付职工薪酬&#x2F;销货成本、应交税费&#x2F;主营税金和所得税、预提费用&#x2F;营业费用和管理费用、其他流动负债&#x2F;经营成本总额、坏账准备&#x2F;应收账款、其他长期资产绝对增加、其他长期负债绝对增加、少数股东损益&#x2F;税前利润、少数股东权益分红比例</p>
</li>
<li><p>债务和利息: 未来10年，最低现金金额占主营收入比例、盈余现金利率、公司长期债务利率、循环贷款利率</p>
</li>
<li><p>股本: 未来10年，原始总股本</p>
</li>
</ul>
<p><strong>投融资假设</strong></p>
<ul>
<li><p>交易性金融资产: 未来10年，起初成本&#x3D;去年期末成本；期末成本&#x3D;期初成本+本期成本增加；期末公允价值变动&#x3D;本期公允价值变动+去年期末公允价值变动；期末余额&#x3D;期末成本+期末公允价值变动</p>
</li>
<li><p>可供出售金融资产：未来10年，同上</p>
</li>
<li><p>持有至到期投资：未来10年，期初账面余额&#x3D;去年期末余额；投资收益&#x3D;(期初账面余额+去年减值准备合计)x票面利率+当期成本增加or减少x票面利率&#x2F;2；减值准备合计&#x3D;去年减值准备合计+当期计提减值准备；期末余额&#x3D;期初账面余额+当期成本增加or减少-当期计提减值准备</p>
</li>
<li><p>长期股权投资(成本法)：未来10年，同上，只不过不考虑票面利率，直接计算投资收益</p>
</li>
<li><p>长期股权投资(权益法)：未来10年，期初余额&#x3D;去年期末余额；当期分红&#x3D;去年投资收益累计x分红比例；投资收益累计&#x3D;去年投资收益累计+当期投资收益-当期分红；减值准备合计&#x3D;当期计提减值准备+去年减值准备合计；期末余额&#x3D;期初余额+当期成本增加or减少+当期投资收益-当期分红-当期计提减值准备</p>
</li>
<li><p>投资性房地产：未来10年，同交易性金融资产</p>
</li>
<li><p>固定资产投资计划：考虑企业销售有关的内生性增长，规模扩张型固定资产的增加额，在建工程期初值，在建工程转化率，年折旧率，当期计提减值准备等假设，预估未来10年的固定资产</p>
</li>
<li><p>无形资产投资：考虑本期新增无形资产、无形资产摊销率、本期计提减值准备等假设，估算期末无形资产额</p>
</li>
<li><p>股权融资(配股、转增、回购)：考虑未来发行股数、发行价格等假设，带来的资本公积变化及发行费用变动</p>
</li>
<li><p>普通债：考虑本期债券发行、票面利率等假设，带来的期末余额、利息</p>
</li>
<li><p>可转债：考虑本期可转债发行、当期票面利率、转股价格、转股比例等假设，带来的资本公积变化、利息</p>
</li>
<li><p>长期银行贷款：考虑未来长期银行贷款新增加额，计算循环利息，从而估算各期现金</p>
</li>
<li><p>公允价值变动合计</p>
</li>
</ul>
<p><strong>勾稽关系</strong></p>
<ul>
<li>利润表</li>
<li>资产负债表</li>
<li>现金流量表</li>
</ul>
<p><strong>财务预测的最终结果</strong></p>
<ul>
<li>股权自由现金流模型(FCFE)</li>
<li>超额收益模型(AE)</li>
</ul>
]]></content>
      <categories>
        <category>量化交易</category>
      </categories>
  </entry>
</search>
