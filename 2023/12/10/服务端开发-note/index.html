

<!DOCTYPE html>
<html lang="zh-CN" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>NJU-服务端开发-学习笔记 - 安然无恙</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  <meta name="keywords" content=", 数据库">
  <meta name="description" content="涉及Spring、Springboot、Spring ...">
  <meta name="author" content="Anran Liang">
  <link rel="icon" href="/images/icons/icon-16.png" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/icon-32.png" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/icon-60@3x.png" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/icon-1024.png" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/icon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="https://at.alicdn.com/t/font_1445822_p6ry5n7lrr.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      loading: {
        gif: '/images/theme/loading.gif',
        lottie: ''
      },
      lazyload: {
        enable: false,
        only_post: 'false',
        loading: {
          gif: '/images/theme/loading.gif',
          lottie: ''
        }
      },
      donate: {
        enable: false,
        alipay: 'https://pic.izhaoo.com/alipay.jpg',
        wechat: 'https://pic.izhaoo.com/wechat.jpg'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: true
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: 'Intellectual curiosity',
          typing: true,
          api: '',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'image',
        image: 'https://lar-blog.oss-cn-nanjing.aliyuncs.com/page/vx.JPG',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'default'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: false,
        path: 'search.xml'
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 6.3.0"></head>

<body class="lock-screen">
  <div class="loading" id="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
    </div>
    <div class="center">NJU-服务端开发-学习笔记</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/galleries/ " class="underline "> 摄影</a>
      </li><li class="menu-item">
        <a href="/archives/ " class="underline "> 文章</a>
      </li><li class="menu-item">
        <a href="/categories/ " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于我</a>
      </li></ul>
    
      <div class="menu-copyright">Created by Anran with 💗 <br> <p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a> theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p> @2022-2025</div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/gallery/gallery/%E9%A3%8E%E5%85%89/5D4F56FB9E1CB22675B95332AE79BE23.png" draggable="false">
  <div class="head-mask">
    <h1 class="head-title">NJU-服务端开发-学习笔记</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>十二月 10, 2023</span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>30177</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        
          <p><p>涉及Spring、Springboot、Spring Cloud、AOP、微服务等后端常用技术栈</p></p>
        
        <h1 id="Lecture-1-第一个Spring-boot程序"><a href="#Lecture-1-第一个Spring-boot程序" class="headerlink" title="Lecture 1 第一个Spring boot程序"></a>Lecture 1 第一个Spring boot程序</h1><ul>
<li>git</li>
<li>一个简单的springboot程序<ul>
<li>框架</li>
<li>maven</li>
<li>themyleaf快速构建网页</li>
<li>liveroad热部署</li>
</ul>
</li>
<li>Junit<ul>
<li>(public) void开头</li>
<li>assert</li>
<li><code>StandardOutputStreamLog</code>工具可以收集打到控制台的内容</li>
</ul>
</li>
</ul>
<h1 id="Lecture-2-spring依赖注入"><a href="#Lecture-2-spring依赖注入" class="headerlink" title="Lecture 2 spring依赖注入"></a>Lecture 2 spring依赖注入</h1><p>spring的核心是提供了容器+依赖注入+AOP切面编程</p>
<ul>
<li><p>bean在容器之中</p>
</li>
<li><p>库存Bean注入到商品Bean中（在商品类中，spring帮忙new 库存）</p>
<ul>
<li><p>三种注入方式：</p>
<ul>
<li>类的构造方法</li>
<li>setter方法，set属性</li>
<li>私有属性上加@Autowired</li>
</ul>
</li>
<li><p>不可以通过方法参数注入</p>
</li>
</ul>
</li>
<li><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230914185655677.png"><span class="image-caption">image-20230914185655677</span></p>
</li>
</ul>
<h2 id="三种配置Bean方式"><a href="#三种配置Bean方式" class="headerlink" title="三种配置Bean方式"></a>三种配置Bean方式</h2><ul>
<li><p>顺便配置Bean间的依赖关系</p>
</li>
<li><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230914185947340.png"><span class="image-caption">image-20230914185947340</span></p>
</li>
</ul>
<h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><ul>
<li>方便自定义override</li>
<li>实例化（new）</li>
<li>name：获取名字<ul>
<li>@Override  setBeanName</li>
</ul>
</li>
<li>factory：产生工厂接口</li>
<li>context<ul>
<li>@Override  setApplicationContext以获取Bean信息，在业务逻辑中使用</li>
</ul>
</li>
<li>…</li>
<li>销毁</li>
</ul>
<p>应用上下文</p>
<ul>
<li>建议根据接口编程</li>
</ul>
<h2 id="自动化配置例子（优先）："><a href="#自动化配置例子（优先）：" class="headerlink" title="自动化配置例子（优先）："></a>自动化配置例子（优先）：</h2><ul>
<li>@Component：将Class注册实例化为Bean<ul>
<li>@Component()可以指定Bean的name</li>
</ul>
</li>
<li>@Autowured：注入（对象参数&#x2F;构造器&#x2F;Setter）时需注解。spring从容器上下文寻找实现了接口的对象，并注入当前类（相当于new 子属性）<ul>
<li>若唯一，则返回</li>
<li>若不存在&#x2F;不唯一，则报错</li>
<li>@primary可指定优先注入的类</li>
</ul>
</li>
<li>Object&#x3D;Bean&#x3D;Component(更业务)</li>
<li>@Configuration  总配置类<ul>
<li>上下文可以基于配置类来建立（较为推荐）</li>
<li>@ComponentScan：扫描文件夹中所有的Bean，建立Spring上下文<ul>
<li>等价 &lt;context:component-scan base-package&#x3D;“…”&#x2F;&gt;</li>
<li>基础包（basePackages&#x3D;{“…”,”…”})<ul>
<li>类型不安全：Scan的文件夹目录会变</li>
<li>解决方案：basePackageClasses&#x3D;{.class,.class}建立TagClass标识根文件夹</li>
</ul>
</li>
</ul>
</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230914193437131.png"><span class="image-caption">image-20230914193437131</span></li>
</ul>
</li>
</ul>
<p>JavaConfig例子：</p>
<ul>
<li>不建议把业务代码放入。有可能跳过执行</li>
<li>更适用于改编第三方代码</li>
<li>自动化配置有时会行不通，如：第三方库</li>
<li>@Configuration：配置类</li>
<li>@Bean(name&#x3D;“..”)：提供实例化Bean的逻辑<ul>
<li>Spring的Bean默认使⽤单例模式，只会创建⼀个：在调⽤构造⽅法时会被Spring截获，如果已经new过了就不会再继续new。也可以⼿动指定不⽤Singleton模式（@Scope带参数，可以指定prototype，⽤⼀个创建⼀次</li>
</ul>
</li>
</ul>
<p>xml例子（特殊场景）：</p>
<ul>
<li>构造器注入<ul>
<li><constructor-arg></constructor-arg></li>
<li>c-命名空间</li>
<li>注入字面量值 vase</li>
<li>注入集合</li>
</ul>
</li>
<li>属性注入<ul>
<li>p-命名空间</li>
<li>util-命名空间</li>
</ul>
</li>
<li>ref：引用(用于如list构造、constructor-arg)</li>
<li>value：赋值</li>
</ul>
<p>混合配置类例子：</p>
<ul>
<li><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230914205612870.png"><span class="image-caption">image-20230914205612870</span></p>
</li>
<li><p>@Configuration</p>
<p>@Import(xxx.class)</p>
<p>@ImportResource(“&#x2F;&#x2F;xml path”)</p>
</li>
<li><p>XML中导入</p>
<ul>
<li>&lt;import resource&#x3D;’xml’&#x2F;&gt;</li>
<li></li>
</ul>
</li>
</ul>
<p> —往后考试不考—</p>
<p>Profile选择性配置，类似#ifdef：</p>
<ul>
<li>方法定义：<ul>
<li>@Bean</li>
<li>@Profile(“prov”)</li>
</ul>
</li>
<li>激活<ul>
<li>spring.profiles.default</li>
<li>spring.profiles.active</li>
<li>@ActiveProfiles(“dev”)</li>
</ul>
</li>
</ul>
<p>Conditional条件注入例子：</p>
<ul>
<li><p>@Bean或@Component</p>
</li>
<li><p>@Conditional(**.class)</p>
</li>
<li><p>接口</p>
<ul>
<li><p>Condition{</p>
<p>boolean matches(…)</p>
<p>}</p>
</li>
</ul>
</li>
</ul>
<p>自动装配的歧义：</p>
<ul>
<li>@Primary优先注入</li>
<li>定义时<ul>
<li>@Componet或@Bean</li>
<li>@Qualifier(“…”)自定义限定符</li>
</ul>
</li>
<li>使用时<ul>
<li>@Autowired</li>
<li>@Qualifier(“…”) bean名称或自定义限定符，默认Bean名是限定符</li>
</ul>
</li>
</ul>
<h1 id="Lecture-3-AOP切面编程"><a href="#Lecture-3-AOP切面编程" class="headerlink" title="Lecture 3 AOP切面编程"></a>Lecture 3 AOP切面编程</h1><h2 id="横切关注点（cross-cutting-concern）"><a href="#横切关注点（cross-cutting-concern）" class="headerlink" title="横切关注点（cross-cutting concern）"></a>横切关注点（cross-cutting concern）</h2><ul>
<li>关注共有的可以抽象出来的操作<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230921192144754.png"><span class="image-caption">image-20230921192144754</span></li>
</ul>
</li>
<li>举例：<ul>
<li>日志</li>
<li>安全</li>
<li>事务 </li>
<li>缓存</li>
</ul>
</li>
</ul>
<h2 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h2><ul>
<li>通知（Advice）：切面做什么以及何时做<ul>
<li>what + when</li>
</ul>
</li>
<li>切点（Pointcut）：何处<ul>
<li>具体where</li>
</ul>
</li>
<li>切面（Aspect）：Advice和Pointcut的结合</li>
<li>连接点（Join point）：方法(spring ) | 字段修改、构造方法(其他)<ul>
<li>可以切的地方</li>
</ul>
</li>
<li>引入（introduction）：引入新的行为和状态<ul>
<li>动态给类添加新方法</li>
</ul>
</li>
<li>织入（Weaving）：切面应用到目标对象的过程</li>
</ul>
<h2 id="通知-Advice）类型"><a href="#通知-Advice）类型" class="headerlink" title="通知(Advice）类型"></a>通知(Advice）类型</h2><ul>
<li>@Before 在某连接点之前执行的通知<ul>
<li>“execution(*  包名.接口名.方法名(参数类型) )”</li>
<li>实例化切面Bean,注解</li>
</ul>
</li>
<li>@After</li>
<li>@AfterReturning</li>
<li>@AfterThrowing 出现意外</li>
<li>@Around 环绕通知可以在方法调用前后完成自定义的行为<ul>
<li>相当于前四个的混合，更自由。可以控制返回值</li>
<li>joinPoint.proceed()  调用切面方法</li>
</ul>
</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230921201439967.png"><span class="image-caption">image-20230921201439967</span><ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230921194712381.png"><span class="image-caption">image-20230921194712381</span></li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230921194937329.png"><span class="image-caption">image-20230921194937329</span></li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230921194952447.png"><span class="image-caption">image-20230921194952447</span></li>
</ul>
</li>
<li>原理:Proxy代理<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230921201906728.png"><span class="image-caption">image-20230921201906728</span></li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230921200647533.png"><span class="image-caption">image-20230921200647533</span></li>
</ul>
</li>
</ul>
<h2 id="切点指示器"><a href="#切点指示器" class="headerlink" title="切点指示器"></a>切点指示器</h2><ul>
<li>Pointout法	<ul>
<li>@Pointcut( “execution(* soundsystem.CompactDisc.playTrack( int )) “ + “&amp;&amp; args(trackNumber) &#x2F;&#x2F;获取参数<br>&amp;&amp; within(soundsystem.*) &#x2F;&#x2F;限定包路径<br>&amp;&amp; bean(sgtPeppers) “) &#x2F;&#x2F;限定bean名称，或者： &amp;&amp; !bean(sgtPeppers)</li>
</ul>
</li>
<li>注解法<ul>
<li>@Around(“@annotation(innerAuth)”) &#x2F;&#x2F;限定注解<br>public Object innerAround(ProceedingJoinPoint point, InnerAuth innerAuth) { … }<br>@InnerAuth public R register(@RequestBody SysUser sysUser) { … }</li>
</ul>
</li>
</ul>
<p>多代理类注入</p>
<ul>
<li>增强Bean。在不改变原类的前提下，利用切面新增方法</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230921212102249.png"><span class="image-caption">image-20230921212102249</span></li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230921212516346.png"><span class="image-caption">image-20230921212516346</span></li>
</ul>
<h1 id="Lecture-4-spring-MVC"><a href="#Lecture-4-spring-MVC" class="headerlink" title="Lecture 4 spring MVC"></a>Lecture 4 spring MVC</h1><h2 id="model-view-control"><a href="#model-view-control" class="headerlink" title="model -view-control"></a>model -view-control</h2><ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20230930002053524.png"><span class="image-caption">image-20230930002053524</span></li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231007183839364.png" style="zoom:200%;"><span class="image-caption">image-20231007183839364</span>
* 1.必经servlet
* 2.映射路径
* 3.获取参数，映射到controller
* 4.servlet通过controller获取数据与视图
* 5.servlet解析视图</li>
</ul>
<p>类前注解</p>
<ul>
<li><code>@Slf4j</code>：这是Lombok库提供的注解，用于自动生成日志记录器（Logger）。在使用<code>@Slf4j</code>注解后，可以直接使用<code>log</code>字段进行日志记录，而无需手动创建Logger对象。例如，<code>log.info(&quot;Message&quot;)</code>。</li>
<li><code>@Controller</code>：等价于@component。这是Spring框架提供的注解，用于标识一个类作为控制器组件。控制器处理传入的HTTP请求，并返回相应的视图或数据。使用<code>@Controller</code>注解后，Spring会自动识别该类并将其作为控制器进行管理。</li>
<li><code>@RequestMapping(&quot;/design&quot;)</code>：这是Spring MVC框架提供的注解，用于映射HTTP请求到相应的处理方法。在这个例子中，<code>@RequestMapping</code>注解指定了路径为”&#x2F;design”，表示该控制器处理的请求路径为”&#x2F;design”开头的请求。</li>
</ul>
<p>请求映射注解</p>
<ul>
<li>@RequestMapping</li>
<li>@GetMapping </li>
<li>@PostMapping </li>
<li>@PutMapping </li>
<li>@DeleteMapping </li>
<li>@PatchMapping</li>
</ul>
<h2 id="模型数据绑定"><a href="#模型数据绑定" class="headerlink" title="模型数据绑定"></a>模型数据绑定</h2><ul>
<li><p><code>@ModelAttribute</code>：这是 Spring MVC 框架提供的注解，用于将方法参数或方法返回值绑定到模型中。当使用 <code>@ModelAttribute</code> 注解修饰方法时，该方法会在每次请求处理之前被调用，用于准备模型数据。当使用 <code>@ModelAttribute</code> 注解修饰方法参数时，它会从模型中获取对应的属性值，并将其绑定到方法参数中。</p>
<ul>
<li><p>@ModelAttribute标注在方法上时，说明该方法是用于添加一个或多个属性到model上；这样的方法能接收@RequestMapping注解相同的参数类型，只不过不能直接被映射到具体的请求上；</p>
<ul>
<li>当@ModelAttribute注解标注返回值为void的方法时，需要传入Model参数，并使用<code>model.addAttribute()</code>方法手动的往Model上绑定数据。</li>
</ul>
</li>
<li><p>@ModelAttribute标注在方法参数上时，说明该方法参数的值将由model中取得；如果model中找不到，那么该参数会先被实例化，然后被添加到model中；在model中存在以后，请求中所有名称匹配的参数都会填充到该参数中；</p>
</li>
<li><p>这在Spring MVC中被称为数据绑定，一个非常有用的特性，我们不用每次都手动从表格数据中转换这些字段数据；</p>
</li>
</ul>
</li>
<li><p><code>@SessionAttributes</code>：这是 Spring MVC 框架提供的注解，用于指定模型属性的值将存储在会话（Session）中。通过 <code>@SessionAttributes</code> 注解，可以将模型中的指定属性值暂时存储在会话中，以便在多个请求之间共享该属性的值。通常与 <code>@ModelAttribute</code> 注解一起使用，以确保在多个请求之间保持一致的模型属性值</p>
</li>
<li><p>Model属性会复制到Servlet Request属性中，这样视图中就可以使用它们用于渲染页面</p>
<ul>
<li>Servlet Request 是 Java Servlet 规范中定义的一个类，用于表示客户端发起的 HTTP 请求。它包含了请求的各种信息，如请求方法、URL、请求头、请求参数等。通过 Servlet Request，开发人员可以获取并处理客户端发送的请求数据。</li>
<li>servlet是⼀个⼩粒度的运⾏单位<ul>
<li>Tomcat:webserver 是⼀个web容器，可运⾏，⾥⾯装的是servlet（有许多servlet）</li>
<li>servlet处理客户端请求request，返回response</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>SpringMVC获取参数的方式 、Converter </p>
<ul>
<li>Converter 负责将前端传来String格式的表单，转换成Ingredient</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231007184128914.png"><span class="image-caption">image-20231007184128914</span></li>
</ul>
<p>校验</p>
<ul>
<li>领域类上添加校验规则 </li>
<li>控制器中声明校验：@Valid</li>
</ul>
<h2 id="使用视图控制器（View-Controller）"><a href="#使用视图控制器（View-Controller）" class="headerlink" title="使用视图控制器（View Controller）"></a>使用视图控制器（View Controller）</h2><ul>
<li>如果一个控制器非常简单，不需要填充模型或处理输入</li>
<li>继承接口WebMvcConfigurer，用于配置 </li>
<li>简单的从请求URL到视图 registry.addViewController(“&#x2F;“).setViewName(“home”); &#x2F;&#x2F;GET请求</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231001123912054.png"><span class="image-caption">image-20231001123912054</span></li>
</ul>
<p>@data</p>
<ul>
<li>生成setter和getter</li>
<li>Lombok是编译期的东西</li>
</ul>
<h1 id="Lecture-5-数据持久化"><a href="#Lecture-5-数据持久化" class="headerlink" title="Lecture 5 数据持久化"></a>Lecture 5 数据持久化</h1><p>Java数据库连接（Java Database Connectivity，JDBC）和Java持久化API（Java Persistence API，JPA）是两个常用的技术。</p>
<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a><strong>JDBC</strong></h2><p>是Java平台提供的一组API，用于在Java应用程序和各种关系型数据库之间建立连接和执行数据库操作。JDBC允许开发人员使用Java代码来执行诸如查询、插入、更新和删除等数据库操作。它提供了一种标准的方式来访问不同数据库系统，独立于具体的数据库实现。通过JDBC，开发人员可以使用Java语言编写数据库驱动程序，连接到数据库并执行SQL语句。</p>
<ul>
<li><p>JDBC的主要组件包括：</p>
<ul>
<li><p><strong>DriverManager</strong>：用于管理数据库驱动程序的类，负责建立数据库连接。</p>
</li>
<li><p><strong>Connection</strong>：表示与数据库的连接，可以执行SQL语句和事务管理。</p>
</li>
<li><p><strong>Statement</strong>：用于执行SQL语句的接口，包括创建、执行和处理结果等操作。</p>
</li>
<li><p><strong>ResultSet</strong>：表示数据库查询结果集，可以遍历和操作查询结果。</p>
</li>
</ul>
</li>
<li><p>使用JDBC时，开发人员需要手动编写SQL语句、处理连接、事务和结果集等细节。虽然JDBC提供了灵活性和直接控制数据库的能力，但对于大型应用程序或复杂的数据库操作，编写和维护大量的JDBC代码可能变得繁琐和冗长。</p>
</li>
</ul>
<h2 id="JDBC-template"><a href="#JDBC-template" class="headerlink" title="JDBC template"></a>JDBC template</h2><ul>
<li>JdbcTemplate是Spring Framework提供的一个用于简化JDBC（Java Database Connectivity）操作的类库。它封装了JDBC的底层细节，提供了一组简单而强大的方法来执行SQL查询、更新和批处理等操作。</li>
<li>JdbcTemplate简化了JDBC的使用，减少了样板代码的编写，并提供了异常处理和资源管理等功能。它是Spring框架中数据访问对象（DAO）模式的核心组件之一，用于与关系型数据库进行交互。</li>
<li>H2数据库是一个基于Java的嵌入式关系型数据库管理系统（RDBMS）。它提供了一个轻量级、快速、可嵌入的数据库解决方案，适用于开发和测试环境。H2数据库支持标准SQL语法和JDBC API，可以通过内存模式或嵌入式模式在应用程序中嵌入和使用。<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231008142847877.png"><span class="image-caption">image-20231008142847877</span></li>
</ul>
</li>
</ul>
<h3 id="生成TABLE"><a href="#生成TABLE" class="headerlink" title="生成TABLE"></a>生成TABLE</h3><p>如果在应⽤的根类路径下存在名为schema.sql的⽂件，那么在应⽤启动的时候将会基于数据库执⾏这个⽂件中的SQL。所以，我们需要将程序清单3.8中的内容保存为名为schema.sql的⽂件并放到“src&#x2F;main&#x2F;resources”⽂件夹下。</p>
<p>我们可能还希望在数据库中预加载⼀些配料数据。幸运的是，Spring Boot还会在应⽤启动的时候执⾏根类路径下名为data.sql的⽂件。将其保存到“src&#x2F;main&#x2F;resources&#x2F;data.sql”⽂件中。</p>
<ul>
<li>其他方法：</li>
<li>CommandLineRunner</li>
<li>Applycation.run</li>
</ul>
<h3 id="Repository的实现"><a href="#Repository的实现" class="headerlink" title="Repository的实现"></a>Repository的实现</h3><ul>
<li>@Repository</li>
<li>接口: RowMapper<T>，可以使用lambda表达式</T></li>
<li>注入DesignTacoController，使用IngredientByldConverter实现优化</li>
<li>identity字段由数据库自动生成值，获取返回的ID，GeneratedKeyHolder <ul>
<li>PreparedStatementCreatorFactory </li>
<li>PreparedStatementCreator</li>
<li>jdbcOperations.update</li>
</ul>
</li>
</ul>
<h2 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h2><ul>
<li>QLException <ul>
<li>发生异常时很难恢复 ✓ 难确定异常类型</li>
</ul>
</li>
<li>Hibernate异常<ul>
<li>定义了许多具体异常，方便定位问题 ✓ 对业务对象的侵入</li>
</ul>
</li>
<li>Spring所提供的平台无关的持久化异常<ul>
<li>DataAccessException ✓ 具体异常，方便定位问题 ✓ 隔离具体数据库平台</li>
</ul>
</li>
</ul>
<h2 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a><strong>JPA</strong></h2><p>是Java平台的Java持久化规范，提供了一种更高级别的抽象，用于简化Java应用程序与数据库之间的交互。JPA的目标是提供一种对象关系映射（Object-Relational Mapping，ORM）的解决方案，将Java对象与数据库表之间进行映射。</p>
<ul>
<li><p>JPA的核心概念包括：</p>
<ul>
<li><p><strong>实体类</strong>（Entity）：用于表示数据库中的表，通过注解或XML配置与数据库表进行映射。</p>
</li>
<li><p><strong>EntityManager</strong>：类似于JDBC中的Connection，用于管理实体对象的生命周期、执行数据库操作以及处理事务。</p>
</li>
<li><p><strong>JPQL</strong>（Java Persistence Query Language）：类似于SQL的查询语言，用于查询和操作实体对象。</p>
</li>
</ul>
</li>
<li><p>JPA提供了一种面向对象的编程模型，将数据库操作转化为对Java对象的操作，避免了直接编写SQL语句和处理数据库连接的繁琐工作。它还提供了缓存、延迟加载、事务管理等高级特性，简化了开发过程并提高了应用程序的可维护性。</p>
</li>
<li><p>JPA是一个规范，不是具体的实现。常见的JPA实现包括Hibernate、EclipseLink、OpenJPA等。开发人员可以根据具体需求选择适合的JPA实现来与数据库进行交互，并使用JPA提供的API进行开发。</p>
</li>
</ul>
<p>综上所述，JDBC是一种低级别的数据库访问API，提供了直接的数据库连接和操作能力，而JPA是一种高级别的ORM规范，提供了更简化和面向对象的数据库访问方式。在选择使用JDBC还是JPA时，需要根据具体的应用场景和需求来决定。</p>
<h3 id="生成TABLE-1"><a href="#生成TABLE-1" class="headerlink" title="生成TABLE"></a>生成TABLE</h3><ul>
<li>@Entity</li>
<li>@Table(name&#x3D;”Taco_Order”)</li>
<li>@OneToMany<ul>
<li>生成关联表</li>
</ul>
</li>
<li>@NoArgsConstructor注解。JPA需要实体有⼀个⽆参的构造器.</li>
</ul>
<h3 id="repository查询方法"><a href="#repository查询方法" class="headerlink" title="repository查询方法"></a>repository查询方法</h3><p>继承CRUD</p>
<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231008164713521.png"><span class="image-caption">image-20231008164713521</span></li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231008164834610.png"><span class="image-caption">image-20231008164834610</span></li>
</ul>
<p>定义查询方法，无需实现</p>
<ul>
<li>领域特定语言(domain-specific language，DSL)，spring data的命名约定</li>
<li>查询动词＋主题＋断言</li>
<li>查询动词: get、read、find、count</li>
<li>例子:<br>List<TacoOrder> findByDeliveryZip( String deliveryZip );</TacoOrder></li>
</ul>
<p>声明自定义查询</p>
<ul>
<li><p>不符合方法命名约定时，或者命名太长时</p>
</li>
<li><p>@Query(“Order o where o.deliveryCity &#x3D; ‘Seattle”)</p>
<p>List<TacoOrder> readOrdersDeliveredInSeattle( );</TacoOrder></p>
</li>
</ul>
<h3 id="两个好处"><a href="#两个好处" class="headerlink" title="两个好处"></a>两个好处</h3><ul>
<li>便于做mock测试</li>
<li>更改时只需更改Repository</li>
</ul>
<h1 id="Lecture-6-非关系数据库"><a href="#Lecture-6-非关系数据库" class="headerlink" title="Lecture 6 非关系数据库"></a>Lecture 6 非关系数据库</h1><h2 id="MongeDB"><a href="#MongeDB" class="headerlink" title="MongeDB"></a>MongeDB</h2><ul>
<li>分布式</li>
<li>类json格式</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231012185636855.png"><span class="image-caption">image-20231012185636855</span></li>
</ul>
<ol>
<li>基本的CRUD操作：<ul>
<li>创建数据库：使用<code>use &lt;database_name&gt;</code>命令创建一个新的数据库。</li>
<li>创建集合：使用<code>db.createCollection(&quot;&lt;collection_name&gt;&quot;)</code>命令创建一个新的集合。</li>
<li>插入文档：使用<code>db.&lt;collection_name&gt;.insertOne(&lt;document&gt;)</code>命令插入一个文档到指定集合。</li>
<li>查询文档：使用<code>db.&lt;collection_name&gt;.find(&lt;query&gt;)</code>命令查询符合条件的文档。</li>
<li>更新文档：使用<code>db.&lt;collection_name&gt;.updateOne(&lt;filter&gt;, &lt;update&gt;)</code>命令更新符合条件的文档。</li>
<li>删除文档：使用<code>db.&lt;collection_name&gt;.deleteOne(&lt;filter&gt;)</code>命令删除符合条件的文档。</li>
</ul>
</li>
<li>高级查询和操作：<ul>
<li>使用查询运算符和条件语句来执行更复杂的查询操作。</li>
<li>学习索引的创建和使用，以提高查询性能。</li>
<li>学习如何使用聚合管道进行数据聚合和数据处理操作。</li>
<li>学习MongoDB的数据备份和恢复方法，以及复制和分片等高可用性和扩展性特性。</li>
</ul>
</li>
</ol>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ul>
<li><p>Key-value的Hash表结构</p>
</li>
<li><p>存在内存，速度快。也可以持久化</p>
</li>
<li><p>主要作缓存。低延迟</p>
</li>
<li><p>常用作集群，有主从复制</p>
</li>
</ul>
<ol>
<li>Redis的基本操作：<ul>
<li>设置键值对：使用<code>SET</code>命令设置一个键值对。</li>
<li>获取值：使用<code>GET</code>命令获取一个键对应的值。</li>
<li>存储列表：使用<code>LPUSH</code>和<code>RPUSH</code>命令将值添加到列表的左侧或右侧。</li>
<li>存储哈希：使用<code>HSET</code>命令将字段和值添加到哈希中。</li>
<li>存储集合：使用<code>SADD</code>命令将值添加到集合中。</li>
<li>存储有序集合：使用<code>ZADD</code>命令将带有分数的成员添加到有序集合中。</li>
</ul>
</li>
<li>Redis的高级功能：<ul>
<li>使用过期时间：设置键的过期时间，让Redis自动删除过期的键。</li>
<li>发布和订阅：使用<code>PUBLISH</code>命令发布消息，使用<code>SUBSCRIBE</code>命令订阅消息。</li>
<li>事务：使用<code>MULTI</code>和<code>EXEC</code>命令执行一系列命令作为一个事务。</li>
<li>Lua脚本：使用Redis的Lua脚本功能执行复杂的操作。</li>
<li>持久化：了解Redis的持久化机制，将数据保存到磁盘上。</li>
</ul>
</li>
</ol>
<ul>
<li><p>链接java</p>
<ul>
<li><p>新增键值对</p>
<ul>
<li><pre><code>redis.opsForValue().set(product.getSku(), product);
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><br>    <br><br>* 新增<span class="hljs-built_in">set</span><br><br>  * ```<br>    redisTemplate.opsForSet().<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;cart&quot;</span>, product);<br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>序列化是必须的</p>
<ul>
<li><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231012205511018.png"><span class="image-caption">image-20231012205511018</span></p>
</li>
<li><pre><code class="java">redis.setKeySerializer(new StringRedisSerializer());
redis.setValueSerializer(new Jackson2JsonRedisSerializer&lt;Product&gt;(Product.class));
redis.afterPropertiesSet(); // if this were declared as a bean, you wouldn&#39;t have to do this
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-section"># Lecture 7 Spring Securety</span><br><br><span class="hljs-section">## cookie</span><br><br><span class="hljs-bullet">*</span> HTTP 协议是一种用于在客户端和服务器之间传输超文本的协议。它是无状态的，这意味着每个请求都是独立的，服务器不会记住之前的请求。然而，有时候需要在多个请求之间保持一些状态信息，这就是 Cookie 的作用。<br><span class="hljs-bullet">*</span> 当服务器发送 HTTP 响应时，它可以在响应头中包含一个 Set-Cookie 标头，其中包含了一个或多个键值对，用于设置 Cookie 的属性，如名称、值、过期时间、域名、路径等。客户端（通常是Web浏览器）在接收到这个响应时会将这些 Cookie 保存在本地。<br><span class="hljs-bullet">*</span> 之后，当客户端发送新的 HTTP 请求时，它会在请求头中包含一个 Cookie 标头，其中包含了保存的 Cookie 信息。服务器可以读取这些 Cookie，识别客户端，并根据需要采取相应的操作。例如，服务器可以使用 Cookie 来跟踪用户的会话、存储用户的首选项、实现购物车功能，判断客户端是否登录。<br><br><span class="hljs-section">## Basic 认证</span><br><br>在 HTTP 协议中，Basic 认证是一种简单的身份验证机制。它通过在 HTTP 请求的头部添加一个名为 &quot;Authorization&quot; 的字段，将用户名和密码以 Base64 编码的形式发送给服务器来进行身份验证。<br><br>Basic 认证的工作流程如下：<br><br><span class="hljs-bullet">1.</span> 客户端发送 HTTP 请求到服务器，并在请求头部添加 &quot;Authorization&quot; 字段。<br><span class="hljs-bullet">2.</span> &quot;Authorization&quot; 字段的值为 &quot;Basic&quot; 加上用户名和密码的 Base64 编码。格式为：<span class="hljs-code">`Basic &lt;base64encoded(username:password)&gt;`</span>。<br><span class="hljs-bullet">3.</span> 服务器接收到请求后，检查 &quot;Authorization&quot; 字段的值。<br><span class="hljs-bullet">4.</span> 服务器将 &quot;Authorization&quot; 字段的值进行解码，并获取用户名和密码。<br><span class="hljs-bullet">5.</span> 服务器使用解码后的用户名和密码进行验证，通常是比对存储在服务器上的用户凭据。<br><span class="hljs-bullet">6.</span> 如果验证成功，服务器返回请求的资源；如果验证失败，服务器返回 HTTP 401 Unauthorized 响应。<br><br><span class="hljs-section">## Securety</span><br><br>用户需要做的：![<span class="hljs-string">image-20231026184904538</span>](<span class="hljs-link">https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231026184904538.png</span>)<br><br><span class="hljs-bullet">1.</span> 继承UserDetailsService，自定义User类<br><span class="hljs-bullet">2.</span> 实现登录视图<br><span class="hljs-bullet">3.</span> 实现FilterChain，配置合法用户<br><span class="hljs-bullet">   1.</span> <span class="hljs-code">`FilterChain`</span> 是 Spring Security 中的过滤器链，用于处理请求的安全过滤器。每个请求都会经过一系列的过滤器，用于验证身份、授权访问等操作。过滤器链由多个过滤器组成，并按照一定的顺序依次执行。<br><span class="hljs-bullet">   2.</span> 身份验证：过滤器链中的某些过滤器负责身份验证，检查请求中的身份凭证（如用户名和密码、令牌等），并将其与预先配置的用户信息进行比对，以确定请求是否来自有效的身份。<br><span class="hljs-bullet">   3.</span> 访问控制：过滤器链中的其他过滤器负责访问控制，根据配置的规则和权限信息，判断请求是否有权限访问特定的资源。根据规则的配置，可以允许或拒绝请求的访问。<br><span class="hljs-bullet">   4.</span> 处理安全相关的操作：过滤器链还可以处理一些安全相关的操作，如跨站请求伪造（CSRF）防护、XSS（跨站脚本攻击）防护、会话管理等。<br><span class="hljs-bullet">4.</span> 继承WebSecurityConfigureAdapter<br><span class="hljs-bullet">   1.</span> 重写其中的方法，可以定义安全规则、身份验证方式、访问控制等安全相关的配置。<br><span class="hljs-bullet">   2.</span> 提供了默认的安全配置：<span class="hljs-code">`WebSecurityConfigurerAdapter`</span> 类提供了一组默认的安全配置，包括关闭跨站请求伪造（CSRF）防护、启用 HTTP Basic 认证、配置默认登录页面等。通过继承并重写需要修改的方法，可以对默认配置进行定制。<br><span class="hljs-bullet">   3.</span> 配置安全策略：通过重写 <span class="hljs-code">`configure()`</span> 方法，可以添加自定义的安全规则。例如，可以配置哪些 URL 需要进行身份验证、使用哪种身份验证方式、定义访问规则等。这些配置可以基于角色、权限或其他条件来限制用户的访问权限。<br><span class="hljs-bullet">   4.</span> 定义认证方式：通过重写 <span class="hljs-code">`configure(AuthenticationManagerBuilder)`</span> 方法，可以指定身份验证方式。可以使用内存中的用户、数据库中的用户、LDAP、OAuth 等多种方式进行身份验证。<br><br>框架做的：<br><br>1、实现用户登录控制器(get、post)|<br>2、请求重定向到用户登录页面<br>3、通过Filter对设定的权限进行控制权限不通过报以下错误:<br><br><span class="hljs-section">### 自动配置</span><br><br>Spring Securety加入pom.xml后，会有HTTP basic认证对话框并提示你认证。<br><br>要想通过这个认证，你需要⼀个⽤户名和密码。⽤户名为user，⽽密码则是随机⽣成的，它会被写⼊应⽤的⽇志⽂件中。⽇志条⽬⼤致如下<br><br><span class="hljs-bullet">*</span> <span class="hljs-code">```sql</span><br><span class="hljs-code">  Using default security password: 087cfc6a-027d-44bc-95d7-cbb3a798a1ea</span><br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<p>通过将security starter添加到项目的构建文件中，我们得到了如下的自动配置的安全特性∶</p>
<ul>
<li>所有的HTTP请求路径都需要认证;</li>
<li>不需要特定的角色和权限,</li>
<li>没有登录页面，认证过程是通过HTTP basic认证对话框实现的;</li>
<li>系统只有一个用户，用户名为user</li>
</ul>
<p>为了满足Taco Cloud的安全需求，我们需要编写一些显式的配置，覆盖掉自动配置为我们提供的功能。我们首先配置一个合适的用户存储，这样就能有多个用户了。</p>
<ul>
<li>基于内存的用户存储;</li>
<li>基于JDBC的用户存储﹔</li>
<li>以LDAP作为后端的用户存储﹔</li>
<li>自定义用户详情服务。</li>
</ul>
<p>不管使用哪种用户存储，你都可以通过覆盖<br>WebSecurityConfigurerAdapter基础配置类中定义的configure()方法来进行配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span><br> <span class="hljs-keyword">throws</span> Exception &#123;<br> auth<br> .jdbcAuthentication()<br> .dataSource(dataSource)<br> .usersByUsernameQuery(<br> <span class="hljs-string">&quot;select username, password, enabled from Users &quot;</span> +<br> <span class="hljs-string">&quot;where username=?&quot;</span>)<br> .authoritiesByUsernameQuery(<br> <span class="hljs-string">&quot;select username, authority from UserAuthorities &quot;</span> +<br> <span class="hljs-string">&quot;where username=?&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="web请求保护"><a href="#web请求保护" class="headerlink" title="web请求保护"></a>web请求保护</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> SecurityFilterChain <span class="hljs-title function_">filterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-keyword">return</span> http<br>.authorizeRequests()<br>.antMatchers(<span class="hljs-string">&quot;/design&quot;</span>, <span class="hljs-string">&quot;/orders&quot;</span>).hasRole(<span class="hljs-string">&quot;USER&quot;</span>)<br>.antMatchers(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;/**&quot;</span>).permitAll()<br>.and()<br>.build();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>方法级别保护</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 我们可以直接在 deleteAllOrders() 方法上应用安全性配置，如下所示：</span><br>`<span class="hljs-meta">@PreAuthorize</span>` (<span class="hljs-string">&quot;hasRole(&#x27;ADMIN&#x27;)&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteAllOrders</span><span class="hljs-params">()</span> &#123;<br>orderRepository.deleteAll();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>为了使 @PreAuthorize 工作，您需要启用全局方法安全。为此，您需要使用 @EnableGlobalMethodSecurity注解安全配置类.</p>
<h3 id="阻止CSRF攻击"><a href="#阻止CSRF攻击" class="headerlink" title="阻止CSRF攻击"></a>阻止CSRF攻击</h3><p>跨站请求伪造（CSRF）是一种常见的安全攻击。它涉及到让用户在一个恶意设计的 web 页面上编写代码，这个页面会自动（通常是秘密地）代表经常遭受攻击的用户向另一个应用程序提交一个表单。例如，在攻击者的网站上，可能会向用户显示一个表单，该表单会自动向用户银行网站上的一个 URL 发送消息（该网站的设计可能很糟糕，很容易受到这种攻击），以转移资金。用户甚至可能不知道攻击发生了，直到他们注意到他们的帐户中少了钱。</p>
<p>为了防止此类攻击，应用程序可以在显示表单时生成 CSRF token，将该 token 放在隐藏字段中，然后将其存储在服务器上供以后使用。提交表单时，token 将与其他表单数据一起发送回服务器。然后服务器拦截请求，并与最初生成的 token 进行比较。如果 token 匹配，则允许继续执行请求。否则，表单一定是由一个不知道服务器生成的 token的恶意网站呈现的。</p>
<h3 id="获取用户信息"><a href="#获取用户信息" class="headerlink" title="获取用户信息"></a>获取用户信息</h3><p>然而，也许最干净的解决方案是简单地接受 processOrder() 中的用户对象，但是使用@AuthenticationPrincipal 对其进行注解，以便它成为身份验证的主体：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">processOrder</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> TacoOrder order, Errors errors,</span><br><span class="hljs-params">SessionStatus sessionStatus,</span><br><span class="hljs-params"><span class="hljs-meta">@AuthenticationPrincipal</span> User user)</span> &#123;<br><span class="hljs-keyword">if</span> (errors.hasErrors()) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;orderForm&quot;</span>;<br>&#125;<br>order.setUser(user);<br>orderRepo.save(order);<br>sessionStatus.setComplete();<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>@AuthenticationPrincipal 的优点在于它不需要强制转换（与身份验证一样），并且将特定于安全性的代码限制为注释本身。当在 processOrder() 中获得 User 对象时，它已经准备好被使用并分配给订单了。</p>
<p>三种方式</p>
<ol>
<li>DesignTacoController<br>参数: Principal principal<br>String username &#x3D; principal.getName();</li>
<li>OrderController<br>  @AuthenticationPrincipal User user</li>
<li>安全上下文获取<br>Authentication authentication &#x3D; SecurityContextHolder.getContext(getAuthentication();<br>User user &#x3D; (User) authentication.getPrincipal();</li>
</ol>
<h1 id="Lecture-8-属性配置"><a href="#Lecture-8-属性配置" class="headerlink" title="Lecture 8  属性配置"></a>Lecture 8  属性配置</h1><h2 id="属性使用方法"><a href="#属性使用方法" class="headerlink" title="属性使用方法"></a>属性使用方法</h2><p>四种属性来源（ property source)</p>
<ul>
<li>application.properties、application.yml: server.port &#x3D; 8090</li>
<li>命令行参数（ commandLineArgs ) : java -jar taco-cloud-sd-jdbc-0.0.3-SNAPSHOT.jar <strong>–server.port&#x3D;8081</strong></li>
<li>JVM系统属性: java <strong>-Dserver.port&#x3D;8091</strong> -jar taco-cloud-sd-jdbc-0.0.3-SNAPSHOT.jar</li>
<li>操作系统环境变量：<strong>set SERVER_PORT&#x3D;8082</strong>、java -jar taco-cloud-sd-jdbc-0.0.3-SNAPSHOT.jar</li>
</ul>
<h2 id="Https（考试略"><a href="#Https（考试略" class="headerlink" title="Https（考试略"></a>Https（考试略</h2><ul>
<li>HTTPS (Secure Hypertext Transfer Protocol)安全超文本传输协议，是一个安全通信通道，它基于HTTP开发用于在客户计算机和服务器之间交换信息。它使<strong>用安全套接字层(SSL)进行信息交换</strong>，简单来说它是HTTP的安全版,是使用TLS&#x2F;SSL加密的HTTP协议。HTTP协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议TLS&#x2F;SSL具有<strong>身份验证、信息加密和完整性校验</strong>的功能，可以避免此类问题发生。<ul>
<li>SSL(Secure Sockets Layer安全套接字协议)，及其继任者传输层安全(Transport Layer Security ,TLS)是<strong>为网络通信提供安全及数据完整性</strong>的一种安全协议。TLS与SSL在传输层与应用层之间对网络连接进行加密。</li>
</ul>
</li>
</ul>
<h2 id="单双向验证（考试略"><a href="#单双向验证（考试略" class="headerlink" title="单双向验证（考试略"></a>单双向验证（考试略</h2><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231026200525305.png"><span class="image-caption">image-20231026200525305</span></p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231026200936146.png"><span class="image-caption">image-20231026200936146</span></p>
<h2 id="秘钥配置（考试略"><a href="#秘钥配置（考试略" class="headerlink" title="秘钥配置（考试略"></a>秘钥配置（考试略</h2><p>生成密钥库</p>
<ul>
<li>keytool -genkey -alias tomcat -keyalg RSA -storetype PKCS12 -storepass letmein -keystore  mykeys.p12</li>
<li>密钥库类型: PKCS12</li>
<li><img src="/C:/Users/lar/AppData/Roaming/Typora/typora-user-images/image-20231026205420773.png"><span class="image-caption">image-20231026205420773</span></li>
</ul>
<p>查看密钥库</p>
<ul>
<li>keytool -list -keystore mykeys.p12 -storepass letmein</li>
</ul>
<p>keytool基本使用</p>
<ul>
<li>生成key和库<br>keytool -genkey -v -alias key别名-keyalg RSA -storetype PKCS12 -keystore库文件名.p12</li>
<li>导出证书<br>keytool -keystore库文件名.p12-export -alias key别名-file证书文件名.cer</li>
<li>打印证书信息<br>keytool -printcert -file证书文件名.cer</li>
<li>导入证书到库<br>keytool -import -v -file证书文件名.cer -keystore库文件名.p12</li>
</ul>
<h2 id="SSL配置（考试略"><a href="#SSL配置（考试略" class="headerlink" title="SSL配置（考试略"></a>SSL配置（考试略</h2><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231026214759577.png"><span class="image-caption">image-20231026214759577</span>启用 SSL（Secure Sockets Layer)协议来加密和保护应用程序的通信。下面是对配置中各个属性的解释：</p>
<ul>
<li><code>server.port: 8443</code>: 指定应用程序的端口号为 8443。这是应用程序监听的 HTTPS 连接的端口号。</li>
<li><code>ssl.key-store: classpath:mykeys.p12</code>: 指定使用的密钥库文件的路径和名称。<code>classpath:</code> 前缀表示从类路径中加载密钥库文件，即在应用程序的资源目录下。</li>
<li><code>ssl.key-store-password: letmein</code>: 指定密钥库的密码，用于访问密钥库文件的内容和密钥对。</li>
<li><code>ssl.key-password: letmein</code>: 指定密钥的密码，用于访问密钥库中的具体密钥。</li>
</ul>
<p>这些配置项用于配置应用程序在 HTTPS 模式下监听的端口号、使用的密钥库文件及其密码。通过配置 SSL，应用程序能够使用 HTTPS 协议进行安全的加密通信。</p>
<p>在实际部署中，应根据实际情况配置真实的证书和密钥库，以确保安全性。</p>
<h2 id="配置日志"><a href="#配置日志" class="headerlink" title="配置日志"></a>配置日志</h2><p> Spring Boot默认使用Logback，日志配置文件logback.xml</p>
<ul>
<li>默认日志级别:INFO</li>
<li>分级别、分包目录日志配置(application.yml)<ul>
<li>logging:<br>  level:<br>root: WARN<br>org:<br>  Springframework:<br>    security: DEBUG</li>
<li>以上配置的含义是设置根日志级别为 <code>WARN</code>，意味着只有警告级别及以上的日志会被输出。同时，对于包名为 <code>org.springframework.security</code> 下的所有类，将其日志级别设置为 <code>DEBUG</code>，即会输出该包下的所有调试级别的日志信息。</li>
</ul>
</li>
</ul>
<h2 id="自定义配置属性"><a href="#自定义配置属性" class="headerlink" title="自定义配置属性"></a>自定义配置属性</h2><ul>
<li>ConfigurationProperties(prefix&#x3D; “taco.orders”)</li>
<li>@Validated</li>
</ul>
<p>通过application.yml文件提供值</p>
<ul>
<li>环境变量: taco _orders _pageSize&#x3D;12</li>
<li>程序参数: –taco.orders.pageSize&#x3D;13</li>
<li>访问:<a target="_blank" rel="noopener" href="http://localhost:8080/orders%E9%AA%8C%E8%AF%81">http://localhost:8080/orders验证</a></li>
</ul>
<h2 id="激活不同配置-Spring-profile"><a href="#激活不同配置-Spring-profile" class="headerlink" title="激活不同配置 Spring profile"></a>激活不同配置 Spring profile</h2><ul>
<li><p>定义特定profile的属性，通过使用不同的YAML或属性文件</p>
<ul>
<li><p>application-{profile名}.properties</p>
</li>
<li><p>application-{profile名}.yml</p>
</li>
</ul>
</li>
<li><p>也可以将不同profile属性放到同一个YAML文件中，使用3个短线进行分隔，并且使用spring.profiles属性来命名profile</p>
</li>
</ul>
<p>激活的三种方式</p>
<ul>
<li>环境变量: spring_profiles_active&#x3D;prod</li>
<li>命令行参数: java -jar ***.jar –spring.profiles.active&#x3D;prod</li>
<li>JVM系统属性: java -Dspring.profiles.active&#x3D;prod -jar ****.jar</li>
<li>使用注解@Profile(!prod)条件化地创建Bean，可以加到@Configuration或@Bean上</li>
</ul>
<h2 id="Actuator"><a href="#Actuator" class="headerlink" title="Actuator"></a>Actuator</h2><p>Spring Boot Actuator是Spring Boot提供的一个功能强大的模块，用于监控和管理Spring Boot应用程序。它提供了一组内置的RESTful端点（endpoints），可以用于获取关于应用程序运行时的各种信息，例如健康状况、度量指标、配置属性、日志记录等。</p>
<ul>
<li>Spring Boot Actuator的主要目标是帮助开发人员和运维人员更好地理解和管理应用程序的运行状态和行为，以便监测和调试应用程序，进行性能优化和故障排查。</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231102185612299.png"><span class="image-caption">image-20231102185612299</span></li>
</ul>
<p>下面是一些Spring Boot Actuator提供的常用端点：</p>
<ol>
<li><code>/health</code>：用于检查应用程序的健康状况，包括是否存活和是否就绪。</li>
<li><code>/info</code>：提供关于应用程序的基本信息，例如应用程序的名称、版本等。</li>
<li><code>/metrics</code>：用于获取应用程序的度量指标，例如内存使用情况、HTTP请求计数等。</li>
<li><code>/env</code>：获取应用程序的配置属性和环境变量。</li>
<li><code>/loggers</code>：用于管理和配置日志记录器，包括查看日志级别、修改日志级别等。</li>
<li><code>/trace</code>：提供最近的HTTP请求追踪信息，包括请求路径、处理时间等。</li>
</ol>
<h1 id="Lecture-9-RESTful-API"><a href="#Lecture-9-RESTful-API" class="headerlink" title="Lecture 9 RESTful API"></a>Lecture 9 RESTful API</h1><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231102191853434.png"><span class="image-caption">image-20231102191853434</span></p>
<h2 id="K8s"><a href="#K8s" class="headerlink" title="K8s"></a>K8s</h2><p>部署多个pod</p>
<h2 id="REST原则（重要"><a href="#REST原则（重要" class="headerlink" title="REST原则（重要"></a>REST原则（重要</h2><ul>
<li>REST：Representational State Transfer：表现层状态转移 </li>
<li>表现层（Representation）：json、xml、html、pdf、excel </li>
<li>状态转移（State Transfer）：服务端–客户端</li>
</ul>
<p>资源（Resources），就是网络上的一个实体</p>
<ul>
<li><p>标识：URI </p>
</li>
<li><p>HTTP协议的四个操作方式的动词：GET、POST、PUT、DELETE </p>
<ul>
<li>CRUD：Create、Read、Update、Delete</li>
<li>不需要再在url体现增删改查</li>
</ul>
</li>
<li><p>如果一个架构符合REST原则，就称它为<strong>RESTful架构</strong></p>
</li>
</ul>
<h2 id="前端vue"><a href="#前端vue" class="headerlink" title="前端vue"></a>前端vue</h2><p>vue作为桥梁的作用</p>
<ul>
<li><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231102191932611.png"><span class="image-caption">image-20231102191932611</span></p>
</li>
<li><p>Vue所关注的核心是MVC模式中的视图层，同时， 它也能方便地获取数据更新，并通过组件内部特定的方法实现视图与模型的交互</p>
</li>
</ul>
<h3 id="MVVM模型"><a href="#MVVM模型" class="headerlink" title="MVVM模型"></a>MVVM模型</h3><p>单文件组件</p>
<ul>
<li>模板、逻辑和样式在一个组件里，组件更加内聚且更可维护</li>
<li>组件是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用</li>
</ul>
<p>MVVM</p>
<ul>
<li>一种用于构建用户界面的软件架构模式，它将应用程序的逻辑和界面进行分离，使代码更易于维护和测试。</li>
</ul>
<p>下面是对 Vue.js 中 MVVM 架构模式的各个组成部分的介绍：</p>
<ol>
<li>Model（模型）：<br>模型代表应用程序的数据和业务逻辑。在 Vue.js 中，模型通常是由 JavaScript 对象或数组表示，包含应用程序的数据和状态。</li>
<li>View（视图）：<br>视图是用户界面的呈现层，它由 HTML 模板表示。在 Vue.js 中，视图通常是使用 Vue 的模板语法编写的，通过绑定数据和指令来实现动态渲染。</li>
<li>ViewModel（视图模型）：<br>视图模型是连接视图和模型的桥梁。它是一个 JavaScript 对象，在 Vue.js 中由 Vue 实例表示。视图模型负责管理视图和模型之间的数据绑定和交互逻辑。它<strong>通过双向数据绑定将视图的变化反映到模型，并将模型的变化反映到视图。</strong></li>
</ol>
<p>在 Vue.js 中，视图模型通过定义数据属性和计算属性来表示模型，并使用指令和事件绑定等特性来处理用户输入和响应用户操作。视图模型还<strong>提供了一些生命周期钩子函数，用于处理视图的初始化、更新和销毁过程</strong>。</p>
<p>通过 MVVM 架构模式，Vue.js <strong>实现了数据驱动的视图，即当模型的状态改变时，视图会自动更新，而无需手动操作 DOM</strong>。这使得开发人员可以更专注于处理业务逻辑和数据处理，而无需过多关注界面的变化和更新。</p>
<h2 id="REST-API"><a href="#REST-API" class="headerlink" title="REST API"></a>REST API</h2><p>重要理解</p>
<ul>
<li>对资源（url）的操作</li>
<li>以面向数据的格式返回：JSON或XML</li>
</ul>
<h3 id="一些注解"><a href="#一些注解" class="headerlink" title="一些注解"></a>一些注解</h3><ol>
<li><code>@RequestMapping</code>：用于将请求映射到控制器方法或处理程序方法。它可以用于类级别和方法级别的注解，用于定义处理请求的路径、HTTP方法、请求参数等。<ol>
<li>produces 指定指定当前方法返回对象的Content-Type。</li>
<li>consumes指定当前方法可以处理的请求Content-Type</li>
</ol>
</li>
<li><code>@GetMapping</code>：是 <code>@RequestMapping</code> 的缩写形式，用于将 GET 请求映射到方法。它指定了特定的路径，当收到 GET 请求时，将调用对应的方法来处理请求。<ol>
<li>params&#96;属性用于指定URL参数过滤条件。该方法仅处理带有”recent”参数的GET请求。</li>
</ol>
</li>
<li><code>@PostMapping</code>：是 <code>@RequestMapping</code> 的缩写形式，用于将 POST 请求映射到方法。类似于 <code>@GetMapping</code>，它指定了特定的路径，当收到 POST 请求时，将调用对应的方法来处理请求。<ol>
<li><code>@ResponseStatus(HttpStatus.CREATED)</code>表示在POST请求成功后返回状态码201（Created）</li>
</ol>
</li>
<li><code>@PutMapping</code>：是 <code>@RequestMapping</code> 的缩写形式，用于将 PUT 请求映射到方法。类似于 <code>@GetMapping</code>，它指定了特定的路径，当收到 PUT 请求时，将调用对应的方法来处理请求。</li>
<li><code>@DeleteMapping</code>：是 <code>@RequestMapping</code> 的缩写形式，用于将 DELETE 请求映射到方法。类似于 <code>@GetMapping</code>，它指定了特定的路径，当收到 DELETE 请求时，将调用对应的方法来处理请求。<ol>
<li>使用<code>@ResponseStatus(HttpStatus.NO_CONTENT)</code>表示成功删除后返回状态码204（No Content）。</li>
</ol>
</li>
<li><code>@PatchMapping</code>：是 <code>@RequestMapping</code> 的缩写形式，用于将 PATCH 请求映射到方法。类似于 <code>@GetMapping</code>，它指定了特定的路径，当收到 PATCH 请求时，将调用对应的方法来处理请求。<ol>
<li>和Put的区别在于，只更新某一个，相当于补丁</li>
</ol>
</li>
<li><code>@RestController</code>：是一个组合注解，用于标记一个类为 RESTful Web 服务的控制器。它结合了 <code>@Controller</code> 和 <code>@ResponseBody</code> 注解的功能，用于处理请求并返回数据，通常用于构建 RESTful API。</li>
<li><code>@ResponseBody</code>：用于将方法的返回值直接作为响应体返回给客户端，而不是通过视图解析器渲染为视图。它可以用于方法级别或控制器类级别。</li>
<li><code>ResponseEntity</code>：是一个类，用于表示 HTTP 响应的实体，包括状态码、响应头和响应体等。它可以用于方法的返回值类型，以更灵活地构建和自定义 HTTP 响应。</li>
</ol>
<h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><p>请求头：请求头由 key&#x2F;value 对组成，每行为一对，key 和 value 之间通过冒号(:)分割。请求头的作用主要用于<strong>通知服务端有关于客户端的请求信息</strong>。</p>
<ul>
<li>User-Agent：生成请求的浏览器类型 </li>
<li><strong>Accept</strong>：客户端可识别的响应内容类型列表；星号* 用于按范围将类型分组。*&#x2F;*表示可接受全部类型，type&#x2F;*表示可接受 type 类型的 所有子类型。<ul>
<li>application&#x2F;json常用</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231102200252323.png"><span class="image-caption">image-20231102200252323</span></li>
</ul>
</li>
<li>Accept-Language: 客户端可接受的自然语言</li>
<li>Accept-Encoding: 客户端可接受的编码压缩格式 </li>
<li>Accept-Charset： 可接受的字符集 </li>
<li><strong>Host</strong>: 请求的主机名，允许多个域名绑定同一 IP 地址 </li>
<li><strong>connection</strong>：连接方式（close 或 keepalive） </li>
<li>Cookie: 存储在客户端的扩展字段 </li>
<li>**Content-Type:**标识请求内容的类型 </li>
<li>**Content-Length:**标识请求内容的长度</li>
</ul>
<p>请求体：请求体主要用于 POST 请求</p>
<ul>
<li>与 POST 请求方法配套的请求头一般有 Content-Type和 Content-Length</li>
</ul>
<h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>状态行：由 HTTP 协议版本、状态码、状态码描述三部分构成，它们之间由空格隔开。</p>
<p>状态码：由 3 位数字组成，第一位标识响应的类型，常用的5大类状态码如下：</p>
<ul>
<li><p>1xx：表示服务器已接收了客户端的请求，<strong>客户端可以继续发送请求</strong> </p>
</li>
<li><p>2xx：表示服务器已成功接收到请求，<strong>并进行处理</strong></p>
<ul>
<li>记住201 创建资源</li>
</ul>
</li>
<li><p>3xx：表示服务器要求客户端<strong>重定向</strong> </p>
</li>
<li><p>4xx：表示客户端的请求有非法内容</p>
<ul>
<li>未授权，返回状态码401 Unauthorized</li>
</ul>
</li>
<li><p>5xx：标识<strong>服务器意外错误</strong></p>
</li>
</ul>
<p>响应头 </p>
<ul>
<li>Location：服务器返回给客户端，用于重定向到新的位置 </li>
<li>Server： 包含服务器用来处理请求的软件信息及版本信息。Vary：标识不可缓存的请求头列表 </li>
<li><strong>Connection</strong>: 连接方式<ul>
<li>close 是告诉服务端，断开连接，不用等待后续的请求了。 </li>
<li>keep-alive 则是告诉服务端，在完成本次请 求的响应后，保持连接</li>
</ul>
</li>
<li><strong>Keep-Alive</strong>: 300，期望服务端保持连接多长时间（秒）</li>
</ul>
<p>响应内容</p>
<ul>
<li>服务端返回给请求端的文本信息。</li>
</ul>
<h3 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h3><p>将java对象与json互转</p>
<ul>
<li>没有model和视图，控制器产生数据，然后消息转换器转换数据之后的资源表述</li>
<li>spring<strong>自动注册一些消息转换器</strong>（HttpMethodConverter），不过类路径下要有对应转换能力的库，如： Jackson Json processor、JAXB库</li>
</ul>
<p>使用方法</p>
<ul>
<li>使用注解@ResponseBody或类级@RestController，作用：指定使用消息转换器 </li>
<li>请求传入，@RequestBody以及HttpMethodConverter</li>
</ul>
<h2 id="前后端传参的四种方式"><a href="#前后端传参的四种方式" class="headerlink" title="前后端传参的四种方式"></a>前后端传参的四种方式</h2><ol>
<li>GET请求参数</li>
</ol>
<p><strong>通过URL</strong>携带参数,比如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/users?<span class="hljs-built_in">id</span>=1&amp;name=Tom<br></code></pre></td></tr></table></figure>

<p>后端通过@RequestParam获取参数。</p>
<ol start="2">
<li>POST请求表单</li>
</ol>
<p><strong>表单提交</strong>参数,post表单数据到后端。</p>
<p>后端通过@RequestParam或@ModelAttribute获取表单数据。</p>
<ol start="3">
<li>POST请求body</li>
</ol>
<p><strong>将JSON&#x2F;XML</strong>等格式的数据放入请求体中传输。</p>
<p>后端通过@RequestBody注解将请求体绑定到对象中。</p>
<ol start="4">
<li>POST请求文件</li>
</ol>
<p><strong>通过form表单</strong>或XMLHttpRequest上传文件到后端。</p>
<p>后端通过MultipartFile获取上传的文件。</p>
<ul>
<li><p>总结:</p>
<ul>
<li><p>GET方式通过URL携带参数</p>
<ul>
<li>POST方式通过表单或请求体传参<ul>
<li>表单通过@RequestParam或@ModelAttribute获取</li>
<li>请求体通过@RequestBody将body绑定到对象</li>
</ul>
</li>
</ul>
</li>
<li><p>文件上传通过表单或者XMLHttpRequest对应MultipartFile获取文件</p>
</li>
</ul>
</li>
</ul>
<h2 id="spring-boot-starter-data-rest"><a href="#spring-boot-starter-data-rest" class="headerlink" title="spring-boot-starter-data-rest"></a>spring-boot-starter-data-rest</h2><p>目的</p>
<ul>
<li>将Spring Data存储库暴露为REST端点</li>
<li>自动实现增删改查的REST API</li>
</ul>
<p>用于快速开发基于Spring Data REST的Restful API项目。</p>
<ul>
<li><p>自动引入Spring Data REST、Spring HATEOAS等组件所需要的依赖。</p>
</li>
<li><p>自动配置和启用了Spring Data REST功能。</p>
</li>
<li><p>自动暴露Spring Data Repositories</p>
</li>
<li><p>自动暴露Restful API。</p>
</li>
<li><p>返回值包含实体与其相关实体或操作的URI链接。</p>
</li>
<li><p>对外提供与数据相关的Restful CRUD接口。</p>
</li>
<li><p>可以根据不同需求定制和扩展自动生成的API功能。</p>
</li>
</ul>
<p>使用它可以一步创建基于实体的Restful API项目框架**,开发者只需定义接口和实体类即可。**大大提高开发效率。</p>
<p>使用方式</p>
<ul>
<li><p>@Data<br>@Entity<br>@RestResource(rel&#x3D;”tacos”, path&#x3D;”tacos”)</p>
</li>
<li><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231102211936578.png"><span class="image-caption">image-20231102211936578</span></p>
</li>
</ul>
<h2 id="RestTemplate（不考"><a href="#RestTemplate（不考" class="headerlink" title="RestTemplate（不考"></a>RestTemplate（不考</h2><p>目的</p>
<ul>
<li>测试和保护REST端点</li>
</ul>
<p>RestTemplate是Spring提供的用于执行HTTP请求的客户端模板类。使用RestTemplate可以方便地发起各种HTTP请求,与远程服务进行交互,在Spring注入模板后使用更简单高效。主要方法如下:</p>
<ul>
<li>getForObject:执行HTTP GET请求,并解析响应体为指定对象类型返回。</li>
<li>getForEntity:执行HTTP GET请求,返回ResponseEntity对象,包含响应头和响应体。</li>
<li>postForObject:执行HTTP POST请求,并解析响应体为指定对象类型返回。</li>
<li>postForEntity:执行HTTP POST请求,返回ResponseEntity对象。</li>
<li>postForLocation:执行POST请求,返回Location头指定的URL。</li>
<li>put:执行HTTP PUT请求,用于资源更新。</li>
<li>delete:执行HTTP DELETE请求,用于资源删除。</li>
<li>execute:执行任意HTTP请求但不解析响应体,返回Response。</li>
<li>exchange:执行任意HTTP请求,返回ResponseEntity对象,包含请求响应全过程的数据。</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231102214752049.png"><span class="image-caption">image-20231102214752049</span></li>
</ul>
<h2 id="Feign（不考"><a href="#Feign（不考" class="headerlink" title="Feign（不考"></a>Feign（不考</h2><p>分布式使用</p>
<p>远程调用RestAPI</p>
<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231102211737197.png"><span class="image-caption">image-20231102211737197</span></li>
</ul>
<h1 id="Lecture-10-OAuth2"><a href="#Lecture-10-OAuth2" class="headerlink" title="Lecture 10 OAuth2"></a>Lecture 10 OAuth2</h1><ul>
<li><p>OAuth2，一个专门为 API创建的授权规范。</p>
</li>
<li><p>对微服务作权限控制</p>
</li>
<li><p>统一认证和授权，专心业务</p>
</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231111094840312.png"><span class="image-caption">image-20231111094840312</span></p>
<ul>
<li><p>非常重要的图！考试必考</p>
</li>
<li><p>流程：</p>
<ul>
<li><p>1.用户进入url，发现没登录</p>
</li>
<li><p>2.资源服务器 重定向到 授权服务器，打开登录对话框</p>
</li>
<li><p>3.新的url（资源服务器）让用户提供consent</p>
<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231111102642798.png"><span class="image-caption">image-20231111102642798</span></li>
</ul>
</li>
<li><p>4.用户确认授权consent</p>
</li>
<li><p>5.返回授权码 auth code</p>
</li>
<li><p>6.Client获取auth code 后再向授权服务器获取token（不能直接获取吗？）</p>
<ul>
<li>减少明文密码在浏览器出现的次数，转化为authcode。避免被第三方软件劫持</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231111112405718.png"><span class="image-caption">image-20231111112405718</span></li>
</ul>
</li>
<li><p>7.用户带着token 去资源服务器请求资源</p>
<ul>
<li>资源服务器需向authserver获取公钥，用以解码token,验证身份</li>
</ul>
</li>
<li><p>8.返回资源</p>
<blockquote>
<ol>
<li>令牌和凭证：<ul>
<li>令牌（Token）是一种代表用户身份的数据结构，用于在身份验证和授权过程中进行传递。令牌可以是访问令牌（Access Token）、身份令牌（ID Token）等。它们通常由授权服务器颁发给客户端，用于表示用户的身份和授权信息。</li>
<li>凭证（Credential）是用于证明用户身份和权限的数据，可以是用户名和密码、API密钥、数字证书等。凭证通常由用户提供给身份验证系统或应用程序，用于获取相应的令牌或授权。</li>
</ul>
</li>
<li>公私钥和凭证：<ul>
<li>公私钥是一对密钥，用于加密和解密数据。公钥用于加密数据，而私钥用于解密数据。公钥可以安全地共享给其他人，而私钥必须保持机密。</li>
<li>凭证在身份验证过程中可以与公私钥配对使用，以提供更安全的身份验证机制。例如，数字证书是一种凭证形式，其中包含用户的公钥和其他身份信息，并由证书颁发机构（CA）使用其私钥签名。在身份验证过程中，验证方可以使用公钥解密数字证书的签名，并验证证书的真实性和完整性。</li>
</ul>
</li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li><p>举例：用微信获取信息 理解</p>
</li>
</ul>
<h2 id="JWT、JWK"><a href="#JWT、JWK" class="headerlink" title="JWT、JWK"></a>JWT、JWK</h2><ul>
<li>JSON web key，RSA密钥对(公钥私钥)，用于对令牌签名.令牌会用私钥签名，资源服务器会通过从授权服务器获取到的公钥验证请求中收到的令牌是否有效<ul>
<li>interface JWKSource</li>
<li>interface JwtDecoder</li>
</ul>
</li>
<li>JWT是一种开放标准（RFC 7519），用于在不同实体之间安全传输信息。它由三部分组成：头部（Header）、载荷（Payload）和签名（Signature）。<ul>
<li>头部包含描述JWT的元数据，如使用的加密算法等。</li>
<li>载荷包含有关实体和其他附加数据的信息，例如用户ID、过期时间等。</li>
<li>签名是对头部和载荷进行数字签名的结果，用于验证JWT的完整性和真实性。</li>
</ul>
</li>
<li>JWT提供了一种安全传输和验证信息的标准化格式，而JWK用于描述和传输用于JWT签名和验证的密钥对。通过使用JWK，可以验证JWT的真实性和完整性</li>
</ul>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231111101635688.png"><span class="image-caption">image-20231111101635688</span></p>
<ul>
<li>解码例子 ↑</li>
</ul>
<h2 id="授权服务器"><a href="#授权服务器" class="headerlink" title="授权服务器"></a>授权服务器</h2><p>1.<br>2. 开发Spring Security User实体，接入数据库。</p>
<ol>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231111111631218.png"><span class="image-caption">image-20231111111631218</span></li>
</ol>
<h2 id="资源服务器"><a href="#资源服务器" class="headerlink" title="资源服务器"></a>资源服务器</h2><ol>
<li>添加OAuth2  pom依赖</li>
<li>添加SCOPE权限控制 &#x2F; 开启调用API前的过滤器：<ol>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231111111518116.png"><span class="image-caption">image-20231111111518116</span></li>
</ol>
</li>
<li>指定授权服务器地址，目的是获得公钥<ol>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231111111539864.png"><span class="image-caption">image-20231111111539864</span></li>
</ol>
</li>
</ol>
<h2 id="开发客户端"><a href="#开发客户端" class="headerlink" title="开发客户端"></a>开发客户端</h2><ol>
<li>添加Oauth2-client专用的pom依赖</li>
<li>代码配置<ol>
<li>定义第2步的重定向</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231111113701029.png"><span class="image-caption">image-20231111113701029</span></li>
</ol>
</li>
<li>属性配置<ol>
<li>配置获取token的重定向地址</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231111113709321.png"><span class="image-caption">image-20231111113709321</span></li>
</ol>
</li>
</ol>
<h1 id="Lecture-11-消息中间件"><a href="#Lecture-11-消息中间件" class="headerlink" title="Lecture 11 消息中间件"></a>Lecture 11 消息中间件</h1><h2 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h2><p>Java 消息服务（Java Message Servcie）</p>
<ul>
<li>JMS是一个Java标准，定义了使用消息代理（message broker）的通用API</li>
<li>Spring通过基于模板的抽象为JMS功能提供了支持，这个模板就JmsTemplate</li>
</ul>
<p>生产消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">connectionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActiveMQConnectionFactory</span>(BROKER_URL, USERNAME, PASSWORD);<br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> connectionFactory.createConnection();<br>connection.start();<br><span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> connection.createSession(<span class="hljs-literal">false</span>, Session.AUTO_ACKNOWLEDGE);<br><span class="hljs-type">Destination</span> <span class="hljs-variable">destination</span> <span class="hljs-operator">=</span> session.createQueue(<span class="hljs-string">&quot;queue.example&quot;</span>);<br><br></code></pre></td></tr></table></figure>

<p>关键方法</p>
<ul>
<li><p><strong>javax.jms.Destination：指定队列或主题</strong> : tacocloud.order.queue</p>
<ul>
<li><p>application.yml（default-destination）</p>
</li>
<li><p>@Bean（Destination对象）</p>
</li>
<li><p>直接String指定</p>
</li>
</ul>
</li>
<li><p><strong>发送消息</strong>的两个方法：send、<strong>convertAndSend</strong></p>
</li>
<li><p><strong>MessageConverter</strong></p>
<ul>
<li>SimpleMessageConverter：实现String与TextMessage的相互转换、字节数组与BytesMessage的相互转换、Map与MapMessage的相互转换，以及Serializable对象与ObjectMessage的相互转换 </li>
<li>MappingJackson2MessageConverter：使用Jackson 2 JSON库实现消息与JSON格式的互转</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231116204313985.png"><span class="image-caption">image-20231116204313985</span></li>
</ul>
</li>
</ul>
<p>不同模式</p>
<ul>
<li><p>拉取模式(Pull Model):</p>
<ul>
<li>拉取模式下,消费者主动从消息队列中拉取消息。即消费者需要不断地向消息队列发出请求,检测是否有新的消息到来,如果有则拉取消息进行消费。</li>
</ul>
</li>
<li><p>推送模式(Push Model):</p>
<ul>
<li>推送模式下,消息队列主动推送消息给消费者。当消息队列中有新消息到达时,会主动通知并直接发送给消费者,而不是等待消费者拉取。</li>
</ul>
</li>
</ul>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><ul>
<li>Exchange:交换机,它是消息进入队列的入口。负责将消息路由到对应的Queue<ul>
<li>主要类型:<ul>
<li>Direct Exchange:根据routing key完全匹配将消息路由到对应的Queue。</li>
<li>Fanout Exchange:将消息进行广播,将消息路由到所有绑定到该Exchange的Queue。</li>
<li>Topic Exchange:根据routing key的通配符规则将消息路由到对应的Queue。</li>
</ul>
</li>
</ul>
</li>
<li>Binding:绑定关系,它将Exchange和Queue绑定起来。</li>
<li>Routing Key:路由键,Exchange根据该键与Binding的binding key匹配将消息路由到对应的Queue。</li>
<li>Binding key:Binding中的键,它将Exchange和Queue关联起来。</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231116203552518.png"><span class="image-caption">image-20231116203552518</span></li>
</ul>
<h1 id="Lecture-12-spring-integration"><a href="#Lecture-12-spring-integration" class="headerlink" title="Lecture 12 spring integration"></a>Lecture 12 spring integration</h1><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231123205551218.png"><span class="image-caption">image-20231123205551218</span></p>
<ul>
<li>本节课做的：③Email Server</li>
</ul>
<p>集成流配置三种方式</p>
<ul>
<li>XML配置</li>
<li>Java配置 </li>
<li>使用DSL的Java配置</li>
</ul>
<h2 id="最简集成流的五个部分"><a href="#最简集成流的五个部分" class="headerlink" title="最简集成流的五个部分"></a>最简集成流的五个部分</h2><ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231123205532037.png"><span class="image-caption">image-20231123205532037</span></li>
<li>消息分为Header和Payload</li>
</ul>
<h2 id="集成流的组件"><a href="#集成流的组件" class="headerlink" title="集成流的组件"></a>集成流的组件</h2><ul>
<li>Channels（通道） —Pass messages from one element to another.<ul>
<li>例如：PublishSubscribeChanne、QueueChannel、PriorityChannel</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231123210628428.png"><span class="image-caption">image-20231123210628428</span></li>
</ul>
</li>
<li>Filters（过滤器） —Conditionally allow messages to pass through the flow based on some criteria.<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231123210721288.png"><span class="image-caption">image-20231123210721288</span></li>
</ul>
</li>
<li>Transformers（转换器） —Change message values and&#x2F;or convert message payloads from one type to another.<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231123210821660.png"><span class="image-caption">image-20231123210821660</span></li>
</ul>
</li>
<li>Routers（路由器） —Direct messages to one of several channels, typically based on message headers.<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231123212118322.png"><span class="image-caption">image-20231123212118322</span></li>
</ul>
</li>
<li>Splitters（切分器） —Split incoming messages into two or more messages, each sent to different channels. <ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231123212211014.png"><span class="image-caption">image-20231123212211014</span></li>
<li>切分的是消息，不是router到多个channel</li>
</ul>
</li>
<li>Aggregators（聚合器） —The opposite of splitters, combining multiple messages coming in from separate channels into a  single message.</li>
<li>Service activators（服务激活器） —Hand a message off to some Java method for processing, and then publish the return  value on an output channel. <ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231123212241684.png"><span class="image-caption">image-20231123212241684</span></li>
<li>类似transformers，语义上不同</li>
</ul>
</li>
<li>Channel adapters（通道适配器） —Connect a channel to some external system or transport. Can either accept input or  write to the external system. <ul>
<li><img src="/C:/Users/lar/AppData/Roaming/Typora/typora-user-images/image-20231123212510747.png"><span class="image-caption">image-20231123212510747</span></li>
<li><strong>Inbound Channel Adapter（入站通道适配器）</strong>：<ul>
<li><strong>作用</strong>：Inbound Channel Adapter 负责将外部系统的数据转换成消息，并将这些消息发送到 Spring Integration 流程中的通道。</li>
<li><strong>例子</strong>：一个常见的例子是文件适配器（File Inbound Channel Adapter），它可以监听指定的文件夹，并在文件变化时将文件内容转化为消息发送到通道中。另一个例子是 JMS 入站适配器，用于从 JMS 队列接收消息。</li>
</ul>
</li>
<li><strong>Outbound Channel Adapter（出站通道适配器）</strong>：<ul>
<li><strong>作用</strong>：Outbound Channel Adapter  负责将消息从 Spring Integration 流程中取出并传递给外部系统。</li>
<li><strong>例子</strong>：一个例子是文件适配器（File Outbound Channel Adapter），它将消息的内容写入文件。另一个例子是 JMS 出站适配器，用于将消息发送到 JMS 队列。</li>
</ul>
</li>
</ul>
</li>
<li>Gateways（网关） —Pass data into an integration flow via an interface<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231123212410022.png"><span class="image-caption">image-20231123212410022</span></li>
</ul>
</li>
</ul>
<h1 id="Lecture-13-反应式编程"><a href="#Lecture-13-反应式编程" class="headerlink" title="Lecture 13 反应式编程"></a>Lecture 13 反应式编程</h1><p>什么是Reactor、java NIO、netty</p>
<ul>
<li>Reactor是一个反应式编程库，用于构建异步和非阻塞的应用程序。</li>
<li>Java NIO是Java平台提供的非阻塞I&#x2F;O编程模型，用于提高I&#x2F;O操作的性能和并发能力。</li>
<li>Netty则是基于Java NIO的网络应用程序框架，提供了高性能和可定制的网络编程API。</li>
<li>这些技术和框架都有助于构建高效的异步和非阻塞的应用程序和网络服务。</li>
</ul>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ul>
<li>命令式编程范式<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207183004199.png"><span class="image-caption">image-20231207183004199</span></li>
<li>强调顺序，强调怎么做</li>
</ul>
</li>
<li>反应式编程范式<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207190905257.png"><span class="image-caption">image-20231207190905257</span></li>
<li>关注数据流和事件变化，强调什么要做</li>
<li>将计算看作是一系列数据流的转换和响应事件的触发。</li>
</ul>
</li>
<li>声明式编程可以应用于多种编程范式。注重问题的描述和逻辑<ul>
<li>函数式编程是一种常见的声明式编程范式，强调使用函数作为基本的构建块来解决问题，并避免可变状态和副作用。</li>
<li>函数式编程和反应式关系紧密</li>
</ul>
</li>
</ul>
<p>解决了什么问题</p>
<ul>
<li>IO密集型场景，减少等待，管理多线程。<ul>
<li>IO：远程通信、内存读写</li>
</ul>
</li>
<li>用尽量少的线程，解决多请求。事件队列<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207191850202.png"><span class="image-caption">image-20231207191850202</span></li>
</ul>
</li>
</ul>
<h2 id="Reactor（重要）"><a href="#Reactor（重要）" class="headerlink" title="Reactor（重要）"></a>Reactor（重要）</h2><p>Reactive Streams：</p>
<ul>
<li><p>一套规范，供无阻塞回压的异步流处理标准</p>
<ul>
<li>回压是指当生产者生成数据的速度大于消费者处理数据的速度时，消费者如何向生产者发出信号以控制数据流的速度。背压机制是为了解决这种情况下的流量控制问题，以确保消费者能够有效地处理数据，而不会被淹没或溢出</li>
</ul>
</li>
<li><p>与jdk的stream的区别：java的stream是同步的</p>
</li>
<li><p>jdk的反应式编程叫做Flow</p>
</li>
</ul>
<p>Reactor</p>
<ul>
<li>Spring Pivotal团队提供的<strong>响应式编程的Java实现</strong></li>
</ul>
<p>Spring WebFlux</p>
<ul>
<li>基于响应式编程的Web应用程序的开发。</li>
<li>类似于Spring MVC的编程模型，但不基于servlet</li>
</ul>
<h2 id="反应式流规范定义的4个接口（-重要）"><a href="#反应式流规范定义的4个接口（-重要）" class="headerlink" title="反应式流规范定义的4个接口（++重要）"></a>反应式流规范定义的4个接口（++重要）</h2><p>问答题</p>
<p>注意①②③④⑤</p>
<p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207183850643.png"><span class="image-caption">image-20231207183850643</span></p>
<ol>
<li>Publisher（发布者）：表示数据的<strong>生产者</strong>，可以发布数据流。<ol>
<li>submit：发布数据给subscription，<strong>每个subscriber对应一个subscription</strong></li>
<li>subscribe：与下一个订阅者建立连接</li>
</ol>
</li>
<li>Subscriber（订阅者）：表示数据的<strong>消费者</strong>，可以订阅并处理数据流。<ol>
<li>onSubscribe：publisher告诉订阅者，建立连接</li>
<li>onNext：订阅者获取下一个数据。<strong>背压调节流速</strong></li>
<li>onError：告诉订阅者出错</li>
<li>onComplete：告诉订阅者结束</li>
</ol>
</li>
<li>Subscription（订阅关系）：一个协调者，纽带。表示订阅者与发布者之间的连接，用于控制数据流的请求和取消订阅。<ol>
<li>request，subscriber请求数据</li>
<li>cancel</li>
</ol>
</li>
<li>Processor（处理器）：表示一个中间组件，<strong>同时具有发布者和订阅者</strong>的功能，可以将数据进行<strong>转换、过滤等</strong>操作。<ol>
<li>extends Publisher,Subscriber</li>
</ol>
</li>
</ol>
<h2 id="Flux-和-Mono"><a href="#Flux-和-Mono" class="headerlink" title="Flux 和 Mono"></a>Flux 和 Mono</h2><p>Flux和Mono是Reactor库中的两个核心类，用于支持反应式流编程模型。</p>
<ul>
<li>Flux：Flux是一个表示0到N个元素的异步序列的类。它类似于Java 8中的Stream，但具有异步和背压控制的能力。Flux可以用于表示多个值的流，可以是有限的，也可以是无限的。它可以发出元素，同时也可以处理背压，以确保在消费者准备好接收时进行数据流控制。</li>
<li>Mono：Mono是一个表示0或1个元素的异步序列的类。它类似于Flux，但只能发出零个或一个元素。Mono可以用于表示单个值的流，例如数据库查询、HTTP请求的响应等。它也可以处理背压，确保在消费者准备好接收时进行数据流控制</li>
</ul>
<p>消息</p>
<ul>
<li>正常的包含元素的消息、序列结束的消息和序列出错的消息</li>
<li>和Integration消息区别：没有消息Head和Body之分</li>
<li>和RabbitMQ等中间件区别：不需要序列化和反序列化，因为只在JVM中流动</li>
</ul>
<p>四种操作</p>
<ul>
<li><p>创建操作</p>
<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207202800486.png"><span class="image-caption">image-20231207202800486</span></li>
<li>根据对象&#x2F;集合&#x2F;迭代器，甚至是时间间隔（interval）创建。<ul>
<li>消费时，多线程自动编排</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207203538187.png"><span class="image-caption">ww</span></li>
</ul>
</li>
</ul>
</li>
<li><p>组合操作</p>
<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207205111813.png"><span class="image-caption">image-20231207205111813</span><ul>
<li>merge：合并同类型</li>
<li>zip：合并不同类型到tuple，也可以自己改造元素</li>
<li>first：只看第一个有数据的流</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207212923617.png"><span class="image-caption">image-20231207212923617</span></li>
</ul>
</li>
</ul>
</li>
<li><p>过滤操作</p>
<ul>
<li>Predicate：返回True或False</li>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207213307397.png"><span class="image-caption">image-20231207213307397</span><ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207213359092.png"><span class="image-caption">image-20231207213359092</span></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>转换操作（重要）</strong></p>
<ul>
<li><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207213626300.png"><span class="image-caption">image-20231207213626300</span></p>
</li>
<li><p>map：转换类型，<strong>返回的是数据</strong></p>
<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207213646882.png"><span class="image-caption">image-20231207213646882</span></li>
</ul>
</li>
<li><p>flatMap：<strong>返回的是流</strong>，所以类型是Mono&#x2F;Flux</p>
<ul>
<li><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207214205506.png"><span class="image-caption">image-20231207214205506</span></p>
<ul>
<li>Schedulers：可以决定是否并行，顺序不可控</li>
</ul>
</li>
<li><p><strong>本质上是扁平化，将多个流化为一个流。在多重流时可以并发处理</strong></p>
</li>
<li><p><img src="/C:/Users/lar/AppData/Roaming/Typora/typora-user-images/image-20231208013716522.png"><span class="image-caption">image-20231208013716522</span></p>
</li>
</ul>
</li>
<li><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207214531371.png"><span class="image-caption">image-20231207214531371</span></p>
</li>
<li><p>返回分组（List）的流。类似MapReduce</p>
<ul>
<li><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207214827674.png"><span class="image-caption">image-20231207214827674</span></li>
</ul>
</li>
</ul>
</li>
<li><p>逻辑操作</p>
<ul>
<li><img src="/C:/Users/lar/AppData/Roaming/Typora/typora-user-images/image-20231208014251456.png"><span class="image-caption">image-20231208014251456</span></li>
<li>Boolean也是流</li>
</ul>
</li>
</ul>
<h1 id="Lecture-14-WebFlux"><a href="#Lecture-14-WebFlux" class="headerlink" title="Lecture 14 WebFlux"></a>Lecture 14 WebFlux</h1><h1 id="WebFlux"><a href="#WebFlux" class="headerlink" title="WebFlux"></a>WebFlux</h1><p><img src="https://lar-blog.oss-cn-nanjing.aliyuncs.com/picGo_img/AppData/Roaming/Typora/typora-user-images/image-20231207200211792.png"><span class="image-caption">image-20231207200211792</span></p>
<ul>
<li>必须Subscribe才能操作数据</li>
</ul>
<h2 id="R2DBC"><a href="#R2DBC" class="headerlink" title="R2DBC"></a>R2DBC</h2>
      </section>
      <section class="extra">
        
        
        
        
  <nav class="nav">
    <a href="/2023/12/11/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/"><i class="iconfont iconleft"></i>数理逻辑-一阶逻辑(模型论角度)-学习笔记</a>
    <a href="/2023/12/10/Index-ART/">Adaptive radix tree：高效自适应树状索引结构<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
        <section class="comments">
  
    <div class="btn" id="comments-btn">查看评论</div>
  
  
<div id="valine"></div>
<script defer src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
  window.onload = function () {
    var loadValine = function () {
      new Valine({
        el: '#valine',
        app_id: "PpvhPeJzC7vUJ6njgvlVg8fG-gzGzoHsz",
        app_key: "M2Wo3xv2VtfNl7ttQQ8csMPT",
        placeholder: "畅所欲言！",
        avatar: "mp",
        pageSize: "10",
        lang: "zh-CN",
      });
    }
    if ( true ) {
      $("#comments-btn").on("click", function () {
        $(this).hide();
        loadValine();
      });
    } else {
      loadValine();
    }
  };
</script>

</section>
      
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Lecture-1-%E7%AC%AC%E4%B8%80%E4%B8%AASpring-boot%E7%A8%8B%E5%BA%8F"><span class="toc-text">Lecture 1 第一个Spring boot程序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lecture-2-spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-text">Lecture 2 spring依赖注入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E9%85%8D%E7%BD%AEBean%E6%96%B9%E5%BC%8F"><span class="toc-text">三种配置Bean方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">Bean的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90%EF%BC%88%E4%BC%98%E5%85%88%EF%BC%89%EF%BC%9A"><span class="toc-text">自动化配置例子（优先）：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lecture-3-AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B"><span class="toc-text">Lecture 3 AOP切面编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9%EF%BC%88cross-cutting-concern%EF%BC%89"><span class="toc-text">横切关注点（cross-cutting concern）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP%E6%9C%AF%E8%AF%AD"><span class="toc-text">AOP术语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%9F%A5-Advice%EF%BC%89%E7%B1%BB%E5%9E%8B"><span class="toc-text">通知(Advice）类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E7%82%B9%E6%8C%87%E7%A4%BA%E5%99%A8"><span class="toc-text">切点指示器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lecture-4-spring-MVC"><span class="toc-text">Lecture 4 spring MVC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#model-view-control"><span class="toc-text">model -view-control</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A"><span class="toc-text">模型数据绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%88View-Controller%EF%BC%89"><span class="toc-text">使用视图控制器（View Controller）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lecture-5-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">Lecture 5 数据持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDBC"><span class="toc-text">JDBC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDBC-template"><span class="toc-text">JDBC template</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90TABLE"><span class="toc-text">生成TABLE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Repository%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">Repository的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="toc-text">异常体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JPA"><span class="toc-text">JPA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90TABLE-1"><span class="toc-text">生成TABLE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#repository%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95"><span class="toc-text">repository查询方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%A5%BD%E5%A4%84"><span class="toc-text">两个好处</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lecture-6-%E9%9D%9E%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">Lecture 6 非关系数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MongeDB"><span class="toc-text">MongeDB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis"><span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#web%E8%AF%B7%E6%B1%82%E4%BF%9D%E6%8A%A4"><span class="toc-text">web请求保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2CSRF%E6%94%BB%E5%87%BB"><span class="toc-text">阻止CSRF攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="toc-text">获取用户信息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lecture-8-%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE"><span class="toc-text">Lecture 8  属性配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">属性使用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Https%EF%BC%88%E8%80%83%E8%AF%95%E7%95%A5"><span class="toc-text">Https（考试略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81%EF%BC%88%E8%80%83%E8%AF%95%E7%95%A5"><span class="toc-text">单双向验证（考试略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%98%E9%92%A5%E9%85%8D%E7%BD%AE%EF%BC%88%E8%80%83%E8%AF%95%E7%95%A5"><span class="toc-text">秘钥配置（考试略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SSL%E9%85%8D%E7%BD%AE%EF%BC%88%E8%80%83%E8%AF%95%E7%95%A5"><span class="toc-text">SSL配置（考试略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97"><span class="toc-text">配置日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7"><span class="toc-text">自定义配置属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BF%80%E6%B4%BB%E4%B8%8D%E5%90%8C%E9%85%8D%E7%BD%AE-Spring-profile"><span class="toc-text">激活不同配置 Spring profile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Actuator"><span class="toc-text">Actuator</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lecture-9-RESTful-API"><span class="toc-text">Lecture 9 RESTful API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#K8s"><span class="toc-text">K8s</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#REST%E5%8E%9F%E5%88%99%EF%BC%88%E9%87%8D%E8%A6%81"><span class="toc-text">REST原则（重要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AFvue"><span class="toc-text">前端vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MVVM%E6%A8%A1%E5%9E%8B"><span class="toc-text">MVVM模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#REST-API"><span class="toc-text">REST API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%B3%A8%E8%A7%A3"><span class="toc-text">一些注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82"><span class="toc-text">请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94"><span class="toc-text">响应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8"><span class="toc-text">消息转换器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BC%A0%E5%8F%82%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">前后端传参的四种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring-boot-starter-data-rest"><span class="toc-text">spring-boot-starter-data-rest</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RestTemplate%EF%BC%88%E4%B8%8D%E8%80%83"><span class="toc-text">RestTemplate（不考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Feign%EF%BC%88%E4%B8%8D%E8%80%83"><span class="toc-text">Feign（不考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lecture-10-OAuth2"><span class="toc-text">Lecture 10 OAuth2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JWT%E3%80%81JWK"><span class="toc-text">JWT、JWK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%88%E6%9D%83%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">授权服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">资源服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">开发客户端</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lecture-11-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text">Lecture 11 消息中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ActiveMQ"><span class="toc-text">ActiveMQ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ"><span class="toc-text">RabbitMQ</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lecture-12-spring-integration"><span class="toc-text">Lecture 12 spring integration</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%AE%80%E9%9B%86%E6%88%90%E6%B5%81%E7%9A%84%E4%BA%94%E4%B8%AA%E9%83%A8%E5%88%86"><span class="toc-text">最简集成流的五个部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E6%88%90%E6%B5%81%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="toc-text">集成流的组件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lecture-13-%E5%8F%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-text">Lecture 13 反应式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-text">对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reactor%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-text">Reactor（重要）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%BA%94%E5%BC%8F%E6%B5%81%E8%A7%84%E8%8C%83%E5%AE%9A%E4%B9%89%E7%9A%844%E4%B8%AA%E6%8E%A5%E5%8F%A3%EF%BC%88-%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-text">反应式流规范定义的4个接口（++重要）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flux-%E5%92%8C-Mono"><span class="toc-text">Flux 和 Mono</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lecture-14-WebFlux"><span class="toc-text">Lecture 14 WebFlux</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#WebFlux"><span class="toc-text">WebFlux</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#R2DBC"><span class="toc-text">R2DBC</span></a></li></ol></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="tencent://message/?Menu=yes&uin=1538618464 "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#12B7F5'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconQQ "></i>
      </a><a 
        href="javascript:; "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#09BB07'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconwechat-fill "></i>
      </a><a 
        href="https://www.instagram.com/liang_anran/ "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#DA2E76'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconinstagram "></i>
      </a><a 
        href="https://github.com/lar0129/lar0129.github.io "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a><a 
        href="mailto:anran.liang@sjtu.edu.cn "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#DA2E76'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconmail "></i>
      </a></div>
  
    <div class="footer-copyright">Created by Anran with 💗 <br> <p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a> theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p> @2022-2025</div>
  
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
  
    
<script src="/js/color-mode.js"></script>

  
  
</body>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>





  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>